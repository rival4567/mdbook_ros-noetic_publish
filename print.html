<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ROS-Noetic-Tutorials</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="learn.html"><strong aria-hidden="true">1.</strong> Learn</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/main.html"><strong aria-hidden="true">1.1.</strong> ROS Basics with Turtlesim</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Workspace/main.html"><strong aria-hidden="true">1.1.1.</strong> ROS Workspace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Workspace/create_a_catkin_workspace.html"><strong aria-hidden="true">1.1.1.1.</strong> Create a Catkin Workspace</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Package/main.html"><strong aria-hidden="true">1.1.2.</strong> ROS Package</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Package/create_a_ros_package.html"><strong aria-hidden="true">1.1.2.1.</strong> Create a ROS Package</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/main.html"><strong aria-hidden="true">1.1.3.</strong> ROS Nodes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/create_a_ros_node.html"><strong aria-hidden="true">1.1.3.1.</strong> Create a ROS Node</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/command_rosrun.html"><strong aria-hidden="true">1.1.3.2.</strong> Command: rosrun</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/command_rosnode.html"><strong aria-hidden="true">1.1.3.3.</strong> Command: rosnode</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Master/main.html"><strong aria-hidden="true">1.1.4.</strong> ROS Master</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/main.html"><strong aria-hidden="true">1.1.5.</strong> ROS Parameter Server</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/load_parameters_using_yaml_file.html"><strong aria-hidden="true">1.1.5.1.</strong> Load Parameters using YAML file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/ros_node_to_get_and_set_parameters.html"><strong aria-hidden="true">1.1.5.2.</strong> Example #1: ROS Node to Get and Set Parameters</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/main.html"><strong aria-hidden="true">1.1.6.</strong> ROS Launch Files</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/create_a_ros_launch_file.html"><strong aria-hidden="true">1.1.6.1.</strong> Create a ROS Launch File</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_two_ros_nodes.html"><strong aria-hidden="true">1.1.6.2.</strong> Example #1: Launch two ROS Nodes</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_turtle_in_forest.html"><strong aria-hidden="true">1.1.6.3.</strong> Example #2: Launch Turtle in Forest</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.html"><strong aria-hidden="true">1.1.6.4.</strong> Example #3: Load YAML</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_shell_script_and_ros_node.html"><strong aria-hidden="true">1.1.6.5.</strong> Example #4: Launch Shell Script and ROS Node</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/main.html"><strong aria-hidden="true">1.1.7.</strong> ROS Communication</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/main.html"><strong aria-hidden="true">1.1.7.1.</strong> ROS Topics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/main.html"><strong aria-hidden="true">1.1.7.1.1.</strong> Command: rostopic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/list.html"><strong aria-hidden="true">1.1.7.1.1.1.</strong> list</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/type_info_and_rosmsg.html"><strong aria-hidden="true">1.1.7.1.1.2.</strong> type, info and rosmsg</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/pub.html"><strong aria-hidden="true">1.1.7.1.1.3.</strong> pub</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/echo.html"><strong aria-hidden="true">1.1.7.1.1.4.</strong> echo</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/pub_sub_with_custom_message.html"><strong aria-hidden="true">1.1.7.1.2.</strong> Example #1: Pub-Sub with Custom Message</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/main.html"><strong aria-hidden="true">1.1.7.2.</strong> ROS Services</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/create_a_srv_file.html"><strong aria-hidden="true">1.1.7.2.1.</strong> Create a srv file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/test_ros_services_server_and_client.html"><strong aria-hidden="true">1.1.7.2.2.</strong> Test ROS Services - Server and Client</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/main.html"><strong aria-hidden="true">1.1.7.3.</strong> ROS Actions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/create_a_action_message_file.html"><strong aria-hidden="true">1.1.7.3.1.</strong> Create an action message file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/simple_action_server_and_client.html"><strong aria-hidden="true">1.1.7.3.2.</strong> Simple Action Server & Client</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/action_server_and_client.html"><strong aria-hidden="true">1.1.7.3.3.</strong> Action Server & Client</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/ros_actions_walkthrough_videos.html"><strong aria-hidden="true">1.1.7.3.4.</strong> ROS Actions Walkthrough Videos</a></li></ol></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_TF/main.html"><strong aria-hidden="true">1.1.8.</strong> ROS TF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_TF/ros_tf_using_turtlesim.html"><strong aria-hidden="true">1.1.8.1.</strong> ROS tf using turtlesim</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/main.html"><strong aria-hidden="true">1.1.9.</strong> Miscellaneous</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph.html"><strong aria-hidden="true">1.1.9.1.</strong> Rqt_graph</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/plot_juggler.html"><strong aria-hidden="true">1.1.9.2.</strong> Plot juggler</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/ros_bags.html"><strong aria-hidden="true">1.1.9.3.</strong> ROS Bags</a></li></ol></li></ol></li><li class="chapter-item "><a href="Additional_Sections/main.html"><strong aria-hidden="true">1.2.</strong> Additional Sections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Additional_Sections/configuring_your_ros_environment.html"><strong aria-hidden="true">1.2.1.</strong> Configuring your ROS environment</a></li><li class="chapter-item "><a href="Additional_Sections/introducing_turtlesim_and_rqt.html"><strong aria-hidden="true">1.2.2.</strong> Introducing turtlesim and rqt</a></li><li class="chapter-item "><a href="Additional_Sections/ros_nodes.html"><strong aria-hidden="true">1.2.3.</strong> Understanding ROS nodes</a></li><li class="chapter-item "><a href="Additional_Sections/ros_topics.html"><strong aria-hidden="true">1.2.4.</strong> Understanding ROS topics</a></li><li class="chapter-item "><a href="Additional_Sections/ros_services.html"><strong aria-hidden="true">1.2.5.</strong> Understanding ROS services</a></li></ol></li><li class="chapter-item "><a href="ROS_with_Gazebo/main.html"><strong aria-hidden="true">1.3.</strong> ROS with Gazebo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_with_Gazebo/installation.html"><strong aria-hidden="true">1.3.1.</strong> Installation Guide</a></li><li class="chapter-item "><a href="ROS_with_Gazebo/Gazebo_Simulator/main.html"><strong aria-hidden="true">1.3.2.</strong> Gazebo Simulator</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_with_Gazebo/Gazebo_Simulator/knocking_one_pin.html"><strong aria-hidden="true">1.3.2.1.</strong> Example: Knock down the bowling pin</a></li></ol></li><li class="chapter-item "><a href="ROS_with_Gazebo/rviz.html"><strong aria-hidden="true">1.3.3.</strong> RViz</a></li><li class="chapter-item "><a href="ROS_with_Gazebo/URDF/main.html"><strong aria-hidden="true">1.3.4.</strong> URDF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_with_Gazebo/URDF/visual_robot_model_with_urdf.html"><strong aria-hidden="true">1.3.4.1.</strong> Visual Robot Model with URDF</a></li><li class="chapter-item "><a href="ROS_with_Gazebo/URDF/defining_joints_in_urdf.html"><strong aria-hidden="true">1.3.4.2.</strong> Defining Movable Joints in URDF</a></li><li class="chapter-item "><a href="ROS_with_Gazebo/URDF/physical_and_collision_properties_in_urdf_model.html"><strong aria-hidden="true">1.3.4.3.</strong> Adding Physical and Collision Properties to a URDF Model</a></li><li class="chapter-item "><a href="ROS_with_Gazebo/URDF/urdf_vs_sdf.html"><strong aria-hidden="true">1.3.4.4.</strong> Difference between URDF and SDF</a></li></ol></li><li class="chapter-item "><a href="ROS_with_Gazebo/XACRO/main.html"><strong aria-hidden="true">1.3.5.</strong> XACRO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_with_Gazebo/XACRO/using_xacro_in_a_urdf_file.html"><strong aria-hidden="true">1.3.5.1.</strong> Using Xacro to Clean Up a URDF File</a></li></ol></li><li class="chapter-item "><a href="ROS_with_Gazebo/Gazebo_Plugins/main.html"><strong aria-hidden="true">1.3.6.</strong> Gazebo Plugins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_with_Gazebo/Gazebo_Plugins/using_urdf_in_gazebo.html"><strong aria-hidden="true">1.3.6.1.</strong> Using URDF in Gazebo</a></li></ol></li></ol></li><li class="chapter-item "><a href="Micromouse/main.html"><strong aria-hidden="true">1.4.</strong> Micromouse</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Micromouse/installation.html"><strong aria-hidden="true">1.4.1.</strong> Installation</a></li><li class="chapter-item "><a href="Micromouse/creating_your_own_micromouse.html"><strong aria-hidden="true">1.4.2.</strong> Creating your robot</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/main.html"><strong aria-hidden="true">1.4.3.</strong> Example Codes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Micromouse/Example_Codes/reading_laser_scan.html"><strong aria-hidden="true">1.4.3.1.</strong> Reading Laser Scan</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/use_diff_drive_to_move_micromouse.html"><strong aria-hidden="true">1.4.3.2.</strong> Differential Drive to move Micromouse</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/use_velocity_controllers_to_move_micromouse.html"><strong aria-hidden="true">1.4.3.3.</strong> Velocity Controller to move Micromouse</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/go_to_point.html"><strong aria-hidden="true">1.4.3.4.</strong> Go to point</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/maze_runner.html"><strong aria-hidden="true">1.4.3.5.</strong> Maze Runner</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/obstacle_avoidance.html"><strong aria-hidden="true">1.4.3.6.</strong> Obstacle Avoidance</a></li><li class="chapter-item "><a href="Micromouse/Example_Codes/follow_wall.html"><strong aria-hidden="true">1.4.3.7.</strong> Follow Wall</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="tasks/main.html"><strong aria-hidden="true">2.</strong> Tasks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task0/main.html"><strong aria-hidden="true">2.1.</strong> Task0</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task0/turtle-task.html"><strong aria-hidden="true">2.1.1.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task0/expected-output.html"><strong aria-hidden="true">2.1.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task0/recording-logs.html"><strong aria-hidden="true">2.1.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task0/solution.html"><strong aria-hidden="true">2.1.4.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task0/autoeval.html"><strong aria-hidden="true">2.1.5.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_2/main.html"><strong aria-hidden="true">2.2.</strong> Task2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_2/problem_statement.html"><strong aria-hidden="true">2.2.1.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_2/expected_output.html"><strong aria-hidden="true">2.2.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_2/recording-logs.html"><strong aria-hidden="true">2.2.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_2/solution.html"><strong aria-hidden="true">2.2.4.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_2/autoeval_script.html"><strong aria-hidden="true">2.2.5.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_bowling_game/main.html"><strong aria-hidden="true">2.3.</strong> Bowling Game</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_bowling_game/problem_statement.html"><strong aria-hidden="true">2.3.1.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_bowling_game/expected_output.html"><strong aria-hidden="true">2.3.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_bowling_game/recording_logs.html"><strong aria-hidden="true">2.3.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_bowling_game/solution.html"><strong aria-hidden="true">2.3.4.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_bowling_game/autoeval.html"><strong aria-hidden="true">2.3.5.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_micromouse/main.html"><strong aria-hidden="true">2.4.</strong> Micromouse</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_micromouse/problem_statement.html"><strong aria-hidden="true">2.4.1.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_micromouse/expected_output.html"><strong aria-hidden="true">2.4.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_micromouse/recording_logs.html"><strong aria-hidden="true">2.4.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_micromouse/NOT_FOR_SHARING/main.html"><strong aria-hidden="true">2.4.4.</strong> NOT FOR SHARING</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_micromouse/NOT_FOR_SHARING/solution.html"><strong aria-hidden="true">2.4.4.1.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_micromouse/NOT_FOR_SHARING/autoeval.html"><strong aria-hidden="true">2.4.4.2.</strong> Autoeval script</a></li><li class="chapter-item "><a href="tasks/task_micromouse/NOT_FOR_SHARING/add_more_mazes.html"><strong aria-hidden="true">2.4.4.3.</strong> Add more maze</a></li></ol></li></ol></li><li class="chapter-item "><a href="tasks/task_simbhabot/main.html"><strong aria-hidden="true">2.5.</strong> Simbhabot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_simbhabot/installation.html"><strong aria-hidden="true">2.5.1.</strong> Installation</a></li><li class="chapter-item "><a href="tasks/task_simbhabot/problem_statement.html"><strong aria-hidden="true">2.5.2.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_simbhabot/expected_output.html"><strong aria-hidden="true">2.5.3.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_simbhabot/recording_logs.html"><strong aria-hidden="true">2.5.4.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_simbhabot/solution.html"><strong aria-hidden="true">2.5.5.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_simbhabot/autoeval.html"><strong aria-hidden="true">2.5.6.</strong> Autoeval Script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_line_follower/main.html"><strong aria-hidden="true">2.6.</strong> Line-follower Robot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_line_follower/problem_statement.html"><strong aria-hidden="true">2.6.1.</strong> Problem Statement</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_line_follower/create_robot.html"><strong aria-hidden="true">2.6.1.1.</strong> Create Robot Model</a></li><li class="chapter-item "><a href="tasks/task_line_follower/create_script.html"><strong aria-hidden="true">2.6.1.2.</strong> Create The Script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_line_follower/expected_output.html"><strong aria-hidden="true">2.6.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_line_follower/recording-logs.html"><strong aria-hidden="true">2.6.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_line_follower/solution.html"><strong aria-hidden="true">2.6.4.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_line_follower/autoeval.html"><strong aria-hidden="true">2.6.5.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_vd/main.html"><strong aria-hidden="true">2.7.</strong> Vitrana Drone</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_vd/installation.html"><strong aria-hidden="true">2.7.1.</strong> installation</a></li><li class="chapter-item "><a href="tasks/task_vd/learn.html"><strong aria-hidden="true">2.7.2.</strong> learing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_vd/learn_edrone_model.html"><strong aria-hidden="true">2.7.2.1.</strong> Exploring eDrone ROS-Gazebo model</a></li><li class="chapter-item "><a href="tasks/task_vd/path_planning.html"><strong aria-hidden="true">2.7.2.2.</strong> Path planning and navigation</a></li></ol></li><li class="chapter-item "><a href="tasks/task_vd/problem_statement.html"><strong aria-hidden="true">2.7.3.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_vd/expected_output.html"><strong aria-hidden="true">2.7.4.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_vd/recording-logs.html"><strong aria-hidden="true">2.7.5.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_vd/solution.html"><strong aria-hidden="true">2.7.6.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_vd/autoeval.html"><strong aria-hidden="true">2.7.7.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/main.html"><strong aria-hidden="true">2.8.</strong> UR5 Multiple Arm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/installation.html"><strong aria-hidden="true">2.8.1.</strong> Installation</a></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/problem_statement.html"><strong aria-hidden="true">2.8.2.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/expected_output.html"><strong aria-hidden="true">2.8.3.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/recording_logs.html"><strong aria-hidden="true">2.8.4.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/solution.html"><strong aria-hidden="true">2.8.5.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task_ur5_multiple_arm/autoeval.html"><strong aria-hidden="true">2.8.6.</strong> Autoeval script</a></li></ol></li><li class="chapter-item "><a href="tasks/task_sahayak_bot/main.html"><strong aria-hidden="true">2.9.</strong> Sahayak Bot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task_sahayak_bot/installation.html"><strong aria-hidden="true">2.9.1.</strong> Installation</a></li><li class="chapter-item "><a href="tasks/task_sahayak_bot/output.html"><strong aria-hidden="true">2.9.2.</strong> Output</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ROS-Noetic-Tutorials</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="learn"><a class="header" href="#learn">Learn</a></h1>
<ul>
<li>
<p>In this section you will find all the necessary learning resources needed.</p>
</li>
<li>
<p>Relevant sample codes are also provided throughout this section which are downloadable also.</p>
</li>
</ul>
<hr />
<center><h2 id="happy-learning-"><a class="header" href="#happy-learning-">Happy Learning !!!</a></h2><center><div style="break-before: page; page-break-before: always;"></div><h1 id="ros-basics-with-turtlesim"><a class="header" href="#ros-basics-with-turtlesim">ROS Basics with Turtlesim</a></h1>
<h2 id="difficulty-beginner"><a class="header" href="#difficulty-beginner">Difficulty: Beginner</a></h2>
<hr />
<p>The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it’s all open source.</p>
<p>These tutorials are a collection of step-by-step instructions meant to steadily build skills.</p>
<p>The best way to approach the tutorials is to walk through them for the first time in order, as they build off of each other and are not meant to be comprehensive documentation.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="catkin-workspace"><a class="header" href="#catkin-workspace">Catkin Workspace</a></h1>
<ul>
<li><strong>catkin</strong> is the official build system of ROS and the successor to the original ROS build system, rosbuild.</li>
<li><strong>catkin</strong> combines CMake macros and Python scripts to provide some functionality on top of CMake’s normal workflow.</li>
<li>catkin was designed to be more conventional than rosbuild, allowing for better distribution of packages, better cross-compiling support, and better portability.</li>
</ul>
<h2 id="src"><a class="header" href="#src">src</a></h2>
<ul>
<li>the <code>src</code> folder contains the source code of catkin packages. This is where you can extract/checkout/clone source code for the packages you want to build.</li>
<li>Each folder within the <code>src</code> folder contains one or more catkin packages. This folder should remain unchanged by configuring, building, or installing.</li>
<li>The root of the <code>src</code> folder contains a symbolic link to catkin’s boiler-plate ‘toplevel’ CMakeLists.txt file. This file is invoked by CMake during the configuration of the catkin projects in the workspace. It can be created by calling <code>catkin_init_workspace</code> in the <code>src</code> folder directory. When we execute the <code>catkin_make</code> command from the workspace folder, it checks inside the <code>src</code> folder and builds each package.</li>
</ul>
<h2 id="build"><a class="header" href="#build">build</a></h2>
<ul>
<li>The <code>build</code> folder is where CMake is invoked to <code>build</code> the catkin packages in the <code>src</code> folder.</li>
<li>CMake and catkin keep their cache information and other intermediate files here.</li>
<li>The <code>build</code> folder does not have to be contained within the workspace nor does it have to be outside of the <code>src</code> folder, but this is recommended.</li>
</ul>
<h2 id="devel"><a class="header" href="#devel">devel</a></h2>
<ul>
<li>The development folder (or <code>devel</code> folder) is where built targets are placed before installed.</li>
<li>The way targets are organized in the <code>devel</code> folder is the same as their layout when they are installed.</li>
<li>This provides a useful testing and development environment which does not require invoking the installation step.</li>
<li>The location of the <code>devel</code> folder is controlled by a catkin specific CMake variable called <code>CATKIN_DEVEL_PREFIX</code>, and it defaults to build/devel folder.</li>
<li>This is the default behavior because it might be confusing to CMake users if they invoked CMake in a <code>build</code> folder and that modified things outside of the current directory.</li>
<li>It is recommended, however, to set the <code>devel</code> folder directory to be a peer of the <code>build</code> folder directory.</li>
</ul>
<pre><code class="language-bash">source ~/&lt;workspace_name&gt;/devel/setup.bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-catkin-workspace"><a class="header" href="#create-a-catkin-workspace">Create a Catkin Workspace</a></h1>
<ol>
<li>Open up the terminal <code>shortcut key: ctrl+alt+t</code>.</li>
<li>Create the root workspace directory. You can name your directory anything we are using <code>workspace</code> as the name this time.</li>
</ol>
<pre><code class="language-bash">cd ~/
mkdir -p ~/workspace/src
cd workspace
</code></pre>
<ol start="3">
<li>Run the following command:</li>
</ol>
<pre><code class="language-bash">catkin_make
</code></pre>
<ol start="4">
<li>The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in your workspace, it will create a CMakeLists.txt link in your ‘src’ folder.</li>
<li>Additionally, if you look in your current directory you should now have a ‘build’ and ‘devel’ folder.</li>
</ol>
<pre><code class="language-bash">ls
</code></pre>
<ol start="6">
<li>Now to make your workspace visible to ROS. Source the setup file in the devel directory.</li>
</ol>
<pre><code class="language-bash">source ~/catkin_ws/devel/setup.bash
</code></pre>
<p>By doing this, all the packages that you create inside the <code>src</code> folder will be visible to ROS.
7. This <code>setup.bash</code> file of your workspace must be source everytime when you want to use ROS packages created inside this workspace.</p>
<ol start="8">
<li>To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you’re in.</li>
</ol>
<pre><code class="language-bash">echo $ROS_PACKAGE_PATH
/home/youruser/catkin_ws/src:/opt/ros/noetic/share
</code></pre>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-package"><a class="header" href="#ros-package">ROS Package</a></h1>
<ul>
<li>ROS Packages according to ROS Wiki</li>
</ul>
<blockquote>
<p>Software in ROS is organized in packages. A package might contain ROS nodes, a ROS-independent library, a dataset, configuration files, a third-party piece of software, or anything else that logically constitutes a useful module. The goal of these packages it to provide this useful functionality in an easy-to-consume manner so that software can be easily reused. In general, ROS packages follow a "Goldilocks" principle: enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software.</p>
</blockquote>
<hr>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/Packages">Packages</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-package"><a class="header" href="#create-a-ros-package">Create a ROS Package</a></h1>
<ul>
<li>This tutorial will demonstrate how to use the <code>catkin_create_pkg</code> script to create a new catkin package, and what you can do with it after it has been created.</li>
</ul>
<ol>
<li>
<p>First, navigate to the source space directory of the catkin workspace you’ve created.</p>
<pre><code class="language-bash">cd ~/workspace/src
</code></pre>
</li>
<li>
<p>Now, use the catkin_create_pkg script to create a new package called pkg_ros_basics which depends on std_msgs, roscpp, and rospy:</p>
<pre><code class="language-bash">catkin_create_pkg pkg_ros_basics std_msgs rospy roscpp
</code></pre>
<ul>
<li>
<p>This will create a beginner_tutorials folder which contains a <code>package.xml</code> and a <code>CMakeLists.txt</code>, which have been partially filled out with the information you gave <code>catkin_create_pkg</code>.</p>
</li>
<li>
<p><code>catkin_create_pkg</code> requires that you give it a <code>package_name</code> and optionally a list of dependencies on which that package depends:</p>
<pre><code class="language-bash">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Now, you need to build the packages in the catkin workspace:</p>
<pre><code class="language-bash">cd ~/workspace
catkin_make
</code></pre>
</li>
</ol>
<ul>
<li>Inside the package, there are <code>src</code> folder, <code>package.xml</code>, <code>CMakeLists.txt</code>, and the <code>include</code> folders.
<ul>
<li><strong>CMakeLists.txt</strong>: This file has all the commands to build the ROS source code inside the package and create the executable. For more information about CMakeLists visit <a href="http://wiki.ros.org/catkin/CMakeLists.txt">here</a>.</li>
<li><strong>package.xml</strong>: This is an XML file. It mainly contains the package dependencies, information, and so forth.</li>
<li><strong>src</strong>: The source code of ROS packages are kept in this folder.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-nodes"><a class="header" href="#ros-nodes">ROS Nodes</a></h1>
<ul>
<li>
<p>A ROS Node is a piece of software/executable that uses ROS to communicate with other ROS Nodes.</p>
</li>
<li>
<p>ROS Nodes are building block of any ROS Application.</p>
</li>
<li>
<p>For example, if you have a wall-following robot then one ROS Node could get distance sensor values and another node can control the motors of the robot. So, these two nodes will communicate with each other in order to move the robot.</p>
</li>
<li>
<p>You can write your entire ROS Application in a single node but having multiple nodes ensures that if a node crashes it won’t crash your entire ROS application.</p>
</li>
<li>
<p>In this eYRC Theme your job will be to write suitable ROS Nodes for your ROS Application.</p>
</li>
<li>
<p>A ROS package can have multiple ROS Nodes.</p>
</li>
<li>
<p>Python and C++ are majorly used to write ROS Nodes.</p>
</li>
<li>
<p>In this eYRC Theme we will use Python to write ROS Nodes.</p>
</li>
</ul>
<hr>
<h3 id="reference-1"><a class="header" href="#reference-1">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes">ROS WIki - Undertanding Nodes</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-node"><a class="header" href="#create-a-ros-node">Create a ROS Node</a></h1>
<p>In this section we will learn how to create a ROS Node inside <code>pkg_ros_basics</code> ROS Package which we created in the previous section.</p>
<ol>
<li>
<p>Navigate to <code>pkg_ros_basics</code>.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/pkg_ros_basics
</code></pre>
<p>OR</p>
<pre><code class="language-bash">roscd pkg_ros_basics
</code></pre>
<p><strong>NOTE</strong>: <code>roscd</code> will work only if you have sourced <code>setup.bash</code> of your catkin workspace.</p>
</li>
<li>
<p>Create a <code>scripts</code> folder for your Python scripts and navigate into the folder.</p>
<pre><code class="language-bash">mkdir scripts
cd scripts
</code></pre>
</li>
<li>
<p>Create a Python script called <code>node_hello_ros.py</code>.</p>
<pre><code class="language-bash">touch node_hello_ros.py
</code></pre>
</li>
<li>
<p>Open the script in any text-editor and start editing.</p>
<pre><code class="language-bash">gedit node_hello_ros.py
</code></pre>
</li>
<li>
<p>First line of all your Python ROS scripts should be the following shebang</p>
<pre><code class="language-bash">#!/usr/bin/env python
</code></pre>
</li>
<li>
<p>Now write a ROS Node to print <code>Hello World!</code> on the console.</p>
<pre><code class="language-python">#!/usr/bin/env python

import rospy


def main():    

# 1. Make the script a ROS Node.
rospy.init_node('node_hello_ros', anonymous=True)

# 2. Print info on console.
rospy.loginfo(&quot;Hello World!&quot;)

# 3. Keep the node alive till it is killed by the user.
rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
</li>
<li>
<p>Now you have to make this script an executable.</p>
<pre><code class="language-bash">sudo chmod +x node_hello_ros.py
</code></pre>
</li>
<li>
<p>Now in order to run your ROS Node,</p>
<ol>
<li>
<p>Open up a terminal and run ROS Master.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Once the roscore is up running, open a new termminal and run the ROS Node.</p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_hello_ros.py

</code></pre>
<p><strong>NOTE</strong>: This command will work only if you have sourced <code>setup.bash</code> of your catkin workspace either manually or using <code>.bashrc</code>.</p>
</li>
</ol>
</li>
<li>
<p>You should get some output like this,</p>
<pre><code class="language-bash">[INFO] [1601277063.968749]: Hello World!
</code></pre>
</li>
</ol>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="command-rosrun"><a class="header" href="#command-rosrun">Command: rosrun</a></h1>
<p><code>rosrun</code> allows you to run an executable in an arbitrary package from anywhere without having to give its full path or cd/roscd there first.</p>
<p>Usage:</p>
<pre><code class="language-bash">rosrun &lt;package&gt; &lt;executable&gt;
</code></pre>
<p><code>&lt;package&gt;</code> is nothing but the package name which you have created using <code>catkin_create_pkg</code> command or used any other package.</p>
<p><code>&lt;executable&gt;</code> is the python or cpp file.</p>
<h2 id="to-create-an-executable-python-file"><a class="header" href="#to-create-an-executable-python-file">To create an executable python file</a></h2>
<p>After creating a package, create a folder in the package names as <code>scripts</code> folder to store all the python files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir scripts
</code></pre>
<p>Here we can create python scripts by running this command by going into the <code>scripts</code> directory,</p>
<pre><code class="language-bash">cd scripts
touch filename.py
</code></pre>
<p>Now you can edit your python file and before running you have to make it executable by running this command once,</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;/scripts
chmod +x filename.py
</code></pre>
<h2 id="to-create-an-executable-cpp-file"><a class="header" href="#to-create-an-executable-cpp-file">To create an executable cpp file</a></h2>
<p>After creating a package, create a folder in the package names as <code>src</code> folder to store all the cpp files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir src
</code></pre>
<p>Here we can create cpp files by running this command by going into the <code>src</code> directory,</p>
<pre><code class="language-bash">cd src
touch filename.cpp
</code></pre>
<p>Now you can edit your cpp file , but for making it executable we have to edit the <code>CMakeLists.txt</code> file which is present in the package.</p>
<p>Add these few lines at the bottom of <code>CMakeLists.txt</code> file,</p>
<pre><code class="language-txt">add_executable(filename src/filename.cpp)
target_link_libraries(filename ${catkin_LIBRARIES})

</code></pre>
<p>Then run this command,</p>
<pre><code class="language-bash">cd ~/catkin_ws
catkin build
</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="command-rosnode"><a class="header" href="#command-rosnode">Command: rosnode</a></h1>
<p><code>rosnode</code> contains the rosnode command-line tool for displaying debug information about <a href="http://wiki.ros.org/Nodes">ROS Nodes</a>.</p>
<blockquote>
<p> Note: For quick information about any command, be that outside of ROS, simply type the command along with suffix `--h` or `-help`. This is a widely used concept among other Linux commands for quick references. Here's an example for `rosnode --h` command
</p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_1.png" alt="image" /></p>
<h2 id="list"><a class="header" href="#list">list</a></h2>
<p><code>rosnode list</code> displays a list of all current nodes.</p>
<p>Let’s figure out what argument the <code>list</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode list
</code></pre>
<p>Now the node named <code>talker</code>(node with word talker in it) will be printed on the terminal.
<img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_list.png" alt="image" /></p>
<h2 id="info"><a class="header" href="#info">info</a></h2>
<p><code>rosnode info /node_name</code> displays information about a node, including publications and subscriptions.</p>
<p>Let’s figure out what argument the <code>info</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode info &lt;talker_node&gt;
</code></pre>
<p>This should give details related to the particular node as shown below:</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_info.png" alt="image" /></p>
<h2 id="kill"><a class="header" href="#kill">kill</a></h2>
<p>IMPORTANT: rosnode kill is not guaranteed to succeed. Let’s figure out what argument the <code>kill</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode kill rosout &lt;talker_node&gt;

</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_kill.png" alt="image" /></p>
<p>Interactive mode. This enables you to select which node to kill from a numbered list, which is useful for killing anonymous nodes.</p>
<pre><code class="language-bash">rosnode kill
1. /rosout

Please enter the number of the node you wish to kill.
</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="ros-master"><a class="header" href="#ros-master">ROS Master</a></h1>
<ul>
<li>
<p>The ROS Master provides naming and registration services to the rest of the nodes in the ROS system.</p>
</li>
<li>
<p>As you know ROS Nodes are building blocks of any ROS Application. A single ROS Application may have multiple ROS Nodes which communicate with each other. </p>
</li>
<li>
<p>The role of the ROS Master is to enable individual ROS nodes to locate one another.</p>
</li>
<li>
<p>Once these nodes have located each other they communicate with each other peer-to-peer.</p>
</li>
<li>
<p>You can say, communication is established between nodes by the ROS Master. So, without ROS Master running ROS Nodes can not communicate with each other.</p>
</li>
</ul>
<h2 id="start-ros-master"><a class="header" href="#start-ros-master">Start ROS Master</a></h2>
<p>To start ROS Master you just have to enter the following command in the terminal.</p>
<pre><code class="language-bash">roscore
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Master/ros-master.png" alt="ros-master.png" /></p>
<p><code>roscore</code> is a collection of nodes and programs that are pre-requisites of a ROS-based system. You must have a roscore running in order for ROS nodes to communicate.</p>
<p>So <a href="http://wiki.ros.org/roscore">roscore</a> will start the following:</p>
<ol>
<li>ROS Master</li>
<li>ROS Parameter Server</li>
<li><code>rosout</code> Logging Node</li>
</ol>
<p>In the preceding output, you can see information about the computer, parameter which list the name (noetic) and version number of ROS distribution, and some other information.</p>
<h2 id="reading-assignment"><a class="header" href="#reading-assignment">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Master">ROS Wiki - Master</a></li>
<li><a href="http://wiki.ros.org/roscore">ROS Wiki - roscore</a></li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-parameter-server"><a class="header" href="#ros-parameter-server">ROS Parameter Server</a></h1>
<ul>
<li>
<p>You can think Parameter Server as a space where all the necessary data that needs to be shared among various ROS Nodes is stored.</p>
</li>
<li>
<p>Parameter Server runs inside ROS Master.</p>
</li>
<li>
<p>ROS Nodes can view and even modify data stored in the Parameter Server.</p>
</li>
<li>
<p>Typically Parameter Server is used to store configuration parameters.</p>
</li>
</ul>
<h2 id="reading-assignment-1"><a class="header" href="#reading-assignment-1">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Parameter%20Server">ROS Wiki - Parameter Server</a></li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-parameters-using-yaml-file"><a class="header" href="#load-parameters-using-yaml-file">Load Parameters using YAML file</a></h1>
<p>In this section we will learn how to load your own parameters in ROS Parameter Server using a YAML File.</p>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Navigate to <code>pkg_ros_basics</code>.</p>
<pre><code class="language-bash">cd ~/workspace/src/pkg_ros_basics
</code></pre>
<p>OR</p>
<pre><code class="language-bash">roscd pkg_ros_basics
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: <code>roscd</code> will work only if you have sourced <code>setup.bash</code> of your catkin workspace.</p>
</blockquote>
</li>
<li>
<p>Create a <code>config</code> folder for your Python scripts and navigate into the folder.</p>
<pre><code class="language-bash">mkdir config
cd config
</code></pre>
</li>
<li>
<p>Create a configuration YAML file called <code>config_my.yaml</code>.</p>
<pre><code class="language-bash">touch config_my.yaml
</code></pre>
</li>
<li>
<p>Open the script in any text-editor and start editing.</p>
<pre><code class="language-bash">gedit config_my.yaml
</code></pre>
</li>
<li>
<p>Now fill your config file.</p>
<pre><code class="language-yaml"># Comment: config_my.yaml Configuration
details:
    name:
        first: &quot;Heisenberg&quot; # First Name
        last: &quot;White&quot; # Last Name
     contact:
         address: &quot;ABQ Street, ABQ&quot; # Address
         phone: 77777    # Contact
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/config_my.yaml" download><button>Download</button></a></center>
<ul>
<li>
<p>ROS Build system will create a Python Dictionary called <code>details</code>.</p>
</li>
<li>
<p>This dictionary will have two keys,</p>
<ol>
<li>Dictionary <code>name</code></li>
<li>Dictionary <code>contact</code></li>
</ol>
</li>
<li>
<p>In your ROS Node you can use <code>rospy</code> to get parameters stored in this <code>config_my</code> dictionary.</p>
<pre><code class="language-python">param_config_my = rospy.get_param('details')

first_name = param_config_my['name']['first']
phone = param_config_my['contact']['phone']
</code></pre>
</li>
</ul>
<br />
</li>
<li>
<p>Now if you want to load the parameters defined in the YAML file you have to first start the ROS Parameter Server.</p>
<p>Open up a new terminal and enter the following.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Now load your parameters.</p>
<pre><code class="language-bash">rosparam load config_my.yaml
</code></pre>
</li>
<li>
<p>Now get the list of parameters loaded in your ROS Parameter Server.</p>
<pre><code class="language-bash">rosparam list
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">/details/contact/address
/details/contact/phone
/details/name/first
/details/name/last
/rosdistro
/roslaunch/uris/host_ros_noetic__35261
/rosversion
/run_id
</code></pre>
<p>Here you can see the first four parameters are loaded from our <code>config_my.yaml</code> file.</p>
</li>
<li>
<p>Now to view the content of any parameter do the following.</p>
<pre><code class="language-bash">rosparam get /details/contact/phone
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">77777
</code></pre>
<p>This is the value which we defined in the <code>config_my.yaml</code> file.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/rosparam-load-config_my.png" alt="rosparam-load-config_my.png" /></p>
</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-ros-node-to-get-and-set-parameters"><a class="header" href="#example-1-ros-node-to-get-and-set-parameters">Example #1: ROS Node to Get and Set Parameters</a></h1>
<h2 id="aim"><a class="header" href="#aim">Aim</a></h2>
<p>To write a ROS Node to read <code>config_my.yaml</code> file loaded in ROS Parameter Server (<a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/load_parameters_using_yaml_file.html#Load-Parameters-using-YAML-file">done here</a>), print it on the console and modify the phone number.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p><code>node_param_get_set.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy


def main():    
    
    # 1. Make the script a ROS Node.
    rospy.init_node('node_param_get_set', anonymous=True)

    # 2. Read from Parameter Server
    rospy.loginfo(&quot;Reading from Parameter Server.&quot;)

    
    param_config_my = rospy.get_param('details')    # Get all the parameters inside 'details'

    # Store the parameters in variables
    first_name = param_config_my['name']['first']
    last_name = param_config_my['name']['last']
    address = param_config_my['contact']['address']
    phone = param_config_my['contact']['phone']

    # Print the parameters
    rospy.loginfo(&quot;&gt;&gt; First Name: {}&quot;.format(first_name))
    rospy.loginfo(&quot;&gt;&gt; Last Name: {}&quot;.format(last_name))
    rospy.loginfo(&quot;&gt;&gt; Address: {}&quot;.format(address))
    rospy.loginfo(&quot;&gt;&gt; Phone: {}&quot;.format(phone))

    # 3. Modify the Phone Number 

    rospy.set_param('/details/contact/phone', 55555)        # Modify only Phone Number in Parameter Server
    new_phone = rospy.get_param('/details/contact/phone')   # Get only Phone Number from Parameter Server
    rospy.loginfo(&quot;&gt;&gt; New Phone: {}&quot;.format(new_phone))     # Print the new Phone Number
    

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/node_param_get_set.py" download><button>Download</button></a></center>
<br />
<blockquote>
<p><strong>NOTE</strong>: Make sure you make the <code>pkg_ros_basics node_param_get_set.py</code> script executable.</p>
</blockquote>
<p>Output:</p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_param_get_set.py
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/node-param-get-set-output.png" alt="node-param-get-set-output.png" /></p>
<ul>
<li>The code is self-explanatory.</li>
<li>If you are not able to understand the code feel free to seek help from us.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-launch-files"><a class="header" href="#ros-launch-files">ROS Launch Files</a></h1>
<ul>
<li>
<p>In the previous sections you must have noticed that we need to use <code>roscore</code> command to start ROS Master and Parameter Server, <code>rosrun</code> command to run a ROS Node, <code>rosparam load</code> command to load parameters etc.</p>
</li>
<li>
<p>This is a tedious process to manually run nodes and load parameters.</p>
</li>
<li>
<p>Launch files provides the capability to do all these stuff using a single command.</p>
</li>
<li>
<p>The idea is to mention all the nodes that you want to run, all the config file that you want to load etc. in a single file which you can run using <code>roslaunch</code> command.</p>
</li>
</ul>
<h2 id="reading-assignment-2"><a class="header" href="#reading-assignment-2">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/roslaunch">ROS Wiki - roslaunch</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-launch-file"><a class="header" href="#create-a-ros-launch-file">Create a ROS Launch File</a></h1>
<h2 id="roslaunch-command"><a class="header" href="#roslaunch-command">roslaunch Command</a></h2>
<ul>
<li>
<p><code>roslaunch</code> is a tool for easily launching multiple ROS nodes locally and remotely via SSH. </p>
</li>
<li>
<p>It includes options to automatically respawn processes that have already died. <code>roslaunch</code> takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch.</p>
</li>
<li>
<p>Usage:</p>
<pre><code class="language-bash">roslaunch &lt;package&gt; file.launch
</code></pre>
<p><code>&lt;package&gt;</code> is nothing but the package name which you have created using <code>catkin_create_pkg</code> command or used any other package.</p>
</li>
</ul>
<h2 id="steps-to-create-a-launch-file"><a class="header" href="#steps-to-create-a-launch-file">Steps to create a launch file</a></h2>
<ol>
<li>
<p>After creating a package, create a folder in the package names as a <code>launch</code> folder to store all the launch files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir launch
</code></pre>
</li>
<li>
<p>Here we can create launch files by running this command by going into the <code>launch</code> directory, we can keep any name for the launch file,</p>
<pre><code class="language-bash">cd launch
touch filename.launch
</code></pre>
<p>Now you can edit your launch file by adding different nodes that you have to run simultaneously.</p>
</li>
</ol>
<h2 id="steps-to-add-a-ros-node-in-the-launch-file"><a class="header" href="#steps-to-add-a-ros-node-in-the-launch-file">Steps to add a ROS node in the launch file</a></h2>
<ol>
<li>
<p>Launch files always starts with</p>
<pre><code class="language-xml">&lt;launch&gt;
</code></pre>
<p>and end with</p>
<pre><code class="language-xml">&lt;/launch&gt;
</code></pre>
</li>
<li>
<p>Now to add any executable file which we have seen in the rosrun_command section, we have to add this line,</p>
<pre><code class="language-xml">&lt;node pkg=&quot;name_of_package&quot; type=&quot;name_of_executable.py&quot; name=&quot;name_of_executable&quot; 
output=&quot;screen&quot;/&gt;
</code></pre>
<ul>
<li><code>pkg</code> is the package name which you have created</li>
<li><code>type</code> is the name of executable file</li>
<li><code>name</code> is the name of the node which is created in that executable</li>
<li><code>output</code> means it will print the data given to the roslog command</li>
</ul>
</li>
</ol>
<h2 id="steps-to-load-config-yaml-file-in-ros-parameter-server"><a class="header" href="#steps-to-load-config-yaml-file-in-ros-parameter-server">Steps to load Config YAML file in ROS Parameter Server</a></h2>
<ul>
<li>You can use <code>rosparam</code> tag to load the YAML file.
<pre><code class="language-xml">&lt;rosparam file =&quot;$(find name_of_package)/config/config.yaml&quot;/&gt;
</code></pre>
<ul>
<li><code>name_of_package</code> is the name of your ROS package.</li>
<li><code>config.yaml</code> is the name of your configuration file.</li>
</ul>
</li>
</ul>
<h2 id="steps-to-add-a-shell-script-in-the-launch-file"><a class="header" href="#steps-to-add-a-shell-script-in-the-launch-file">Steps to add a Shell Script in the launch file</a></h2>
<ul>
<li>
<p>You can use <code>node</code> tag to run any shell script using launch file</p>
<pre><code class="language-xml">&lt;node pkg=&quot;name_of_package&quot; type=&quot;shell_script.sh&quot; name=&quot;shell_script&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;cmd&quot; value=&quot;$(find name_of_package)/launch/shell_script.sh&quot;/&gt;
&lt;/node&gt;
</code></pre>
<ul>
<li><code>name_of_package</code> is the name of your ROS package.</li>
<li><code>shell_script.sh</code> is the name of your configuration file.</li>
<li><code>/launch/shell_script.sh</code> is the location of the shell script inside your ROS Package folder.</li>
</ul>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-launch-two-ros-nodes"><a class="header" href="#example-1-launch-two-ros-nodes">Example #1: Launch two ROS Nodes</a></h1>
<h2 id="aim-1"><a class="header" href="#aim-1">Aim</a></h2>
<ul>
<li>To launch <code>talker</code> and <code>listener</code> node present in <code>rospy_tutorials</code> package.</li>
<li>For this create a <code>chatter.launch</code> file and save it in the <code>launch</code> folder inside <code>pkg_ros_basics</code> package.</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>: To install <code>rospy_tutorials</code> package in your system you can run <code>sudo apt-get install ros-noetic-ros-tutorials</code> this command.</p>
</blockquote>
<p>Once installed, you can use <code>listener</code> python script and talker executable written in C++ present in <code>rospy_tutorials</code> package.</p>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<p><code>chatter.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
  &lt;node name=&quot;talker&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;talker&quot; output=&quot;screen&quot;/&gt;
  &lt;node name=&quot;listener&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener.py&quot; output=&quot;screen&quot;/&gt;
&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/chatter.launch" download><button>Download</button></a></center>
<ul>
<li>Here first <code>talker.cpp</code> file (for cpp file we dont need to add .cpp extension) has been included with the node name as talker and also set output as screen so you can see the output from talker node.</li>
<li>Next we have added <code>listener.py</code> which has node name as listener and here also we have set output as screen.</li>
</ul>
<h2 id="run-command"><a class="header" href="#run-command">Run Command</a></h2>
<p>Now run these command to run the launch file,</p>
<pre><code class="language-bash">roslaunch pkg_ros_basics chatter.launch
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/chatter.png" alt="chatter.png" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-launch-turtle-in-forest"><a class="header" href="#example-2-launch-turtle-in-forest">Example #2: Launch Turtle in Forest</a></h1>
<h2 id="aim-2"><a class="header" href="#aim-2">Aim</a></h2>
<ul>
<li>
<p>To write a launch file to run <code>turtlesim_node</code> node and <code>turtle_teleop_key</code> node present in <code>turtlesim</code> package.</p>
</li>
<li>
<p>While launching the <code>turtlesim_node</code> make sure to change the background colour of the simulator from blue to forest green.</p>
</li>
<li>
<p>Name the launch file <code>turtlesim.launch</code> and save it in <code>launch</code> folder inside <code>pkg_ros_basics</code> package.</p>
</li>
</ul>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<p><code>turtlesim.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;node_turtlesim_node&quot;&gt;
        &lt;param name=&quot;/background_r&quot; value=&quot;34&quot; /&gt;
        &lt;param name=&quot;/background_g&quot; value=&quot;139&quot; /&gt;
        &lt;param name=&quot;/background_b&quot; value=&quot;34&quot; /&gt;
    &lt;/node&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;node_turtle_teleop_key&quot; /&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/turtlesim.launch" download><button>Download</button></a></center>
<h2 id="run-command-1"><a class="header" href="#run-command-1">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics turtlesim.launch
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/turtlesim.png" alt="turtlesim.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-load-yaml"><a class="header" href="#example-3-load-yaml">Example #3: Load YAML</a></h1>
<h2 id="aim-3"><a class="header" href="#aim-3">Aim</a></h2>
<ul>
<li>To write a launch file to load <code>config_my.yaml</code> present in <code>pkg_ros_basics</code> package.</li>
<li>Also launch the <code>node_param_get_set.py</code> ROS node after loading the YAML file.</li>
</ul>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<p><code>load_yaml.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;rosparam file =&quot;$(find pkg_ros_basics)/config/config_my.yaml&quot;/&gt;
        
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;node_param_get_set.py&quot; name=&quot;node_param_get_set&quot; output=&quot;screen&quot;/&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.launch" download><button type="button">Download</button></a></center>
<h2 id="run-command-2"><a class="header" href="#run-command-2">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics load_yaml.launch
</code></pre>
<h2 id="output-2"><a class="header" href="#output-2">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.png" alt="load_yaml.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-4-launch-shell-script-and-ros-node"><a class="header" href="#example-4-launch-shell-script-and-ros-node">Example #4: Launch Shell Script and ROS Node</a></h1>
<h2 id="aim-4"><a class="header" href="#aim-4">Aim</a></h2>
<ul>
<li>
<p>To write a launch file called <code>web_node.launch</code> to open <code>e-yantra.org</code> in firefox and run <code>node_hello_ros.py</code> of <code>pkg_ros_basics</code>.</p>
</li>
<li>
<p>You need to write a shell script called <code>webpage_launch.sh</code> to open <code>e-yantra.org</code> in firefox and save it in <code>launch</code> folder of <code>pkg_ros_basics</code>.</p>
</li>
</ul>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<p><code>webpage_launch.sh</code></p>
<pre><code class="language-shell">#!/bin/bash

# Store URL in a variable
URL1=&quot;https://www.e-yantra.org/&quot;

# Print some message
echo &quot;** Opening $URL1 in Firefox **&quot;

# Use firefox to open the URL in a new window
firefox -new-window $URL1 
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/webpage_launch.sh" download><button>Download</button></a></center>
<p><code>node_hello_ros.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy

def main():
    # 1. Make the script a ROS Node.
    rospy.init_node('node_hello_ros', anonymous=True)

    # 2. Print Hello World!
    rospy.loginfo(&quot;Hello World!&quot;)

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/node_hello_ros.py" download><button>Download</button></a></center>
<blockquote>
<p><strong>NOTE</strong>: You need to make these shell script and python script executable using <code>chmod</code> before using it in a launch file.</p>
</blockquote>
<p><code>web_node.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;webpage_launch.sh&quot; name=&quot;webpage_launch&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;cmd&quot; value=&quot;$(find pkg_ros_basics)/launch/webpage_launch.sh&quot;/&gt;
    &lt;/node&gt;
        
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;node_hello_ros.py&quot; name=&quot;node_hello_ros&quot; output=&quot;screen&quot;/&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/web_node.launch" download="web_node.launch"><button type="button">Download</button></a></center>
<h2 id="run-command-3"><a class="header" href="#run-command-3">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics web_node.launch
</code></pre>
<h2 id="output-3"><a class="header" href="#output-3">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/web_node.png" alt="web_node.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-communication"><a class="header" href="#ros-communication">ROS Communication</a></h1>
<ul>
<li>
<p>In ROS there are essentially three ways in which two nodes can communicate with each other. These are,</p>
<ol>
<li>ROS Topics</li>
<li>ROS Services</li>
<li>ROS Actions</li>
</ol>
</li>
<li>
<p>We will learn about all these three in this section.</p>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-topics"><a class="header" href="#ros-topics">ROS Topics</a></h1>
<ul>
<li>
<p>ROS Topics allow <strong>unidirectional</strong> communication between ROS Nodes.</p>
</li>
<li>
<p>When using ROS Topics a ROS Node can be a <strong>publisher</strong>, <strong>subscriber</strong> or both.</p>
</li>
<li>
<p>A ROS Node acting as a publisher can publish data on a ROS Topic and a subscriber ROS Node can subscribe to a ROS Topic.</p>
</li>
<li>
<p>Publisher and Subscriber Nodes will exchange ROS Messages over a ROS Topic.</p>
</li>
<li>
<p>A ROS Message is a simple data structure, comprising typed fields (integer, floating point, boolean, etc.). So a ROS Message can hold data of various data-types.</p>
</li>
<li>
<p>Consider this analogy,</p>
<ul>
<li>
<p>Let’s say you are subscribed to a newspaper called <em>The Noetic</em> published by a publishing house called <em>OSRF</em>.</p>
</li>
<li>
<p>Every morning your paperboy <em>Jon Doe</em> will deliver this newspaper to you.</p>
</li>
<li>
<p>You like <em>The Noetic</em> because it has dedicated section on <em>sports</em> and <em>robotics</em> news.</p>
</li>
<li>
<p>In this analogy you can think,</p>
<ul>
<li>
<p><code>OSRF &lt;--&gt; ROS Publisher Node</code></p>
<p>OSRF which is publishing the newspaper as a Publisher Node.</p>
</li>
<li>
<p><code>You &lt;--&gt; ROS Subscriber Node</code></p>
<p>You along with your neighbours who are subscribed to this newspaper as Subscriber Nodes. </p>
</li>
<li>
<p><code>Jon Doe &lt;--&gt; ROS Topic</code></p>
<p>Your paperboy who is taking the newspaper from the publisher and delivering it to its subscribers as a ROS Topic.</p>
</li>
<li>
<p><code>The Noetic Newspaper &lt;--&gt; ROS Message</code></p>
<p>The physical newspaper is your ROS Message.</p>
</li>
<li>
<p><code>Sports and Robotics Sections of The Noetic &lt;--&gt; Data Fields defined in ROS Message</code></p>
<p>The sections of the newspaper is the Data Fields defined in the ROS Message.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="reading-assignment-3"><a class="header" href="#reading-assignment-3">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Topics">ROS Wiki - Topic</a></li>
<li><a href="http://wiki.ros.org/Messages">ROS Wiki - Messages</a></li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-rostopic"><a class="header" href="#command-rostopic">Command: rostopic</a></h1>
<p><code>rostopic</code> contains the rostopic command-line tool for displaying debug information about ROS Topics, including publishers, subscribers, publishing rate, and ROS Messages.</p>
<blockquote>
<p>Reference: <a href="http://wiki.ros.org/rostopic">http://wiki.ros.org/rostopic</a></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: For quick information about any command, be that outside of ROS, simply type the command along with suffix <code>--h</code> or <code>-help</code>. This is a widely used concept among other Linux commands for quick referencing. Here’s an example for <code>rostopic --h</code> command </p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic--h.png" alt="rostopic–h" /></p>
<p>As you can see in the above image, there are multiple suffixes associated with <code>rostopic</code>, these suffixes are the commands to analyze any existing or developing system. We’ll look into this sub-command or suffixes one by one. </p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-1"><a class="header" href="#list-1">list</a></h1>
<ul>
<li>
<p><code>rostopic list</code> returns a list of all topics currently subscribed to and published.</p>
</li>
<li>
<p>Let’s see this command’s actual output. In a new terminal start the roscore:</p>
<pre><code class="language-bash">roscore
</code></pre>
<blockquote>
<p><strong>Note</strong>: Do not close this terminal, otherwise you won’t be able to communicate with the rosmaster while executing some of its features.</p>
</blockquote>
</li>
<li>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rostopic list
</code></pre>
<p>This should give something like the following image, which is the ROS’s default topics. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic_list_before.png" alt="rostopic-list-before.png" /></p>
</li>
<li>
<p>For this tutorial, we will also use turtlesim. Please run in a new terminal: </p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>You will see a small blue box with probably a different turtle within it. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/turtlesim_node.png" alt="turtlesim-node.png" /></p>
</li>
<li>
<p>Now, check again the <code>rostopic list</code> command in another terminal and observe the topics being subscribed or published.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic_list_after.png" alt="rostopic-list-after.png" /></p>
<blockquote>
<p><strong>Note</strong>: You can know more about these listed topics, by simply adding arguments as a suffix to <code>rostopic list</code>. And to know which arguments does what type <code>rostopic list --help</code>. Go ahead and experiment.</p>
</blockquote>
<hr />
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-info-and-rosmsg"><a class="header" href="#type-info-and-rosmsg">type, info and rosmsg</a></h1>
<h2 id="type"><a class="header" href="#type">type</a></h2>
<p>Communication on topics happens by sending ROS messages between <a href="http://wiki.ros.org/Nodes">nodes</a>. To communicate, the publisher and subscriber must send and receive the same <strong>type</strong> of message. This means that a topic <strong>type</strong> is defined by the message <strong>type</strong> published on it. The <strong>type</strong> of the message sent on a topic can be determined using <code>rostopic type</code>. </p>
<pre><code class="language-bash">rostopic type [topic]
</code></pre>
<ul>
<li>
<p>From the previous section, we know that the turtlesim node has 3 topics being published/subscribed. </p>
<ul>
<li><code>/turtle1/cmd_vel</code></li>
<li><code>/turtle1/pose</code></li>
<li><code>/turtle1/color_sensor</code></li>
</ul>
</li>
<li>
<p>Lets consider the topics <code>/turtle1/cmd_vel</code>. Enter the following command to get the message type.</p>
<pre><code class="language-bash">rostopic type /turtle1/cmd_vel
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-type.png" alt="rostopic-type.png" /></p>
</li>
</ul>
<h2 id="rosmsg"><a class="header" href="#rosmsg">rosmsg</a></h2>
<ul>
<li>
<p>As you can observe the type of message associated with <code>/turtle1/cmd_vel</code> is <code>geometry_msgs/Twist</code>. let’s look into more detail of the message, using <code>rosmsg show [messageType]</code> command: </p>
<pre><code class="language-bash">rosmsg show geometry_msgs/Twist
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rosmsg-show.png" alt="rosmsg-show.png" /></p>
</li>
<li>
<p>A message consists of two parts, <em>field and constant</em>. Simply, <strong>fields</strong> is the datatype and <strong>constants</strong> are the representative value. From the above figure, you can observe that these <em>field and constants</em> are displayed twice. However, both of these sections, are separate since they have a different <strong>header</strong> or different sub-information from the same robot. The 2 <strong>headers</strong> seen are…</p>
<ul>
<li>
<p><code>geometry_msgs/Vector3 linear:</code> Describes the linear velocities of all the 3 axes.</p>
</li>
<li>
<p><code>geometry_msgs/Vector3 angular:</code> While this header describes, angular velocities of all 3 axes.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>For more details regarding <em>messages</em> in ROS refer to <a href="http://wiki.ros.org/msg">wiki.ros.org/msg</a>.</p>
</blockquote>
<blockquote>
<p>For more information on <code>geometry_msgs/Twist</code> refer, this <a href="https://stackoverflow.com/questions/50976281/what-do-x-y-and-z-mean-in-geometry-msgs-twist-message-in-ros">thread</a> of Stackoverflow forum.</p>
</blockquote>
<h2 id="info-1"><a class="header" href="#info-1">info</a></h2>
<ul>
<li>This command provides a little more detail about topics then <code>type</code> argument. </li>
</ul>
<pre><code class="language-bash">rostopic info /turtle1/cmd_vel
</code></pre>
<ul>
<li>
<p>The output of this command will yield both</p>
<ul>
<li>the message <strong>type</strong> and</li>
<li>the nodes which are publishing it or subscribing it.</li>
</ul>
</li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-info.png" alt="rostopic-info.png" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pub"><a class="header" href="#pub">pub</a></h1>
<ul>
<li>
<p><code>rostopic pub</code> publishes data on to a topic currently advertised. </p>
</li>
<li>
<p>Usage:</p>
</li>
</ul>
<pre><code class="language-bash">rostopic pub [topic] [msg_type] [args]
</code></pre>
<ul>
<li>Let’s move the turtle inside the turtlsim window.</li>
</ul>
<pre><code class="language-bash">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 0.0 
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0&quot;
</code></pre>
<blockquote>
<p>Here we recommend to double tap the TAB button after <code>/turtle1/cmd_vel</code> (don’t forget the space after the topic name). You’ll see the message <strong>type</strong> appearing after a few instance. Similarly, double tapping after ‘geometry_msgs/Twist’ will make the corresponding message content appear automatically. Try it with other commands too.</p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-0.png" alt="rostopic-pub-0.png" /></p>
<ul>
<li>Now that we have the complete blank (with all <em>constants</em> as zeros) pub command for <code>/turtle1/cmd_vel</code>, let’s rotate it about its z-axis (Yep! the Omega variable).</li>
</ul>
<pre><code class="language-bash">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 0.0 
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.5
</code></pre>
<ul>
<li>After executing the above command you will see the turtle rotating clockwise. </li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-0.5.png" alt="rostopic-pub-0.5.png" /></p>
<ul>
<li>
<p>However, the turtle only rotated for a while and not continuously. This is because our <code>pub</code> command was only sent once. So, to keep the turtle rotating we need to keep sending our <code>pub</code> command repeatedly. And to do so, we’ll use the <code>-r</code> argument with <code>pub</code> command.</p>
</li>
<li>
<p>The following command is used to publish a steady stream of commands at a rate of 10Hz.</p>
</li>
</ul>
<pre><code class="language-bash">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 2.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 1.8&quot;
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-rate-10.gif" alt="rostopic-pub-rate-10.gif" /></p>
<ul>
<li>You can always know more about <code>pub</code> command by simply typing <code>rostopic pub --help</code>.</li>
</ul>
<blockquote>
<p>For more details refer, <a href="http://wiki.ros.org/rostopic#rostopic_pub">http://wiki.ros.org/rostopic#rostopic_pub</a></p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="echo"><a class="header" href="#echo">echo</a></h1>
<ul>
<li>
<p><code>rostopic echo</code> shows the data published on a topic. </p>
</li>
<li>
<p>Usage:</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo [topic]
</code></pre>
<ul>
<li>
<p>In the earlier section, at the end, we used <code>-r</code> argument to keep it rotation at an angular velocity of 0.5 units. But what if the velocity is unknown and we need this information as feedback to control the motion of turtle???</p>
</li>
<li>
<p>Our desire here is to get the pose information or simply one or all of the turtle’s x,y, and z values w.r.t to the world.</p>
</li>
<li>
<p>But let’s see if there is any data being published by the turtlesim node in the first place. To do so, we’ll use the following command…</p>
</li>
</ul>
<pre><code class="language-bash">rostopic list -p
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-list-p.png" alt="rostopic-list-p.png" /></p>
<ul>
<li>
<p>From the <code>-p</code> we know 2 topic is being published</p>
<ul>
<li><code>/turtle1/color_sensor</code></li>
<li><code>/turtle1/pose</code></li>
</ul>
</li>
<li>
<p>Let’s see more into the <code>/turtle1/pose</code> topic. </p>
</li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-info-turtle1-pose.png" alt="rostopic-info-turtle1-pose.png" /></p>
<ul>
<li>
<p>Luckily the pose information of turtle from the turtlesim is being published on the topic <code>/turtle1/pose</code>. </p>
</li>
<li>
<p>To display the pose data, enter the following command…</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /turtle1/pose
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-echo.png" alt="rostopic-echo.png" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-pub-sub-with-custom-message"><a class="header" href="#example-1-pub-sub-with-custom-message">Example #1: Pub-Sub with Custom Message</a></h1>
<h2 id="aim-5"><a class="header" href="#aim-5">Aim</a></h2>
<p>To write a <code>listener</code> and <code>talker</code> node which should communicate with each other over a ROS Topic called <code>my_topic</code> using a custom ROS Message called <code>myMessage</code> with the following data fields of the following data types.</p>
<ol>
<li>int32 id</li>
<li>string name</li>
<li>float32 temperature</li>
<li>float32 humidity</li>
</ol>
<h2 id="steps-1"><a class="header" href="#steps-1">Steps</a></h2>
<h3 id="create-custom-ros-message"><a class="header" href="#create-custom-ros-message">Create Custom ROS Message</a></h3>
<ul>
<li>
<p>Messages are just simple text files with a field type and field name per line. </p>
</li>
<li>
<p>They are stored in the <code>msg</code> directory of your package. </p>
</li>
</ul>
<ol>
<li>
<p>Create a file and name it <code>myMessage.msg</code> and store it in a <code>msg</code> folder of <code>pkg_ros_basics</code>. If the folder does not exist create it.</p>
</li>
<li>
<p>Now fill the <code>myMessage.msg</code> file with the following content.</p>
<pre><code class="language-txt">int32 id
string name
float32 temperature
float32 humidity
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/myMessage.msg" download><button>Download</button></a></center>
<p>This is the format of a typical <code>msg</code> file.</p>
</li>
<li>
<p>Now open your <code>package.xml</code> file of <code>pkg_ros_basics</code> package and add in the dependencies for your <code>geometry_msgs</code>, <code>message_generation</code> and <code>message_runtime</code> as seen below.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
    &lt;name&gt;pkg_ros_basics&lt;/name&gt;
    &lt;version&gt;0.0.0&lt;/version&gt;
    &lt;description&gt;The pkg_ros_basics package&lt;/description&gt;

    &lt;maintainer email=&quot;ubuntu@todo.todo&quot;&gt;ubuntu&lt;/maintainer&gt;

    &lt;license&gt;TODO&lt;/license&gt;

    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
    &lt;build_depend&gt;rospy&lt;/build_depend&gt;
    &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
    &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
    &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
    &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;
    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
    &lt;build_depend&gt;message_generation&lt;/build_depend&gt;
    &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
    &lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt;
    &lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt;

    &lt;export&gt;
    &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/package.xml" download><button>Download</button></a></center>
</li>
<li>
<p>Now open your <code>CMakeList.txt</code> file of <code>pkg_ros_basics</code> package and navigate to the following block of code in your file.</p>
<pre><code class="language-xml"># add_message_files(
#   FILES
#   Message1.msg
#   Message2.msg
# )
</code></pre>
<p>Uncomment the Messages and add include the name of your Message files. You can include multiple Message files if required as well.</p>
<p>Now your <code>CMakeLists.txt</code> should look like this,</p>
<pre><code class="language-txt">cmake_minimum_required(VERSION 3.0.2)
project(pkg_ros_basics)


find_package(catkin REQUIRED COMPONENTS
    roscpp
    rospy
    std_msgs
    geometry_msgs
    message_generation
)

add_message_files(
    FILES
    myMessage.msg
)

generate_messages(
    DEPENDENCIES
    std_msgs
    geometry_msgs
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES pkg_ros_basics
    CATKIN_DEPENDS roscpp rospy std_msgs geometry_msgs message_runtime
#  DEPENDS system_lib
)

###########
## Build ##
###########

## Specify additional locations of header files
## Your package locations should be listed before other locations
include_directories(
# include
    ${catkin_INCLUDE_DIRS}
)
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/CMakeLists.txt" download><button>Download</button></a></center>
</li>
<li>
<p>After this build your package.</p>
<pre><code class="language-bash">cd ~/workspace
catkin_make
</code></pre>
<p>Once the package is build successfully you can see <code>myMessage.h</code> file located at <code>~/workspace/devel/include/pkg_ros_basics/myMessage.h</code>. This will be used by ROS Nodes to communicate over a ROS Topic using <code>myMessage</code> ROS Message. </p>
</li>
</ol>
<h2 id="code---ros-nodes"><a class="header" href="#code---ros-nodes">Code - ROS Nodes</a></h2>
<h3 id="listener-node"><a class="header" href="#listener-node">Listener Node</a></h3>
<p><code>node_myMsg_listener.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from pkg_ros_basics.msg import myMessage


def func_callback_topic_my_topic(myMsg):

    rospy.loginfo(&quot;Data Received: (%d, %s, %.2f, %.2f)&quot;, myMsg.id,
                  myMsg.name, myMsg.temperature, myMsg.humidity)


def main():

    # 1. Initialize the Subscriber Node.
    rospy.init_node('node_myMsg_listener', anonymous=True)

    # 2. Subscribe to the desired topic and attach a Callback Funtion to it.
    rospy.Subscriber(&quot;my_topic&quot;, myMessage, func_callback_topic_my_topic)

    # 3. spin() simply keeps python from exiting until this node is stopped
    rospy.spin()


# Python Main
if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node_myMsg_listener.py" download><button>Download</button></a></center>
<h3 id="talker-node"><a class="header" href="#talker-node">Talker Node</a></h3>
<p><code>node_myMsg_talker.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from pkg_ros_basics.msg import myMessage

import random


def main():
    
    # 1. Create a handle to publish messages to a topic.
    var_handle_pub = rospy.Publisher('my_topic', myMessage, queue_size=10)
    
    # 2. Initializes the ROS node for the process.
    rospy.init_node('node_myMsg_talker', anonymous=True)

    # 3. Set the Loop Rate 
    var_loop_rate = rospy.Rate(1) # 1 Hz : Loop will its best to run 1 time in 1 second
    
    # 4. Write the infinite Loop
    while not rospy.is_shutdown():
        obj_msg = myMessage()

        obj_msg.id = 1
        obj_msg.name = &quot;my_message&quot;
        obj_msg.temperature = 10 + random.random()
        obj_msg.humidity = 20 + random.random()

        rospy.loginfo(&quot;Publishing: &quot;)
        rospy.loginfo(obj_msg)

        var_handle_pub.publish(obj_msg)

        var_loop_rate.sleep()



# Python Main
if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node_myMsg_talker.py" download><button>Download</button></a></center>
<h2 id="output-4"><a class="header" href="#output-4">Output</a></h2>
<p>For analyzing the output for these custom messages, you can follow the following steps</p>
<ol>
<li>
<p><code>roscore</code> - As seen in previous tutorials, you must have a roscore running for the nodes to communicate. To view the messages between the talker and listener nodes, run an instance of roscore in a separate terminal window</p>
</li>
<li>
<p>listener node - For making the script of your node executable run <code>chmod +x</code> within the appropriate directory in a separate terminal window other than where your roscore is running. To run the listener node, run the following commands within your appropriate directory <code>rosrun &lt;package_name&gt; &lt;listener_node.py&gt;</code></p>
</li>
<li>
<p>talker node - You can follow the same steps mentioned above for running your talker node using the commands <code>rosrun &lt;package_name&gt; &lt;talker_node.py&gt;</code></p>
</li>
</ol>
<p>If you follow the steps given above, you should see the following output </p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_myMsg_talker.py 
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node-myMsg-talker.png" alt="node-myMsg-talker.png" /></p>
<br />  
```bash
rosrun pkg_ros_basics node_myMsg_listener.py
```
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node-myMsg-listener.png" alt="node-myMsg-listener.png" /></p>
<ul>
<li>If you face any problems while following this tutorial you can feel free to reach out to us. </li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-services"><a class="header" href="#ros-services">ROS Services</a></h1>
<ul>
<li>
<p>The publish/subscribe model is a very flexible communication paradigm, but its many-to-many one-way transport is not appropriate for request/reply interactions, which are often required in a distributed system. </p>
</li>
<li>
<p>Request/reply is done via a Service, which is defined by a pair of messages: one for the request and one for the reply. </p>
</li>
<li>
<p>A providing ROS node offers a service under a string name, and a client calls the service by sending the request message and awaiting the reply. </p>
</li>
<li>
<p>Client libraries usually present this interaction to the programmer as if it were a remote procedure call.</p>
</li>
<li>
<p>Services are defined using <code>srv</code> files, which are compiled into source code by a ROS client library. </p>
</li>
<li>
<p>Like topics, services have an associated service type that is the package resource name of the <code>.srv</code> file.</p>
</li>
</ul>
<h2 id="reading-assignment-4"><a class="header" href="#reading-assignment-4">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Services">ROS Wiki - Services</a></li>
<li><a href="https://www.cse.sc.edu/~jokane/agitr/agitr-letter-service.pdf">AGITR - Services</a></li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-srv-file"><a class="header" href="#create-a-srv-file">Create a srv file</a></h1>
<h2 id="steps-2"><a class="header" href="#steps-2">Steps</a></h2>
<ol>
<li>
<p>Create a custom ROS Package or use any existing package like <code>pkg_ros_basics</code>.</p>
</li>
<li>
<p>Go into the package directory and create a folder called <code>srv</code>.</p>
<pre><code class="language-bash">roscd &lt;package_name&gt;
mkdir srv
</code></pre>
</li>
<li>
<p>Instead of creating a new srv definition by hand, we will copy an existing one from another package. For that, <code>roscp</code> is a useful commandline tool for copying files from one package to another.
Usage:</p>
<pre><code class="language-bash">roscp [package_name] [file_to_copy_path] [copy_path]
</code></pre>
<p>Now we can copy a service from the <code>rospy_tutorials</code> package:</p>
<pre><code class="language-bash">roscp rospy_tutorials AddTwoInts.srv srv/AddTwoInts.srv
</code></pre>
<p>The srv file is,</p>
<pre><code class="language-txt">int64 a
int64 b
---
int64 sum
</code></pre>
<p>Here <code>a</code> and <code>b</code> holds the request data which is sent by the Client to the Server and <code>sum</code> is the response which is sent by the Server to the Client.</p>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/AddTwoInts.srv" download><button>Download</button></a></center>
</li>
<li>
<p>Open <code>package.xml</code>, and make sure these two lines are in it and uncommented:</p>
<pre><code class="language-xml">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;
&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
</code></pre>
</li>
<li>
<p>Add the <code>message_generation</code> dependency to generate messages in <code>CMakeLists.txt</code>:
<strong>Do not just add this line to your CMakeLists.txt, modify the existing line</strong></p>
<pre><code class="language-txt">find_package(catkin REQUIRED COMPONENTS
roscpp
rospy
std_msgs
message_generation
)
</code></pre>
</li>
<li>
<p>Remove <code>#</code> to uncomment the following lines:</p>
<pre><code class="language-txt"># add_service_files(
#   FILES
#   Service1.srv
#   Service2.srv
# )
</code></pre>
<p>And replace the placeholder <code>&lt;service_name&gt;.srv</code> files for your service files:</p>
<pre><code class="language-txt">add_service_files(
FILES
AddTwoInts.srv
)
</code></pre>
</li>
<li>
<p>Unless you have already done this in the previous steps, change in <code>CMakeLists.txt</code>. :</p>
<pre><code class="language-txt"># generate_messages(
#   DEPENDENCIES
# #  std_msgs  # Or other packages containing msgs
# )
</code></pre>
<p>Uncomment it and add any packages you depend on which contain <code>.msg</code> files that your messages use (in this case std_msgs), such that it looks like this:</p>
<pre><code class="language-txt">generate_messages(
DEPENDENCIES
std_msgs
)
</code></pre>
</li>
</ol>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/CMakeLists.txt" download><button>Download CMakeLists.txt</button></a></center>
<ol>
<li>Go to <code>workspace</code> directory and run:
<pre><code class="language-bash">catkin_make
</code></pre>
</li>
</ol>
<h2 id="rossrv-command"><a class="header" href="#rossrv-command">rossrv Command</a></h2>
<p>The <code>rossrv</code> command-line tool displays information about ROS services. It has the exact same usage as <code>rosmsg</code> (see what it offers when it runs without sub-command below):</p>
<pre><code class="language-bash">rossrv -h
rossrv show pkg_ros_basics/AddTwoInts
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/rossrv-command.png" alt="rossrv-command.png" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-ros-services---server-and-client"><a class="header" href="#test-ros-services---server-and-client">Test ROS Services - Server and Client</a></h1>
<blockquote>
<p>For in depth code details in python language <a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28python%29">Click here</a></p>
</blockquote>
<blockquote>
<p>For in depth code details in Cpp language <a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29">Click here</a></p>
</blockquote>
<ul>
<li>We will use an example from <code>rospy_tutorials</code>.</li>
</ul>
<h2 id="steps-3"><a class="header" href="#steps-3">Steps</a></h2>
<ol>
<li>
<p>First, run <code>roscore</code> command in a new terminal.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Then run this command in a new terminal:</p>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_server 
</code></pre>
</li>
<li>
<p>Run this command in the new terminal for adding integer 12 and integer 20:</p>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_client 12 20
</code></pre>
</li>
</ol>
<h2 id="output-5"><a class="header" href="#output-5">Output</a></h2>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_server
</code></pre>
<pre><code class="language-bash">Returning [12 + 20 = 32]
Returning [12 + 20 = 32]
</code></pre>
<br />
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_client 12 20
</code></pre>
<pre><code class="language-bash">Requesting 12+20
12 + 20 = 32
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-actions"><a class="header" href="#ros-actions">ROS Actions</a></h1>
<ul>
<li>In any large ROS based system, here are cases when someone would like to send a request to a node to perform some task, and also receive a reply to the request. This can currently be achieved via <code>ROS services</code>. </li>
<li>However, in some cases the sevices takes a long time to execute.</li>
<li>The user might want the ability to cancel the request during execution or get periodic feedback about how the request is progressing.</li>
<li>The <code>actionlib</code> package provides tools to create servers that execute long-running goals that can be preempted</li>
<li>It also provides a client interface in order to send requests to the server.</li>
<li>The action specification is defined using a <code>.action</code> file. The <code>.action</code> file has the goal definition, followed by the result definition, followed by the feedback definition, with each section separated by 3 hyphens (—). </li>
</ul>
<h2 id="reference-2"><a class="header" href="#reference-2">Reference</a></h2>
<ul>
<li>More details about how actionlib operates “under the hood” are <a href="http://wiki.ros.org/actionlib/DetailedDescription">here</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-an-action-message-file"><a class="header" href="#create-an-action-message-file">Create an action message file</a></h1>
<p>Before writing an action it is important to define the goal, result, and feedback messages. The action messages are generated automatically from the <code>.action</code> file, for more information on action files see the <a href="https://wiki.ros.org/actionlib">actionlib</a> documentation. This file defines the type and format of the goal, result, and feedback topics for the action. Create actionlib_tutorials/action/Fibonacci.action in your favorite editor, and place the following inside it:</p>
<pre><code>#goal definition
int32 order
---
#result definition
int32[] sequence
---
#feedback
int32[] sequence
</code></pre>
<p>To automatically generate the message files during the make process, a few things need to be added to CMakeLists.txt.</p>
<ul>
<li>
<p>add the actionlib_msgs package to the find_package macro’s argument like this (if you used catkin_create_package to generate CMakeLists.txt, this may already have been added):</p>
<pre><code>find_package(catkin REQUIRED COMPONENTS actionlib_msgs)
</code></pre>
<ul>
<li>
<p>Note that CMake needs to find_package actionlib_msgs (message_generation does not need to be listed explicitly, it is referenced implicitly by actionlib_msgs). </p>
</li>
<li>
<p>use the add_action_files macro to declare the actions you want to be generated:</p>
</li>
</ul>
<pre><code>add_action_files(
DIRECTORY action
FILES Fibonacci.action
)
</code></pre>
</li>
<li>
<p>call the generate_messages macro, not forgetting the dependencies on actionlib_msgs and other message packages like std_msgs: </p>
<pre><code>generate_messages(
DEPENDENCIES actionlib_msgs std_msgs  # Or other packages containing msgs
)    
</code></pre>
</li>
<li>
<p>add actionlib_msgs to catkin_package macro like this:</p>
<pre><code>catkin_package(
CATKIN_DEPENDS actionlib_msgs
)
</code></pre>
<ul>
<li>catkin_package also specifies only CATKIN_DEPEND to actionlib_msgs. The transitive dependency on message_runtime is happening automatically. </li>
</ul>
</li>
</ul>
<p>Note: Sometimes you have to setup your package.xml, since we are generating messages you have to declare on the manifest file that at run time you have to generate messages. You could just insert the follow line.</p>
<pre><code>&lt;exec_depend&gt;message_generation&lt;/exec_depend&gt;

</code></pre>
<p>Now by following, automatically generate msg files of your action files, and also see the result. </p>
<pre><code class="language-bash">$ cd ../.. # Go back to the top level of your catkin workspace
$ catkin_make
$ ls devel/share/actionlib_tutorials/msg/
FibonacciActionFeedback.msg  FibonacciAction.msg        FibonacciFeedback.msg
FibonacciResult.msg          FibonacciActionGoal.msg    FibonacciActionResult.msg  FibonacciGoal.msg
$ ls devel/include/actionlib_tutorials/
FibonacciActionFeedback.h  FibonacciAction.h        FibonacciFeedback.h  FibonacciResult.h
FibonacciActionGoal.h      FibonacciActionResult.h  FibonacciGoal.h
</code></pre>
<p>To manually generate the message files from this file, use the script genaction.py from the actionlib_msgs package. </p>
<h3 id="reference-3"><a class="header" href="#reference-3">Reference</a></h3>
<ul>
<li><a href="https://wiki.ros.org/actionlib_tutorials/Tutorials/SimpleActionServer(ExecuteCallbackMethod)#actionlib_tutorials.2BAC8-Tutorials.2BAC8-SimpleActionServer.28ExecuteCallbackMethod.29.2BAC8-groovy.Creating_the_Action_Messages">actionlib_tutorial</a></li>
</ul>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="simple-action-server--client"><a class="header" href="#simple-action-server--client">Simple Action Server &amp; Client</a></h1>
<ul>
<li>This tutorial covers using the simple_action_server library to create a Fibonacci action server in Python. This example action server generates a Fibonacci sequence, the goal is the order of the sequence, the feedback is the sequence as it is computed, and the result is the final sequence.</li>
</ul>
<h2 id="writing-a-simple-server"><a class="header" href="#writing-a-simple-server">Writing a Simple Server</a></h2>
<ul>
<li>The following code can be found in actionlib_tutorials/simple_action_servers/fibonacci_server.py, and implements a python action server for the <a href="http://docs.ros.org/api/actionlib_tutorials/html/classfibonacci__server_1_1FibonacciAction.html">fibonacci action</a>.</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python3
 
 import rospy
 
 import actionlib
 
 import actionlib_tutorials.msg
 
 class FibonacciAction(object):
     # create messages that are used to publish feedback/result
     _feedback = actionlib_tutorials.msg.FibonacciFeedback()
     _result = actionlib_tutorials.msg.FibonacciResult()
 
     def __init__(self, name):
         self._action_name = name
         self._as = actionlib.SimpleActionServer(self._action_name, actionlib_tutorials.msg.FibonacciAction, execute_cb=self.execute_cb, auto_start = False)
         self._as.start()
       
     def execute_cb(self, goal):
         # helper variables
         r = rospy.Rate(1)
         success = True
         
         # append the seeds for the fibonacci sequence
         self._feedback.sequence = []
         self._feedback.sequence.append(0)
         self._feedback.sequence.append(1)
         
         # publish info to the console for the user
         rospy.loginfo('%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i' % (self._action_name, goal.order, self._feedback.sequence[0], self._feedback.sequence[1]))
        
         # start executing the action
         for i in range(1, goal.order):
             # check that preempt has not been requested by the client
             if self._as.is_preempt_requested():
                 rospy.loginfo('%s: Preempted' % self._action_name)
                 self._as.set_preempted()
                 success = False
                 break
             self._feedback.sequence.append(self._feedback.sequence[i] + self._feedback.sequence[i-1])
             # publish the feedback
             self._as.publish_feedback(self._feedback)
             # this step is not necessary, the sequence is computed at 1 Hz for demonstration purposes
             r.sleep()
          
         if success:
             self._result.sequence = self._feedback.sequence
             rospy.loginfo('%s: Succeeded' % self._action_name)
             self._as.set_succeeded(self._result)
         
 if __name__ == '__main__':
     rospy.init_node('fibonacci')
     server = FibonacciAction(rospy.get_name())
     rospy.spin()

</code></pre>
<p>You can see more about this code <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Server%20using%20the%20Execute%20Callback%20%28Python%29">here</a>.</p>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<p>Only initially when you just created your tutorial package, you need to compile to generate shell config files.</p>
<pre><code class="language-bash">cd %TOPDIR_YOUR_CATKIN_WORKSPACE%
catkin_make
source devel/setup.bash
</code></pre>
<h2 id="running-the-action-server"><a class="header" href="#running-the-action-server">Running the Action Server</a></h2>
<p>Run: </p>
<pre><code class="language-bash">roscore
</code></pre>
<p>Then on a new terminal, the following command will run the action server.</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_server.py
</code></pre>
<h2 id="writing-a-simple-action-client"><a class="header" href="#writing-a-simple-action-client">Writing a Simple Action Client</a></h2>
<p>The following code can be found in <a href="http://wiki.ros.org/actionlib_tutorials">actionlib_tutorials</a> repository, and implements a simple python action client for the <a href="http://docs.ros.org/api/actionlib_tutorials/html/classfibonacci__server_1_1FibonacciAction.html">fibonacci action</a>.</p>
<pre><code class="language-python">#! /usr/bin/env python3
 
 import rospy
 from __future__ import print_function
 
 # Brings in the SimpleActionClient
 import actionlib
 
 # Brings in the messages used by the fibonacci action, including the
 # goal message and the result message.
 import actionlib_tutorials.msg
 
 def fibonacci_client():
     # Creates the SimpleActionClient, passing the type of the action
     # (FibonacciAction) to the constructor.
     client = actionlib.SimpleActionClient('fibonacci', actionlib_tutorials.msg.FibonacciAction)
 
     # Waits until the action server has started up and started
     # listening for goals.
     client.wait_for_server()
 

     # Creates a goal to send to the action server.
     goal = actionlib_tutorials.msg.FibonacciGoal(order=20)
 
     # Sends the goal to the action server.
     client.send_goal(goal)
 
     # Waits for the server to finish performing the action.
     client.wait_for_result()
 
     # Prints out the result of executing the action
     return client.get_result()  # A FibonacciResult
 
 if __name__ == '__main__':
     try:
         # Initializes a rospy node so that the SimpleActionClient can
         # publish and subscribe over ROS.
         rospy.init_node('fibonacci_client_py')
         result = fibonacci_client()
         print(&quot;Result:&quot;, ', '.join([str(n) for n in result.sequence]))
     except rospy.ROSInterruptException:
         print(&quot;program interrupted before completion&quot;, file=sys.stderr)

</code></pre>
<p>You can read more about the code <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Client%20%28Python%29">here</a>.</p>
<h2 id="running-the-client"><a class="header" href="#running-the-client">Running the client</a></h2>
<p>Before running the client, we assume roscore ans Action server are already running from previous page.</p>
<p>Start the client. It will start up, send a goal to the server, wait for the goal to complete, and then exit.</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_client.py
</code></pre>
<h3 id="reference-4"><a class="header" href="#reference-4">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/actionlib/Tutorials">ROS Wiki</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="action-server--client"><a class="header" href="#action-server--client">Action Server &amp; Client</a></h1>
<p>This tutorial covers using the simple_action_server library to create a Fibonacci action server in Python. This example action server generates a Fibonacci sequence, the goal is the order of the sequence, the feedback is the sequence as it is computed, and the result is the final sequence.</p>
<h2 id="1-creating-the-action-messages"><a class="header" href="#1-creating-the-action-messages">1. Creating the Action Messages</a></h2>
<p>Before writing an action it is important to define the goal, result, and feedback messages. The action messages are generated automatically from the .action file, for more information on action files see the <a href="https://wiki.ros.org/actionlib">actionlib</a> documentation.</p>
<p>Create actionlib_tutorials/action/Fibonacci.action in your favorite editor, and place the following inside it: </p>
<pre><code>#goal definition
int32 order
---
#result definition
int32[] sequence
---
#feedback
int32[] sequence
</code></pre>
<p>To automatically generate the message files during the make process, a few things need to be added to CMakeLists.txt.</p>
<ul>
<li>
<p>add the actionlib_msgs package to the find_package macro’s argument like this (if you used catkin_create_package to generate CMakeLists.txt, this may already have been added): </p>
<pre><code>find_package(catkin REQUIRED COMPONENTS actionlib_msgs)
</code></pre>
<ul>
<li>Note that CMake needs to find_package actionlib_msgs (message_generation does not need to be listed explicitly, it is referenced implicitly by actionlib_msgs).</li>
</ul>
</li>
</ul>
<pre><code>- use the add_action_files macro to declare the actions you want to be generated:

  ```
  add_action_files(
    DIRECTORY action
    FILES Fibonacci.action
  )
  ```

- call the generate_messages macro, not forgetting the dependencies on actionlib_msgs and other message packages like std_msgs: 

  ```
  generate_messages(
    DEPENDENCIES actionlib_msgs std_msgs  # Or other packages containing msgs
  )
  ```

- add actionlib_msgs to catkin_package macro like this: 

  ```
  catkin_package(
    CATKIN_DEPENDS actionlib_msgs
  )
  ```
  - catkin_package also specifies only CATKIN_DEPEND to actionlib_msgs. The transitive dependency on message_runtime is happening automatically. 
</code></pre>
<p>Note: Sometimes you have to setup your package.xml, since we are generating messages you have to declare on the manifest file that at run time you have to generate messages. You could just insert the follow line. </p>
<pre><code>&lt;exec_depend&gt;message_generation&lt;/exec_depend&gt;

</code></pre>
<p>also do not forget to add these in your package.xml.</p>
<pre><code>&lt;build_depend&gt;actionlib&lt;/build_depend&gt;
&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;
&lt;exec_depend&gt;actionlib&lt;/exec_depend&gt;
&lt;exec_depend&gt;actionlib_msgs&lt;/exec_depend&gt;
</code></pre>
<p>now go to the root directory and run:</p>
<pre><code class="language-bash">catkin_make
</code></pre>
<p>you can see the result by the following command:</p>
<pre><code class="language-bash">$ ls devel/share/actionlib_tutorials/msg/
FibonacciActionFeedback.msg  FibonacciAction.msg        FibonacciFeedback.msg
FibonacciResult.msg          FibonacciActionGoal.msg    FibonacciActionResult.msg  FibonacciGoal.msg
$ ls devel/include/actionlib_tutorials/
FibonacciActionFeedback.h  FibonacciAction.h        FibonacciFeedback.h  FibonacciResult.h
FibonacciActionGoal.h      FibonacciActionResult.h  FibonacciGoal.h
</code></pre>
<h2 id="2-writing-a-simple-server"><a class="header" href="#2-writing-a-simple-server">2. Writing a Simple Server</a></h2>
<p>The code and examples used in this tutorial can be found in the <a href="http://wiki.ros.org/actionlib_tutorials">actionlib_tutorials</a> package. You may want to read about the <a href="http://wiki.ros.org/actionlib">actionlib</a> package before starting this tutorial. </p>
<p>The following code can be found in actionlib_tutorials/simple_action_servers/fibonacci_server.py, and implements a python action server for the fibonacci action.</p>
<pre><code class="language-python">#! /usr/bin/env python3
 
import rospy
 
import actionlib

import actionlib_tutorials.msg

class FibonacciAction(object):
    # create messages that are used to publish feedback/result
    _feedback = actionlib_tutorials.msg.FibonacciFeedback()
    _result = actionlib_tutorials.msg.FibonacciResult()

    def __init__(self, name):
        self._action_name = name
        self._as = actionlib.SimpleActionServer(self._action_name, actionlib_tutorials.msg.FibonacciAction, execute_cb=self.execute_cb, auto_start = False)
        self._as.start()
      
    def execute_cb(self, goal):
        # helper variables
        r = rospy.Rate(1)
        success = True
        
        # append the seeds for the fibonacci sequence
        self._feedback.sequence = []
        self._feedback.sequence.append(0)
        self._feedback.sequence.append(1)
        
        # publish info to the console for the user
        rospy.loginfo('%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i' % (self._action_name, goal.order, self._feedback.sequence[0], self._feedback.sequence[1]))
       
        # start executing the action
        for i in range(1, goal.order):
            # check that preempt has not been requested by the client
            if self._as.is_preempt_requested():
                rospy.loginfo('%s: Preempted' % self._action_name)
                self._as.set_preempted()
                success = False
                break
            self._feedback.sequence.append(self._feedback.sequence[i] + self._feedback.sequence[i-1])
            # publish the feedback
            self._as.publish_feedback(self._feedback)
            # this step is not necessary, the sequence is computed at 1 Hz for demonstration purposes
            r.sleep()
          
        if success:
            self._result.sequence = self._feedback.sequence
            rospy.loginfo('%s: Succeeded' % self._action_name)
            self._as.set_succeeded(self._result)
        
if __name__ == '__main__':
    rospy.init_node('fibonacci')
    server = FibonacciAction(rospy.get_name())
    rospy.spin()

</code></pre>
<p>make the script executable. For more information about the code refer <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Server%20using%20the%20Execute%20Callback%20%28Python%29">here</a>.</p>
<h2 id="3-compiling"><a class="header" href="#3-compiling">3. Compiling</a></h2>
<p>Only initially when you just created your tutorial package, you need to compile to generate shell config files.</p>
<pre><code class="language-bash">cd %TOPDIR_YOUR_CATKIN_WORKSPACE%
catkin_make
source devel/setup.bash
</code></pre>
<h2 id="4-writing-a-simple-action-client"><a class="header" href="#4-writing-a-simple-action-client">4. Writing a Simple Action Client</a></h2>
<p>The following code can be found in <a href="https://github.com/ros/common_tutorials/blob/hydro-devel/actionlib_tutorials/scripts/fibonacci_client.py">actionlib_tutorials</a> repository, and implements a simple python action client for the fibonacci action.</p>
<pre><code class="language-python">#! /usr/bin/env python3

from __future__ import print_function

import rospy
# Brings in the SimpleActionClient
import actionlib

# Brings in the messages used by the fibonacci action, including the
# goal message and the result message.
import actionlib_tutorials.msg

def fibonacci_client():
    # Creates the SimpleActionClient, passing the type of the action
    # (FibonacciAction) to the constructor.
    client = actionlib.SimpleActionClient('fibonacci', actionlib_tutorials.msg.FibonacciAction)

    # Waits until the action server has started up and started
    # listening for goals.
    client.wait_for_server()

    # Creates a goal to send to the action server.
    goal = actionlib_tutorials.msg.FibonacciGoal(order=20)

    # Sends the goal to the action server.
    client.send_goal(goal)

    # Waits for the server to finish performing the action.
    client.wait_for_result()

    # Prints out the result of executing the action
    return client.get_result()  # A FibonacciResult

if __name__ == '__main__':
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node('fibonacci_client_py')
        result = fibonacci_client()
        print(&quot;Result:&quot;, ', '.join([str(n) for n in result.sequence]))
    except rospy.ROSInterruptException:
        print(&quot;program interrupted before completion&quot;, file=sys.stderr)
</code></pre>
<p>More details about the code <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Client%20%28Python%29">here</a>.</p>
<h2 id="running-the-client-and-action-server"><a class="header" href="#running-the-client-and-action-server">Running the Client and Action Server</a></h2>
<p>Run:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>Then on a new terminal, the following command will run the action server.</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_server.py
</code></pre>
<p>On second terminal run:</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_client.py
</code></pre>
<h3 id="reference-5"><a class="header" href="#reference-5">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/actionlib/Tutorials">ROS Tutorials Actionlib</a></li>
</ul>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-actions-walkthrough-videos"><a class="header" href="#ros-actions-walkthrough-videos">ROS Actions Walkthrough Videos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-tf"><a class="header" href="#ros-tf">ROS TF</a></h1>
<ul>
<li><code>tf</code> is a package that lets the user keep track of multiple coordinate frames over time.</li>
<li><code>tf</code> maintains the relationship between coordinate frames in a tree structure buffered in time, and lets the user transform points, vectors, etc between any two coordinate frames at any desired point in time.</li>
<li>A robotic system typically has many 3D <a href="http://wiki.ros.org/geometry/CoordinateFrameConventions">coordinate frames</a> that change over time, such as a world frame, base frame, gripper frame, head frame, etc.</li>
<li>tf keeps track of all these frames over time, and allows you to ask questions like:
<ul>
<li>Where was the head frame relative to the world frame, 5 seconds ago?</li>
<li>What is the pose of the object in my gripper relative to my base?</li>
<li>What is the current pose of the base frame in the map frame?</li>
</ul>
</li>
<li>tf can operate in a <code>distributed system</code>. This means all the information about the coordinate frames of a robot is available to all ROS components on any computer in the system. There is <code>no central server</code> of transform information.</li>
</ul>
<h2 id="reference-6"><a class="header" href="#reference-6">Reference</a></h2>
<ul>
<li><a href="http://wiki.ros.org/tf">ROS-wiki</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-tf-using-turtlesim"><a class="header" href="#ros-tf-using-turtlesim">ROS tf using turtlesim:</a></h1>
<p>This tutorial will give you a good idea of what tf can do for you. It shows off some of the tf power in a multi-robot example using <a href="http://wiki.ros.org/turtlesim">turtlesim</a>. This also introduces using <a href="http://wiki.ros.org/tf#tf_echo">tf_echo</a>, <a href="http://wiki.ros.org/tf#view_frames">view_frames</a>, <a href="http://wiki.ros.org/rqt_tf_tree">rqt_tf_tree</a>, and <a href="http://wiki.ros.org/rviz">rviz</a>.</p>
<h2 id="1-set-up-the-demo"><a class="header" href="#1-set-up-the-demo">1. Set Up the Demo</a></h2>
<p>The nodes for this tutorial are released for Ubuntu, so go ahead and install them: </p>
<pre><code class="language-bash">$ sudo apt-get install ros-noetic-ros-tutorials ros-noetic-geometry-tutorials ros-noetic-rviz ros-noetic-rosbash ros-noetic-rqt-tf-tree

</code></pre>
<h2 id="2-running-the-demo"><a class="header" href="#2-running-the-demo">2. Running the Demo</a></h2>
<p>Now that we’re done getting the turtle_tf tutorial package, let’s run the demo. </p>
<pre><code class="language-bash">$ roslaunch turtle_tf turtle_tf_demo.launch
</code></pre>
<p>You will see the turtlesim start with two turtles. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_TF/turtle_tf_start.png" alt="image" /></p>
<p>Once the turtlesim is started you can drive the center turtle around in the turtlesim using the keyboard arrow keys, select the <strong>roslaunch terminal window</strong> so that your keystrokes will be captured to drive the turtle.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_TF/turtle_tf_drive.png" alt="image" /></p>
<p>As you can see that one turtle will continuously move to follow the turtle you are driving around. </p>
<h2 id="3-what-is-happening"><a class="header" href="#3-what-is-happening">3. What is Happening</a></h2>
<p>This demo is using the tf library to create three coordinate frames: a world frame, a turtle1 frame, and a turtle2 frame. This tutorial uses a <strong>tf broadcaster</strong> to publish the turtle coordinate frames and a <strong>tf listener</strong> to compute the difference in the turtle frames and move one turtle to follow the other. </p>
<h3 id="reference-7"><a class="header" href="#reference-7">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf">ros_tf_tutorial</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<blockquote>In this section we will discuss some miscellaneous topics which a basic ROS user should know about.</blockquote>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="rqt_graph"><a class="header" href="#rqt_graph">Rqt_graph</a></h1>
<h2 id="ros-gui-development-tool-rqt"><a class="header" href="#ros-gui-development-tool-rqt">ROS GUI Development Tool (rqt)</a></h2>
<ul>
<li>
<p>ROS provides various GUI tools for robot development.</p>
</li>
<li>
<p>These tools helps to visualize and analyze your ROS Application.</p>
</li>
<li>
<p>Following are some rqt tools provided by ROS.</p>
<ul>
<li>rqt plugins</li>
<li>rqt_image_view</li>
<li>rqt_graph</li>
<li>rqt_plot</li>
<li>rqt_bag</li>
</ul>
</li>
<li>
<p><code>rqt_graph</code> is a tool used to your entire ROS Network as a diagram.</p>
</li>
<li>
<p>This is a very handy tool if you want to visualize how ROS Nodes are communicating with each other and how they are connected to each other.</p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>In this secion, we will see few inspection commands that are used to find information about ROS Nodes and ROS Topics running as a part of a ROS application.</p>
<p>First and foremost, open a new terminal and type roscore command to start your ROS Master node.</p>
<pre><code class="language-bash">$ roscore
</code></pre>
<p>Now the result of this command will resemble he output discussed in previous module. For this module we will be using turtlesim simulator that is part of ROS installation.</p>
<p>Run following command in a new terminal window.</p>
<pre><code class="language-bash">$ rosrun turtlesim turtlesim_node
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">[ INFO] [1601303390.799401514]: Starting turtlesim with node name /turtlesim
[ INFO] [1601303390.804994858]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>You will also see image of a turtle at the center in the display screen, as shown in the output below. The turtle in the window is called as turtle1 because it is the first and only turtle in our display.</p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/turtle.png" alt="image" /></p>
<p>So there will be two terminal windows active which can be minimized or dragged off to the side or bottom but should not be closed. We will use three commands that will help us find our way around.</p>
<p>The first command is, “rosnode list”. This command prints a list of all running nodes on the terminal.</p>
<p>In third terminal, run the following command:</p>
<pre><code class="language-bash">$ rosnode list
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">/rosout
/turtlesim
</code></pre>
<p>The next command “rosnode info “. This command prints node specific information on the terminal.</p>
<pre><code class="language-bash">$ rosnode info /turtlesim
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">Node [/turtlesim]
Publications: 
 * /rosout [rosgraph_msgs/Log]
 * /turtle1/color_sensor [turtlesim/Color]
 * /turtle1/pose [turtlesim/Pose]

Subscriptions: 
 * /turtle1/cmd_vel [unknown type]

Services: 
 * /clear
 * /kill
 * /reset
 * /spawn
 * /turtle1/set_pen
 * /turtle1/teleport_absolute
 * /turtle1/teleport_relative
 * /turtlesim/get_loggers
 * /turtlesim/set_logger_level


 contacting node http://ruchi24-Vostro-15-3568:42299/ ...
 Pid: 12698
 Connections:
  * topic: /rosout
     * to: /rosout
     * direction: outbound (57779 - 127.0.0.1:51260) [24]
     * transport: TCPROS
</code></pre>
<p>And finally, the command “rqt_graph”. This command provides a visual representation of the different nodes and the way they interact with each other. We can see the structure of how topics are passed around the system using rqt_graph.</p>
<p>rqt_graph is part of the rqt package. Unless you already have it installed, run:</p>
<pre><code class="language-bash">$ sudo apt-get install ros-melodic-rqt
$ sudo apt-get install ros-melodic-rqt-common-plugins
</code></pre>
<p>We’ll need something to drive the turtle aroud with. Open a new terminal window and run following command:</p>
<pre><code class="language-bash">$ rosrun turtlesim turtle_teleop_key
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">Reading from keyboard
---------------------------
Use arrow keys to move the turtle. 'q' to quit.
</code></pre>
<p>You can use arrow keys from the keyboard to drive the turtle around. Now that you can drive your turtle around, let’s see what’s going on behind the scenes.</p>
<p>Basically the turtlesim_node and turtle_teleop_key are communicating with each other over a ROS Topic. turtle_teleop_key is publishing the key strokes on a topic, while turtlesim subscribes to the same topic to receive the key strokes.</p>
<p>Open a new terminal window and run following command:</p>
<pre><code class="language-bash">$ rosrun rqt_graph rqt_graph
</code></pre>
<p>You will see output similar to this:</p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph1.png" alt="image" /></p>
<p>If you place your mouse over /turtle1/command_velocity it will highlight the ROS nodes (here blue and green) and topics (here red). As you can see, the turtlesim_node and the turtle_teleop_key nodes are communicating on the topic named /turtle1/command_velocity. </p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph.png" alt="image" /></p>
<hr>
<h3 id="reference-8"><a class="header" href="#reference-8">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingTopics#Using_rqt_graph">ROS Wiki - rqt_graph</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plot-juggler"><a class="header" href="#plot-juggler">Plot Juggler</a></h1>
<ul>
<li>PlotJuggler is an application to plot logged data, in particular timeseries.</li>
<li>It helps to visualize time series that is fast, powerful and intuitive.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><strong>For ROS users, to install PlotJuggler just type:</strong></p>
<pre><code class="language-bash">sudo apt install ros-${ROS_DISTRO}-plotjuggler-ros
</code></pre>
<p>which for ROS-noetic will be:</p>
<pre><code class="language-bash">sudo apt install ros-noetic-plotjuggler-ros
</code></pre>
<p>To launch PlotJuggler on ROS, use the comand:</p>
<pre><code class="language-bash">rosrun plotjuggler plotjuggler
</code></pre>
<p>or, if are using ROS2:</p>
<pre><code class="language-bash">ros2 run plotjuggler plotjuggler

</code></pre>
<p>for more details vist <a href="https://github.com/facontidavide/PlotJuggler/blob/main/README.md">here</a></p>
<h2 id="visualizing-streamed-data"><a class="header" href="#visualizing-streamed-data">Visualizing Streamed Data</a></h2>
<p>PlotJuggler is most commonly used to visualize data that is stored in a log file, for instance a <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or a <a href="http://wiki.ros.org/rosbag">rosbag</a>. This kind of data is usually loaded using plugins named “DataLoader”.</p>
<p>Additionally, it is possible to visualize data that is being streamed. The user can easily start and stope streaming and decide the size of the buffer (in seconds).</p>
<p>Note that some functionalities such as zoom, pan and the time tracker are disabled when streaming is ON.</p>
<p>Lets try it on the turtlesim tutorial.</p>
<p>Open the terminal and run roscore.</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>in second terminal run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>This window will open:
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/turtle.png" alt="image" /></p>
<p>In third terminal run command:</p>
<pre><code class="language-bash">rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'
</code></pre>
<p>this will make the turtle move in a circle.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/revolve.png" alt="image" /></p>
<p>In the fourth terminal run PlotJuggler.</p>
<pre><code class="language-bash">rosrun plotjuggler plotjuggler
</code></pre>
<p>This window will open:
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/PlotJuggler.png" alt="image" /></p>
<p>Under the Streaming tab select ROS Topic Subscriber
and then click on start.</p>
<p>A new window will open.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/select_ros.png" alt="image" /></p>
<p>Select the Ros topic u want for now select /turtle1/pose.</p>
<p>Now turtle1 ros topic will be available inthe timeseries. U can drag and drop individual data or messages that u want to plot.</p>
<p>Select turtle1/pose/x and turtle1/pose/y.</p>
<p>The selected Data will be plotted.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/plot.png" alt="image" /></p>
<h3 id="reference-9"><a class="header" href="#reference-9">Reference</a></h3>
<ul>
<li><a href="https://facontidavide.github.io/PlotJuggler/data_sources/index.html">PlotJuggler</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-bags"><a class="header" href="#ros-bags">ROS Bags</a></h1>
<p>A bag is a file format in ROS for storing ROS <a href="http://wiki.ros.org/Messages">message</a> data. Bags – so named because of their .bag extension – have an important role in ROS, and a variety of tools have been written to allow you to store, process, analyze, and visualize them.</p>
<p>U can read more about them <a href="http://wiki.ros.org/Bags">here</a>.</p>
<h2 id="recording-and-playing-back-data"><a class="header" href="#recording-and-playing-back-data">Recording and playing back data</a></h2>
<p>In this section we will learn how to record data from a running ROS system into a .bag file, and then to play back the data to produce similar behavior in a running system</p>
<p>First, execute the following commands in separate terminals:</p>
<p>Terminal 1:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>Terminal 2:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Terminal 3:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>This will start two nodes - the turtlesim visualizer and a node that allows for the keyboard control of turtlesim using the arrows keys on the keyboard. If you select the terminal window from which you launched turtle_keyboard, you should see something like the following:</p>
<pre><code class="language-bash">Reading from keyboard
---------------------------
Use arrow keys to move the turtle.
</code></pre>
<p>Pressing the arrow keys on the keyboard should cause the turtle to move around the screen. Note that to move the turtle you must have the terminal from which you launched turtlesim selected and not the turtlesim window. </p>
<p>We now will record the published data. Open a new terminal window. In this window run the following commands:</p>
<pre><code class="language-bash">mkdir ~/bagfiles
cd ~/bagfiles
rosbag record -a
</code></pre>
<p>Here we are just making a temporary directory to record data and then running rosbag record with the option -a, indicating that all published topics should be accumulated in a bag file. </p>
<p>Move back to the terminal window with turtle_teleop and move the turtle around for 10 or so seconds.</p>
<p>In the window running rosbag record exit with a Ctrl-C. Now examine the contents of the directory ~/bagfiles. You should see a file with a name that begins with the year, date, and time and the suffix .bag. This is the bag file that contains all topics published by any node in the time that rosbag record was running. </p>
<p>Now that we’ve recorded a bag file using rosbag record we can examine it and play it back using the commands rosbag info and rosbag play. First we are going to see what’s recorded in the bag file. We can do the info command – this command checks the contents of the bag file without playing it back. Execute the following command from the bagfiles directory: </p>
<pre><code class="language-bash">rosbag info &lt;your bagfile&gt;
</code></pre>
<p>You should see something like:</p>
<pre><code class="language-bash">path:        2014-12-10-20-08-34.bag
version:     2.0
duration:    1:38s (98s)
start:       Dec 10 2014 20:08:35.83 (1418270915.83)
end:         Dec 10 2014 20:10:14.38 (1418271014.38)
size:        865.0 KB
messages:    12471
compression: none [1/1 chunks]
types:       geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a]
             rosgraph_msgs/Log   [acffd30cd6b6de30f120938c17c593fb]
             turtlesim/Color     [353891e354491c51aabe32df673fb446]
             turtlesim/Pose      [863b248d5016ca62ea2e895ae5265cf9]
topics:      /rosout                    4 msgs    : rosgraph_msgs/Log   (2 connections)
             /turtle1/cmd_vel         169 msgs    : geometry_msgs/Twist
             /turtle1/color_sensor   6149 msgs    : turtlesim/Color
             /turtle1/pose           6149 msgs    : turtlesim/Pose
</code></pre>
<p>This tells us topic names and types as well as the number (count) of each message topic contained in the bag file. We can see that of the topics being advertised that we saw in the rostopic output, four of the five were actually published over our recording interval. As we ran rosbag record with the -a flag it recorded all messages published by all nodes. </p>
<p>Lets play the bag file to reproduce behavior in the running system. First kill the teleop program that may be still running from the previous section - a Ctrl-C in the terminal where you started turtle_teleop_key. Leave turtlesim running. In a terminal window run the following command in the directory where you took the original bag file:</p>
<pre><code class="language-bash">rosbag play &lt;your bagfile&gt;
</code></pre>
<p>In this window you should immediately see something like:</p>
<pre><code class="language-bash">[ INFO] [1418271315.162885976]: Opening 2014-12-10-20-08-34.bag

Waiting 0.2 seconds after advertising topics... done.

Hit space to toggle paused, or 's' to step.
</code></pre>
<p>Eventually the topic /turtle1/cmd_vel will be published and the turtle should start moving in turtlesim in a pattern similar to the one you executed from the teleop program. The duration between running rosbag play and the turtle moving should be approximately equal to the time between the original rosbag record execution and issuing the commands from the keyboard in the beginning part of the tutorial. You can have rosbag play not start at the beginning of the bag file but instead start some duration past the beginning using the -s argument. A final option that may be of interest is the -r option, which allows you to change the rate of publishing by a specified factor. If you execute:</p>
<pre><code class="language-bash">rosbag play -r 2 &lt;your bagfile&gt;
</code></pre>
<p>You should see the turtle execute a slightly different trajectory - this is the trajectory that would have resulted had you issued your keyboard commands twice as fast. </p>
<h3 id="reference-10"><a class="header" href="#reference-10">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/ROS/Tutorials/Recording%20and%20playing%20back%20data">rosbag tutorial</a></li>
</ul>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="additional-sections"><a class="header" href="#additional-sections">Additional Sections</a></h1>
<ul>
<li>This section will make user get used to terminal and also ros basic commands.</li>
<li>It will also help them later if they’ve to do debugging.</li>
<li>It is practice purpose only.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-your-ros-environment"><a class="header" href="#configuring-your-ros-environment">Configuring your ROS environment</a></h1>
<p><strong>Goal</strong>: This tutorial will show you how to prepare your ROS environment.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before starting these tutorials please complete installation as described in the <a href="http://wiki.ros.org/ROS/Installation">ROS installation instructions</a>.</p>
<h2 id="managing-your-environment"><a class="header" href="#managing-your-environment">Managing Your Environment</a></h2>
<p>During the installation of ROS, you will see that you are prompted to source one of several setup.*sh files, or even add this ‘sourcing’ to your shell startup script. This is required because ROS relies on the notion of combining spaces using the shell environment. This makes developing against different versions of ROS or against different sets of packages easier.</p>
<p>If you are ever having problems finding or using your ROS packages make sure that you have your environment properly setup. A good way to check is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: </p>
<pre><code class="language-bash">$ printenv | grep ROS
</code></pre>
<pre><code class="language-bash">ROS_VERSION=1
ROS_PYTHON_VERSION=3
ROS_PACKAGE_PATH=/home/ubuntu/workspace/src:/opt/ros/noetic/share
ROSLISP_PACKAGE_DIRECTORIES=/home/ubuntu/workspace/devel/share/common-lisp
ROS_ETC_DIR=/opt/ros/noetic/etc/ros
ROS_MASTER_URI=http://localhost:11311
ROS_ROOT=/opt/ros/noetic/share/ros
ROS_DISTRO=noetic
</code></pre>
<p>If they are not then you might need to ‘source’ some setup.*sh files. </p>
<pre><code class="language-bash">$ source /opt/ros/noetic/setup.bash
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You will need to run this command on every new shell you open to have access to the ROS commands, unless you add this line to your .bashrc.</p>
</blockquote>
<p>To add this line to .bashrc run this command:</p>
<pre><code class="language-bash">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>To undo this (to change to another distro) in Linux and macOS, locate your system’s shell startup script and remove the appended source command.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The ROS development environment needs to be correctly configured before use. This can be done in two ways: either sourcing the setup files in every new shell you open, or adding the source command to your startup script.</p>
<p>If you ever face any problems locating or using packages with ROS, the first thing you should do is check your environment variables and ensure they are set to the version and distro you intended.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-turtlesim-and-rqt"><a class="header" href="#introducing-turtlesim-and-rqt">Introducing turtlesim and rqt</a></h1>
<p><strong>Goal</strong>: Install and use the turtlesim package and rqt tools to prepare for upcoming tutorials.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level, to give you an idea of what you will do with a real robot or robot simulation later on.</p>
<p>rqt is a GUI tool for ROS. Everything done in rqt can be done on the command line, but it provides an easier, more user-friendly way to manipulate ROS elements.</p>
<p>This tutorial touches on core ROS concepts, like the separation of nodes, topics, and services. All of these concepts will be elaborated on in later tutorials; for now, you will simply set up the tools and get a feel for them.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>The previous tutorial, <a href="Additional_Sections/configuring_your_ros_environment.html">Configuring your ROS environment</a>, will show you how to set up your environment.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<h3 id="1-start-rosmaster"><a class="header" href="#1-start-rosmaster">1 Start rosmaster</a></h3>
<pre><code class="language-bash">roscore
</code></pre>
<h3 id="2-start-turtlesim"><a class="header" href="#2-start-turtlesim">2 Start turtlesim</a></h3>
<p>To start turtlesim, enter the following command in your terminal:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>The simulator window should appear, with a random turtle in the center.</p>
<p><img src="Additional_Sections/turtlesim_node-turtle1.png" alt="turtlesim_node-turtle1.png" /></p>
<p>In the terminal under the command, you will see messages from the node:</p>
<pre><code class="language-bash">[ INFO] [1622133713.331795042]: Starting turtlesim with node name /turtlesim
[ INFO] [1622133713.335199049]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>Here you can see your default turtle’s name is <code>turtle1</code>, and the default coordinates where it spawns.</p>
<h3 id="3-use-turtlesim"><a class="header" href="#3-use-turtlesim">3 Use turtlesim</a></h3>
<p>Open a new terminal and source ROS again.</p>
<p>Now you will run a new node to control the turtle in the first node:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>At this point you should have four windows open: a terminal running <code>roscore</code>, a terminal running <code>turtlesim_node</code>, a terminal running <code>turtle_teleop_key</code> and the turtlesim window. Arrange these windows so that you can see the turtlesim window, but also have the terminal running <code>turtle_teleop_key</code> active so that you can control the turtle in turtlesim.</p>
<p>Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached “pen” to draw the path it followed so far.</p>
<blockquote>
<p><strong>Note</strong>: Pressing an arrow key will only cause the turtle to move a short distance and then stop. This is because, realistically, you wouldn’t want a robot to continue carrying on an instruction if, for example, the operator lost the connection to the robot.</p>
</blockquote>
<p>You can see the nodes and their associated services, topics using the list command:</p>
<pre><code class="language-bash">rosnode list
rostopic list
rosservice list
</code></pre>
<p>You will learn more about these concepts in the coming tutorials. Since the goal of this tutorial is only to get a general overview of turtlesim, we will use rqt (a graphical user interface for ROS) to look at services a little closer.</p>
<h3 id="4-run-rqt"><a class="header" href="#4-run-rqt">4 Run rqt</a></h3>
<p>Open a new terminal to run <code>rqt</code>:</p>
<pre><code class="language-bash">rqt
</code></pre>
<p>After running rqt the first time, the window will be blank. No worries; just select Plugins &gt; Services &gt; Service Caller from the menu bar at the top.</p>
<blockquote>
<p><strong>Note</strong>: It may take some time for rqt to locate all the plugins itself. If you click on Plugins, but don’t see Services or any other options, you should close rqt, enter the command <code>rqt --force-discover</code> in your terminal.</p>
</blockquote>
<p>Use the refresh button to the left of the <strong>Service</strong> dropdown list to ensure all the services of your turtlesim node are available.</p>
<p>Click on the Service dropdown list to see turtlesim’s services, and select the <code>/spawn</code> service.</p>
<h4 id="41-try-the-spawn-service"><a class="header" href="#41-try-the-spawn-service">4.1 Try the spawn service</a></h4>
<p>Let’s use rqt to call the <code>/spawn</code> service. You can guess from its name that <code>/spawn</code> will create another turtle in the turtlesim window.</p>
<p>Give the new turtle a unique name, like <code>turtle2</code> by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the <strong>name</strong> value, and is of type <strong>string</strong>.</p>
<p>Enter new coordinates for the turtle to spawn at, like <code>x = 1.0</code> and <code>y = 1.0</code>.</p>
<p><img src="Additional_Sections/rqt-spawn-turtle2.png" alt="rqt-spawn-turtle2.png" /></p>
<blockquote>
<p><strong>Note</strong>: If you try to spawn a new turtle with the same name as an existing turtle, like your default <code>turtle1</code>, you will get an error message in the terminal running <code>turtlesim_node</code>:</p>
</blockquote>
<pre><code class="language-bash">[ERROR] [1622134917.034342076]: A turtled named [turtle1] already exists
</code></pre>
<p>To spawn turtle2, you have to call the service by clicking the <strong>Call</strong> button on the upper right side of the rqt window.</p>
<p>You will see a new turtle (again with a random design) spawn at the coordinates you input for <strong>x</strong> and <strong>y</strong>.</p>
<p>If you refresh the service list in rqt, you will also see that now there are services related to the new turtle, <code>/turtle2/…</code>, in addition to <code>/turtle1/…</code>.</p>
<h4 id="42-try-the-set_pen-service"><a class="header" href="#42-try-the-set_pen-service">4.2 Try the set_pen service</a></h4>
<p>Now let’s give turtle1 a unique pen using the <code>/set_pen</code> service:</p>
<p><img src="Additional_Sections/rqt-set-pen-turtle1.png" alt="rqt-set-pen-turtle1.png" /></p>
<p>The values for <strong>r</strong>, <strong>g</strong> and <strong>b</strong>, between 0 and 255, will set the color of the pen turtle1 draws with, and <strong>width</strong> sets the thickness of the line.</p>
<p>To have turtle1 draw with a distinct red line, change the value of <strong>r</strong> to 255, and the value of width to <strong>5</strong>. Don’t forget to call the service after updating the values.</p>
<p>If you return to the terminal where <code>turtle_teleop_node</code> is running and press the arrow keys, you will see turtle1’s pen has changed.</p>
<p><img src="Additional_Sections/turtlesim-set-pen-turtle1.png" alt="turtlesim-set-pen-turtle1.png" /></p>
<p>You’ve probably noticed that there’s no way to move turtle2. You can accomplish this by remapping turtle1’s <code>cmd_vel</code> topic onto turtle2.</p>
<h3 id="5-remapping"><a class="header" href="#5-remapping">5 Remapping</a></h3>
<p>In a new terminal, source ROS, and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node __name:=turtle2 --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel
</code></pre>
<blockquote>
<p><strong>Note</strong>: Notice that __name:=turtle2 starts the node with name <code>turtle2</code>. This avoids conflicts if we start two nodes with same name.</p>
</blockquote>
<p>Now you can move turtle2 when this terminal is active, and turtle1 when the other terminal running the <code>turtle_teleop_key</code> is active.</p>
<p><img src="Additional_Sections/turtlesim-two-turtles.png" alt="turtlesim-two-turtles.png" /></p>
<h3 id="close-turtlesim"><a class="header" href="#close-turtlesim">Close turtlesim</a></h3>
<p>To stop the simulation, you can simply close the terminal windows where you ran <code>turtlesim_node</code> and <code>turtle_teleop_key</code>. If you want to keep those terminals open, but end the simulation, you can enter Ctrl + C in the turtlesim_node terminal, and q in the teleop terminal.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Using turtlesim and rqt is a great way to learn the core concepts of ROS.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-nodes"><a class="header" href="#understanding-ros-nodes">Understanding ROS nodes</a></h1>
<p><strong>Goal</strong>: Learn about the function of nodes in ROS, and the tools to interact with them.</p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<h3 id="1-the-ros-graph"><a class="header" href="#1-the-ros-graph">1 The ROS graph</a></h3>
<p>Over the next few tutorials, you will learn about a series of core ROS concepts that make up what is referred to as the “ROS graph”.</p>
<p>The ROS graph is a network of ROS elements processing data together at one time. It encompasses all executables and the connections between them if you were to map them all out and visualize them.</p>
<h3 id="2-nodes-in-ros"><a class="header" href="#2-nodes-in-ros">2 Nodes in ROS</a></h3>
<p>Each node in ROS should be responsible for a single, module purpose (e.g. one node for controlling wheel motors, one node for controlling a laser range-finder, etc). Each node can send and receive data to other nodes via topics, services, actions, or parameters.</p>
<p><img src="Additional_Sections/node-graph.gif" alt="node-graph.gif" /></p>
<p>A full robotic system is comprised of many nodes working in concert.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS in every new terminal you open. Also, run <code>roscore</code> in a
separate terminal.</p>
<h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<h3 id="1-rosrun"><a class="header" href="#1-rosrun">1 rosrun</a></h3>
<p>The command <code>rosrun</code> launches an executable from a package.</p>
<pre><code class="language-bash">rosrun &lt;package_name&gt; &lt;executable_name&gt;
</code></pre>
<p>To run turtlesim, open a new terminal, and enter the following command:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Here, the package name is <code>turtlesim</code> and the executable name is <code>turtlesim_node</code>.</p>
<p>We still don’t know the node name, however. You can find node names by using <code>rosnode list</code></p>
<h3 id="2-rosnode-list"><a class="header" href="#2-rosnode-list">2 rosnode list</a></h3>
<p><code>rosnode list</code> will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them.</p>
<p>Open a new terminal while turtlesim is still running in the other one, and enter the following command:</p>
<pre><code class="language-bash">rosnode list
</code></pre>
<p>The terminal will return the node name:</p>
<pre><code class="language-bash">/rosout
/turtlesim
</code></pre>
<p>Open another new terminal and start the teleop node with the command:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>Here, we are searching the <code>turtlesim</code> package again, this time for the executable named <code>turtle_teleop_key</code>.</p>
<p>Return to the terminal where you ran <code>rosnode list</code> and run it again. You will now see the names of two active nodes:</p>
<pre><code class="language-bash">/rosout
/teleop_turtle
/turtlesim
</code></pre>
<h4 id="21-remapping"><a class="header" href="#21-remapping">2.1 Remapping</a></h4>
<p><a href="http://wiki.ros.org/Remapping%20Arguments">Remapping</a> allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. In the last tutorial, you used remapping on <code>turtle_teleop_key</code> to change the default turtle being controlled.</p>
<p>Now, lets reassign the name of our <code>/turtlesim</code> node. In a new terminal, run the following command:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node __name:=my_turtle
</code></pre>
<p>Since you’re calling <code>rosrun</code> on turtlesim again, another turtlesim window will open. However, now if you return to the terminal where you ran <code>rosnode list</code>, and run it again, you will see three node names:</p>
<pre><code class="language-bash">/my_turtle
/rosout
/teleop_turtle
/turtlesim
</code></pre>
<h3 id="3-rosnode-info"><a class="header" href="#3-rosnode-info">3 rosnode info</a></h3>
<p>Now that you know the names of your nodes, you can access more information about them with:</p>
<pre><code class="language-bash">rosnode info &lt;node_name&gt;
</code></pre>
<p>To examine your latest node, <code>my_turtle</code>, run the following command:</p>
<pre><code class="language-bash">rosnode info /my_turtle
</code></pre>
<p><code>rosnode info</code> returns a list of subscribers, publishers, services, and actions (the ROS graph connections) that interact with that node. The output should look like this:</p>
<pre><code class="language-bash">Node [/my_turtle]
Publications: 
 * /rosout [rosgraph_msgs/Log]
 * /turtle1/color_sensor [turtlesim/Color]
 * /turtle1/pose [turtlesim/Pose]

Subscriptions: 
 * /turtle1/cmd_vel [geometry_msgs/Twist]

Services: 
 * /clear
 * /kill
 * /my_turtle/get_loggers
 * /my_turtle/set_logger_level
 * /reset
 * /spawn
 * /turtle1/set_pen
 * /turtle1/teleport_absolute
 * /turtle1/teleport_relative


contacting node http://ros-noetic:44953/ ...
Pid: 878
Connections:
 * topic: /rosout
    * to: /rosout
    * direction: outbound (40097 - 10.104.247.68:60584) [18]
    * transport: TCPROS
 * topic: /turtle1/cmd_vel
    * to: /teleop_turtle (http://ros-noetic:44321/)
    * direction: inbound (58058 - ros-noetic:47853) [17]
    * transport: TCPROS
</code></pre>
<p>Now try running the same command on the <code>/teleop_turtle node</code>, and see how its connections differ from <code>my_turtle</code>.</p>
<p>You will learn more about ROS graph connection concepts in the upcoming tutorials.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>A node is a fundamental ROS element that serves a single, modular purpose in a robotics system.</p>
<p>In this tutorial, you utilized nodes created from the <code>turtlesim</code> package by running the executables <code>turtlesim_node</code> and <code>turtle_teleop_key</code>.</p>
<p>You learned how to use <code>rosnode list</code> to discover active node names and <code>rosnode info</code> to introspect on a single node. These tools are vital to understanding the flow of data in a complex, real-world robot system.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-topics"><a class="header" href="#understanding-ros-topics">Understanding ROS topics</a></h1>
<p><strong>Goal</strong>: Use rqt_graph and command line tools to introspect ROS topics.</p>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<p>ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages.</p>
<p><img src="Additional_Sections/topic-single-publisher-and-single-subscriber.gif" alt="topic-single-publisher-and-single-subscriber.gif" /></p>
<p>A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics.</p>
<p><img src="Additional_Sections/topic-multiple.gif" alt="topic-multiple.gif" /></p>
<p>Topics are one of the important ways that data moves between nodes, and therefore between different parts of the system.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS 2 in every new terminal you open. Run <code>roscore</code> in a separate terminal.</p>
<h2 id="tasks-2"><a class="header" href="#tasks-2">Tasks</a></h2>
<h3 id="1-setup"><a class="header" href="#1-setup">1 Setup</a></h3>
<p>By now you should be comfortable starting up turtlesim.</p>
<p>Open a new terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Open another terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>Recall from the [previous tutorial] that the names of these nodes are <code>/turtlesim</code> and <code>/teleop_turtle</code> by default.</p>
<h3 id="2-rqt_graph"><a class="header" href="#2-rqt_graph">2 rqt_graph</a></h3>
<p>Throughout this tutorial, we will use <code>rqt_graph</code> to visualize the changing nodes and topics, as well as the connections between them.</p>
<p>To run rqt_graph, open a new terminal and enter the command:</p>
<pre><code class="language-bash">rqt_graph
</code></pre>
<p>You can also open <code>rqt_graph</code> by opening rqt and selecting <strong>Plugins</strong> &gt; <strong>Introspection</strong> &gt; <strong>Nodes Graph</strong>.</p>
<p><img src="Additional_Sections/rqt-graph-rostopic.png" alt="rqt-graph-rostopic.png" /></p>
<p>You should see the above nodes and topic. If you hover your mouse over the topic in the center, you’ll see the color highlighting like in the image above.</p>
<p>The graph is depicting how the <code>/turtlesim</code> node and the <code>/teleop_turtle</code> node are communicating with each other over a topic. The <code>/teleop_turtle</code> node is publishing data (the keystrokes you enter to move the turtle around) to the <code>/turtle1/cmd_vel</code> topic, and the <code>/turtlesim</code> node is subscribed to that topic to receive the data.</p>
<p>The highlighting feature of <strong>rqt_graph</strong> is very helpful when examining more complex systems with many nodes and topics connected in many different ways.</p>
<p><code>rqt_graph</code> is a graphical introspection tool. Now we’ll look at some command line tools for introspecting topics.</p>
<h3 id="rostopic-list"><a class="header" href="#rostopic-list">rostopic list</a></h3>
<p>Running the <code>rostopic list</code> command in a new terminal will return a list of all the topics currently active in the system:</p>
<pre><code class="language-bash">/rosout
/rosout_agg
/statistics
/turtle1/cmd_vel
/turtle1/color_sensor
/turtle1/pose
</code></pre>
<p>Topics have names and types. These attributes, particularly the type, are how nodes know they’re talking about the same information as it moves over topics. To show the topic type run this command:</p>
<pre><code class="language-bash">rostopic type /turtle1/cmd_vel 
</code></pre>
<pre><code class="language-bash">geometry_msgs/Twist
</code></pre>
<p>If you’re wondering where all these topics are in rqt_graph, you can uncheck all the boxes under Hide:</p>
<p><img src="Additional_Sections/rqt-graph-unhidden.png" alt="rqt-graph-unhidden.png" /></p>
<p>For now, though, leave those options checked to avoid confusion.</p>
<h3 id="4-rostopic-echo"><a class="header" href="#4-rostopic-echo">4 rostopic echo</a></h3>
<p>To see the data being published on a topic, use:</p>
<pre><code class="language-bash">rostopic echo &lt;topic_name&gt;
</code></pre>
<p>Since we know that <code>/teleop_turtle</code> publishes data to <code>/turtlesim</code> over the <code>/turtle1/cmd_vel</code> topic, let’s use echo to introspect on that topic:</p>
<pre><code class="language-bash">rostopic echo /turtle1/cmd_vel
</code></pre>
<p>At first, this command won’t return any data. That’s because it’s waiting for <code>/teleop_turtle</code> to publish something.</p>
<p>Return to the terminal where <code>turtle_teleop_key</code> is running and use the arrows to move the turtle around. Watch the terminal where your <code>echo</code> is running at the same time, and you’ll see position data being published for every movement you make:</p>
<pre><code class="language-bash">linear: 
  x: 2.0
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0
---
</code></pre>
<p>Now return to rqt_graph and uncheck the Debug box.</p>
<p><img src="Additional_Sections/rqt-graph-cli.png" alt="rqt-graph-cli.png" /></p>
<p><code>/rostopic_2309_1622187461192</code> is the node created by the <code>echo</code> we just ran (the number will change). Now you can see that the publisher is publishing data over the <code>cmd_vel</code> topic, and two subscribers are subscribed.</p>
<h3 id="5-rostopic-info"><a class="header" href="#5-rostopic-info">5 rostopic info</a></h3>
<p>Topics don’t have to only be point-to-point communication; it can be one-to-many, many-to-one, or many-to-many.</p>
<p>Another way to look at this is running:</p>
<pre><code class="language-bash">rostopic info /turtle1/cmd_vel
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">Type: geometry_msgs/Twist

Publishers: 
 * /teleop_turtle (http://ros-noetic:44037/)

Subscribers: 
 * /turtlesim (http://ros-noetic:44297/)
 * /rostopic_2309_1622187461192 (http://ros-noetic:45255/)
</code></pre>
<h3 id="6-rosmsg-show"><a class="header" href="#6-rosmsg-show">6 rosmsg show</a></h3>
<p>Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate.</p>
<p>The topic types we saw earlier after running <code>rostopic type &lt;topic-name&gt;</code> let us know what type of messages each topic can send. Recall that the <code>cmd_vel</code> topic has the type:</p>
<pre><code class="language-bash">geometry_msgs/Twist
</code></pre>
<p>This means that in the package <code>geometry_msgs</code> there is a message called <code>Twist</code>.</p>
<p>Now we can run `rosmsg show <type>.msg on this type to learn its details, specifically, what structure of data the message expects.</p>
<pre><code class="language-bash">rosmsg show geometry_msgs/Twist
</code></pre>
<pre><code class="language-bash">geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
</code></pre>
<p>This tells you that the <code>/turtlesim</code> node is expecting a message with two vectors, <code>linear</code> and <code>angular</code>, of three elements each. If you recall the data we saw <code>/teleop_turtle</code> passing to <code>/turtlesim</code> with the <code>echo</code> command, it’s in the same structure:</p>
<pre><code class="language-bash">linear: 
  x: 2.0
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0
---
</code></pre>
<h3 id="rostopic-pub"><a class="header" href="#rostopic-pub">rostopic pub</a></h3>
<p>Now that you have the message structure, you can publish data onto a topic directly from the command line using:</p>
<pre><code class="language-bash">rostopic pub &lt;topic_name&gt; &lt;msg_type&gt; '&lt;args&gt;'
</code></pre>
<p>The <code>'&lt;args&gt;'</code> argument is the actual data you’ll pass to the topic, in the structure you just discovered in the previous section.</p>
<p>It’s important to note that this argument needs to be input in YAML syntax. Input the full command like so:</p>
<pre><code class="language-bash">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
</code></pre>
<p><code>-1</code> is an optional argument meaning “publish one message then exit”.</p>
<p>You will receive the following message in the terminal:</p>
<pre><code class="language-bash">publishing and latching message for 3.0 seconds
</code></pre>
<p>And you will see your turtle move like so:</p>
<p><img src="Additional_Sections/turtle1-rostopic-pub-once.png" alt="turtle1-rostopic-pub-once.png" /></p>
<p>The turtle (and commonly the real robots which it is meant to emulate) require a steady stream of commands to operate continuously. So, to get the turtle to keep moving, you can run:</p>
<pre><code class="language-bash">rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
</code></pre>
<p>The difference here is the removal of the <code>-1</code> option and the addition of the <code>--rate 1</code> option, which tells <code>rostopic pub</code> to publish the command in a steady stream at 1 Hz.</p>
<p><img src="Additional_Sections/turtle1-rostopic-pub.gif" alt="turtle1-rostopic-pub.gif" /></p>
<p>You can refresh <strong>rqt_graph</strong> to see what’s happening graphically. You will see the <code>rostopic pub ... </code> node (<code>/rostopic_3050_1622189437717</code>) is publishing over the <code>/turtle1/cmd_vel</code> topic, and is being received by both the <code>rostopic echo ... </code> node (<code>/rostopic_2309_1622187461192</code>) and the <code>/turtlesim node</code> now.</p>
<p><img src="Additional_Sections/rqt_graph-pub.png" alt="rqt_graph-pub.png" /></p>
<p>Finally, you can run <code>echo</code> on the <code>pose</code> topic and recheck rqt_graph:</p>
<pre><code class="language-bash">rostopic echo /turtle1/pose
</code></pre>
<p><img src="Additional_Sections/rqt_graph-echo-pose.png" alt="rqt_graph-echo-pose.png" /></p>
<p>In this case, <code>/turtlesim</code> is now publishing to the <code>pose</code> topic, and a new <code>echo</code> node is subscribed.</p>
<h3 id="8-rostopic-hz"><a class="header" href="#8-rostopic-hz">8 rostopic hz</a></h3>
<p>For one last introspection on this process, you can report the rate at which data is published using:</p>
<pre><code class="language-bash">rostopic hz /turtle1/pose 
</code></pre>
<p>It will return data on the rate at which the <code>/turtlesim</code> node is publishing data to the <code>pose</code> topic.</p>
<pre><code class="language-bash">average rate: 62.527
	min: 0.015s max: 0.017s std dev: 0.00041s window: 62
</code></pre>
<p>Recall that you set the rate of <code>turtle1/cmd_vel</code> to publish at a steady 1 Hz using <code>rostopic pub -r 1</code>. If you run the above command with <code>turtle1/cmd_vel</code> instead of <code>turtle1/pose</code>, you will see an average reflecting that rate.</p>
<h3 id="9-clean-up"><a class="header" href="#9-clean-up">9 Clean up</a></h3>
<p>At this point you’ll have a lot of nodes running. Don’t forget to stop them, either by closing the terminal windows or entering <code>Ctrl+C</code> in each terminal.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Nodes publish information over topics, which allows any number of other nodes to subscribe to and access that information. In this tutorial you examined the connections between several nodes over topics using rqt_graph and command line tools. You should now have a good idea of how data moves around a ROS system.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-services"><a class="header" href="#understanding-ros-services">Understanding ROS Services</a></h1>
<p><strong>Goal</strong>: Learn about services in ROS using command line tools.</p>
<h2 id="background-3"><a class="header" href="#background-3">Background</a></h2>
<p>Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model, versus topics’ publisher-subscriber model. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client.</p>
<p><img src="Additional_Sections/Service-SingleServiceClient.gif" alt="Service-SingleServiceClient.gif" /></p>
<p><img src="Additional_Sections/Service-MultipleServiceClient.gif" alt="Service-MultipleServiceClient.gif" /></p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS 2 in every new terminal you open.</p>
<p>Run <code>roscore</code> in a separate terminal.</p>
<h2 id="tasks-3"><a class="header" href="#tasks-3">Tasks</a></h2>
<h3 id="1-setup-1"><a class="header" href="#1-setup-1">1 Setup</a></h3>
<p>Start up the two turtlesim nodes, <code>/turtlesim</code> and <code>/teleop_turtle</code>.</p>
<p>Open a new terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Open another terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<h3 id="2-rosservice-list"><a class="header" href="#2-rosservice-list">2 rosservice list</a></h3>
<p>Running the <code>rosservice list</code> command in a new terminal will return a list of all the services currently active in the system:</p>
<pre><code class="language-bash">/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/teleop_turtle/get_loggers
/teleop_turtle/set_logger_level
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
</code></pre>
<p>For now, let’s focus on the turtlesim-specific services, <code>/clear</code>, <code>/kill</code>, <code>/reset</code>, <code>/spawn</code>, <code>/turtle1/set_pen</code>, <code>/turtle1/teleport_absolute</code>, and <code>/turtle1/teleport_relative</code>. You may recall interacting with some of these services using rqt in the `[<a href="Additional_Sections/introducing_turtlesim_and_rqt.html">“Introducing turtlesim and rqt”</a> tutorial.</p>
<h3 id="3-rosservice-type"><a class="header" href="#3-rosservice-type">3 rosservice type</a></h3>
<p>Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response.</p>
<p>To find out the type of a service, use the command:</p>
<pre><code class="language-bash">rosservice type &lt;service_name&gt;
</code></pre>
<p>Let’s take a look at turtlesim’s <code>/clear</code> service. In a new terminal, enter the command:</p>
<pre><code class="language-bash">rosservice type /clear
</code></pre>
<p>Which should return:</p>
<pre><code class="language-bash">std_srvs/Empty
</code></pre>
<p>The <code>Empty</code> type means the service call sends no data when making a request and receives no data when receiving a response.</p>
<h3 id="4-rosservice-find"><a class="header" href="#4-rosservice-find">4 rosservice find</a></h3>
<p>If you want to find all the services of a specific type, you can use the command:</p>
<pre><code class="language-bash">rosservice find &lt;type_name&gt;
</code></pre>
<p>For example, you can find all the <code>Empty</code> typed services like this:</p>
<pre><code class="language-bash">rosservice find std_srvs/Empty 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">/clear
/reset
</code></pre>
<h3 id="5-rossrv-show"><a class="header" href="#5-rossrv-show">5 rossrv show</a></h3>
<p>You can call services from the command line, but first you need to know the structure of the input arguments.</p>
<pre><code class="language-bash">rossrv show &lt;type_name&gt;
</code></pre>
<p>To run this command on the <code>/clear</code> service’s type, <code>Empty</code>:</p>
<pre><code class="language-bash">rossrv show std_srvs/Empty 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">---
</code></pre>
<p>The <code>---</code> separates the request structure (above) from the response structure (below). But, as you learned earlier, the <code>Empty</code> type doesn’t send or receive any data. So, naturally, its structure is blank.</p>
<p>Let’s introspect a service with a type that sends and receives data, like <code>/spawn</code>. From the results of <code>rosservice list</code> and <code>rosservice type</code>, we know <code>/spawn</code>’s type is <code>turtlesim/Spawn</code>.</p>
<p>To see the arguments in a <code>/spawn</code> call-and-request, run the command:</p>
<pre><code class="language-bash">rossrv show turtlesim/Spawn 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">float32 x
float32 y
float32 theta
string name
---
string name
</code></pre>
<p>The information above the <code>---</code> line tells us the arguments needed to call <code>/spawn</code>. <code>x</code>, <code>y</code> and <code>theta</code> determine the location of the spawned turtle, and <code>name</code> is clearly optional.</p>
<p>The information below the line isn’t something you need to know in this case, but it can help you understand the data type of the response you get from the call.</p>
<h3 id="6-rosservice-call"><a class="header" href="#6-rosservice-call">6 rosservice call</a></h3>
<p>Now that you know what a service type is, how to find a service’s type, and how to find the structure of that type’s arguments, you can call a service using:</p>
<pre><code class="language-bash">rosservice call &lt;service_name&gt; &lt;arguments&gt;
</code></pre>
<p>The <code>&lt;arguments&gt;</code> part is optional. For example, you know that <code>Empty</code> typed services don’t have any arguments:</p>
<pre><code class="language-bash">rosservice call /clear
</code></pre>
<p>This command will clear the turtlesim window of any lines your turtle has drawn.</p>
<p><img src="Additional_Sections/rosservice-call-clear-before.png" alt="rosservice-call-clear-before.png" /></p>
<p><img src="Additional_Sections/rosservice-call-clear-after.png" alt="rosservice-call-clear-after.png" /></p>
<p>Now let’s spawn a new turtle by calling <code>/spawn</code> and inputting arguments. Input <code>&lt;arguments&gt;</code> in a service call from the command-line need to be in YAML syntax.</p>
<p>Enter the command:</p>
<pre><code class="language-bash">rosservice call /spawn &quot;{x: 2, y: 2, theta: 0.2, name: ''}&quot;
</code></pre>
<p>You will get this output on terminal:</p>
<pre><code class="language-bash">name: &quot;turtle2&quot;
</code></pre>
<p>Your turtlesim window will update with the newly spawned turtle right away:</p>
<p><img src="Additional_Sections/rosservice-call-spawn.png" alt="rosservice-call-spawn.png" /></p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Nodes can communicate using services in ROS. Unlike a topic - a one way communication pattern where a node publishes information that can be consumed by one or more subscribers - a service is a request/response pattern where a client makes a request to a node providing the service and the service processes the request and generates a reponse.</p>
<p>You generally don’t want to use a service for continuous calls; topics or even actions would be better suited.</p>
<p>In this tutorial you used command line tools to identify, elaborate on, and call services.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-with-gazebo"><a class="header" href="#ros-with-gazebo">ROS with Gazebo</a></h1>
<h2 id="difficulty-intermediate"><a class="header" href="#difficulty-intermediate">Difficulty: Intermediate</a></h2>
<hr />
<p>This page is just to quick overview of the simulation and visualization tools in ROS. </p>
<blockquote>
<p><strong>Note</strong>: ROS and Gazebo together are a great combination to simulate how your algoirthm would work in real time scenarios. </p>
</blockquote>
<h2 id="gazebo-simulator"><a class="header" href="#gazebo-simulator">Gazebo Simulator</a></h2>
<ul>
<li>
<p>Robot simulation is an essential tool in every roboticist’s toolbox.</p>
</li>
<li>
<p>A robust physics engine, high-quality graphics, and convenient programmatic and graphical interfaces, makes Gazebo a top Choice for 3D Simulator.</p>
</li>
</ul>
<p><strong>.world</strong> File: The file used to describe a collection of objects (such as buildings, tables, and lights), and global parameters including the sky, ambient light, and physics properties.</p>
<h3 id="reference-11"><a class="header" href="#reference-11">Reference</a></h3>
<ol>
<li><a href="http://gazebosim.org/tutorials">Gazebo Tutorials</a></li>
</ol>
<hr />
<h2 id="rviz"><a class="header" href="#rviz">RViz</a></h2>
<ul>
<li>
<p>Visualizing sensor information is an important part in developing and debugging controllers. </p>
</li>
<li>
<p>Rviz is a powerful 3D visualization tool in ROS that will hep you do exactly that.</p>
</li>
<li>
<p>It allows the user to view the simulated robot model, log sensor information from the robot’s sensors, and replay the logged sensor information.</p>
</li>
</ul>
<h3 id="reference-12"><a class="header" href="#reference-12">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/rviz">ROS Wiki: RViz</a></li>
<li><a href="http://gazebosim.org/tutorials?tut=drcsim_visualization&amp;cat=drcsim">Gazebo: Visualization and logging</a></li>
</ol>
<hr />
<h2 id="urdf"><a class="header" href="#urdf">URDF</a></h2>
<ul>
<li>
<p>The Unified Robot Description Format (URDF) contains a number of XML specifications for robot models, sensors, scenes, etc. </p>
</li>
<li>
<p>It describes the position of all the joints, sensors, type of joints, structure of the robot base, arm etc. </p>
</li>
</ul>
<h3 id="reference-13"><a class="header" href="#reference-13">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/urdf">ROS Wiki: URDF overview</a></li>
<li><a href="http://wiki.ros.org/urdf/Tutorials">ROS Wiki: URDF Tutorials</a></li>
</ol>
<hr />
<h2 id="xacro"><a class="header" href="#xacro">XACRO</a></h2>
<ul>
<li>Xacro (XML Macros) Xacro is an XML macro language. </li>
<li>With xacro, you can construct shorter and more readable XML files by using macros that expand to larger XML expressions.</li>
<li>Xacro is useful when the structure of the robot is complex so instead of describing the whole structure in an urdf we can divide the structure in small parts and call those macro files in the main xacro file.</li>
<li>Xacros also make it easier to define common structures. For example, let’s say the robot has 2 wheels, we just need to make macros of a cylindrical structure(wheels), call it in the main xacro file and then define 2 different joints using the same structure but giving different joint location. </li>
</ul>
<h3 id="reference-14"><a class="header" href="#reference-14">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/urdf/Tutorials/Using%20Xacro%20to%20Clean%20Up%20a%20URDF%20File">ROS Wiki: Using Xacro to Clean Up a URDF File</a></li>
<li><a href="http://wiki.ros.org/xacro">ROS Wiki: Xacro overview</a></li>
</ol>
<hr />
<h2 id="gazebo-plugins"><a class="header" href="#gazebo-plugins">Gazebo Plugins</a></h2>
<ul>
<li>A Gazebo plugin needs to be added to your URDF that actually parses the transmission tags and loads the appropriate hardware interfaces and controller manager. </li>
<li>Plugins basically replicate exact architecture of the sensors in use or the control system used to control the movement of the robot. </li>
</ul>
<h3 id="what-are-transmission-tags"><a class="header" href="#what-are-transmission-tags">What are Transmission Tags?</a></h3>
<ul>
<li>Transmission tags are used to link actuators to joints. </li>
<li>If the transmission tags the joints won’t move in Gazebo and they will be considered as stationary objects.</li>
<li>We need to define transmission for every dynamic(moving) joint. </li>
</ul>
<h3 id="reference-15"><a class="header" href="#reference-15">Reference</a></h3>
<ol>
<li><a href="http://gazebosim.org/tutorials/?tut=ros_control#Aboutros_control">Gazebo tutorials: ROS Control</a></li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h1>
<ol>
<li>
<p>Make sure you have the gazebo and RViz installed with ros-noetic. Run <code>roscore</code> in a separate terminal. Then,</p>
<p>Run this command to load RViz:</p>
<pre><code class="language-bash">rosrun rviz rviz
</code></pre>
<p>Run this command to load the gazebo simulator:</p>
<pre><code class="language-bash">rosrun gazebo_ros gazebo
</code></pre>
<p>If RViz and the Gazebo simulator are successfully installed, you’ll see the following result:</p>
<p><code>RViz</code></p>
<p><img src="ROS_with_Gazebo/rviz.png" alt="RViz" /></p>
<p><code>Gazebo Simulator</code></p>
<p><img src="ROS_with_Gazebo/gazebo.png" alt="Gazebo" /></p>
<blockquote>
<p><strong>Note</strong>: You can install any ROS package by running this command in terminal: <code>sudo apt install ros-noetic-&lt;package-name&gt;</code>.</p>
</blockquote>
</li>
<li>
<p>Let’s create another ROS package where we’ll keep all the gazebo tutorials related files.</p>
<ul>
<li>
<p>Go to the <code>src</code> folder of <code>workspace</code> where ROS packages are located.</p>
<pre><code class="language-bash">cd ~/workspace/src
</code></pre>
</li>
<li>
<p>Create a ROS package with following dependencies.</p>
<pre><code class="language-bash">catkin_create_pkg pkg_gazebo roscpp geometry_msgs std_msgs gazebo_ros gazebo_dev tf tf2 dynamic_reconfigure rviz
</code></pre>
</li>
<li>
<p>Create directories where we’ll save worlds.</p>
<pre><code class="language-bash">cd pkg_gazebo
mkdir config scripts worlds lib models launch
</code></pre>
</li>
</ul>
</li>
<li>
<p>Open <code>package.xml</code>, and make sure these two lines are in between <code>export</code> tag and uncommented.</p>
<pre><code class="language-xml">&lt;export&gt;
    &lt;gazebo_ros gazebo_model_path=&quot;${prefix}/models&quot;/&gt;
    &lt;gazebo_ros gazebo_media_path=&quot;${prefix}/models&quot;/&gt;
    &lt;gazebo_ros plugin_path=&quot;$(prefix)/lib&quot;/&gt;
&lt;/export&gt;
</code></pre>
<p>You also have to add <code>message_runtime</code> and <code>message_generation</code>. Now, your <code>package.xml</code> file should look something like this:</p>
<p><code>package.xml</code></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
    &lt;name&gt;pkg_gazebo&lt;/name&gt;
    &lt;version&gt;0.0.0&lt;/version&gt;
    &lt;description&gt;The pkg_gazebo package&lt;/description&gt;

    &lt;maintainer email=&quot;ubuntu@todo.todo&quot;&gt;ubuntu&lt;/maintainer&gt;
    &lt;license&gt;TODO&lt;/license&gt;

    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
    &lt;build_depend&gt;dynamic_reconfigure&lt;/build_depend&gt;
    &lt;build_depend&gt;gazebo_dev&lt;/build_depend&gt;
    &lt;build_depend&gt;gazebo_ros&lt;/build_depend&gt;
    &lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt;
    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
    &lt;build_depend&gt;rviz&lt;/build_depend&gt;
    &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
    &lt;build_depend&gt;tf&lt;/build_depend&gt;
    &lt;build_depend&gt;tf2&lt;/build_depend&gt;
    &lt;build_depend&gt;message_generation&lt;/build_depend&gt;

    &lt;build_export_depend&gt;dynamic_reconfigure&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;gazebo_dev&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;gazebo_ros&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;geometry_msgs&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;rviz&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;tf&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;tf2&lt;/build_export_depend&gt;

    &lt;exec_depend&gt;dynamic_reconfigure&lt;/exec_depend&gt;
    &lt;exec_depend&gt;gazebo_dev&lt;/exec_depend&gt;
    &lt;exec_depend&gt;gazebo_ros&lt;/exec_depend&gt;
    &lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt;
    &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
    &lt;exec_depend&gt;rviz&lt;/exec_depend&gt;
    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
    &lt;exec_depend&gt;tf&lt;/exec_depend&gt;
    &lt;exec_depend&gt;tf2&lt;/exec_depend&gt;
    &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;


    &lt;!-- The export tag contains other, unspecified, tags --&gt;
    &lt;export&gt;
        &lt;!-- Other tools can request additional information be placed here --&gt;
        &lt;gazebo_ros gazebo_model_path=&quot;${prefix}/models&quot;/&gt;
        &lt;gazebo_ros gazebo_media_path=&quot;${prefix}/models&quot;/&gt;
        &lt;gazebo_ros plugin_path=&quot;$(prefix)/lib&quot;/&gt;

    &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<center><a href="ROS_with_Gazebo/package.xml" download><button>Download</button></a></center>
<p><code>CMakeLists.txt</code></p>
<pre><code class="language-txt">cmake_minimum_required(VERSION 3.0.2)
project(pkg_gazebo)

add_compile_options(-std=c++11)

find_package(catkin REQUIRED COMPONENTS
message_generation
gazebo_msgs
nav_msgs
std_srvs
dynamic_reconfigure
gazebo_dev
gazebo_ros
geometry_msgs
roscpp
rviz
std_msgs
tf
tf2
tf2_ros
)

find_package(gazebo REQUIRED)
include_directories(include ${GAZEBO_INCLUDE_DIRS})

find_package(Boost REQUIRED COMPONENTS thread)
include_directories(${Boost_INCLUDE_DIRS})

################################################
## Declare ROS messages, services and actions ##
################################################

## Generate messages in the 'msg' folder
# add_message_files(
#   FILES
#   Message1.msg
#   Message2.msg
# )

## Generate services in the 'srv' folder
# add_service_files(
#   FILES
#   Service1.srv
#   Service2.srv
# )

## Generate actions in the 'action' folder
# add_action_files(
#   FILES
#   Action1.action
#   Action2.action
# )

## Generate added messages and services with any dependencies listed here
# generate_messages(
#   DEPENDENCIES
#   geometry_msgs#   std_msgs
# )

################################################
## Declare ROS dynamic reconfigure parameters ##
################################################

## Generate dynamic reconfigure parameters in the 'cfg' folder
# generate_dynamic_reconfigure_options(
#   cfg/DynReconf1.cfg
#   cfg/DynReconf2.cfg
# )

###################################
## catkin specific configuration ##
###################################

catkin_package(
INCLUDE_DIRS include
LIBRARIES pkg_gazebo
CATKIN_DEPENDS dynamic_reconfigure gazebo_dev gazebo_ros geometry_msgs roscpp rviz std_msgs tf tf2
DEPENDS system_lib
)

###########
## Build ##
###########

include_directories(
# include
${catkin_INCLUDE_DIRS}
)

## Declare a C++ library
# add_library(${PROJECT_NAME}
#   src/${PROJECT_NAME}/pkg_gazebo.cpp
# )

#############
## Install ##
#############

#############
## Testing ##
#############
</code></pre>
<center><a href="ROS_with_Gazebo/CMakeLists.txt" download><button>Download</button></a></center>
</li>
<li>
<p>Let’s build the package now.</p>
<pre><code class="language-bash">cd ~/workspace
catkin_make
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>Hint</strong>: Run this command to see if you’ve successfully build the package. <code>rospack find &lt;package-name&gt;</code>. To get more help about how to create a package look into this section: <a href="ROS_with_Gazebo/../ROS_Basics_with_Turtlesim/ROS_Package/create_a_ros_package.html#create-a-ros-package">Create a ROS package</a>.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="gazebo-simulator-1"><a class="header" href="#gazebo-simulator-1">Gazebo Simulator</a></h1>
<p>Gazebo is a 3D dynamic simulator with the ability to accurately and efficiently simulate populations of robots in complex indoor and outdoor environments. While similar to game engines, Gazebo offers physics simulation at a much higher degree of fidelity, a suite of sensors, and interfaces for both users and programs.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p>multiple physics engines,</p>
</li>
<li>
<p>a rich library of robot models and environments,</p>
</li>
<li>
<p>a wide variety of sensors,</p>
</li>
<li>
<p>convenient programmatic and graphical interfaces</p>
</li>
</ul>
<h2 id="understanding-the-gui"><a class="header" href="#understanding-the-gui">Understanding the GUI</a></h2>
<p>To get a brief overview of the GUI of gazebo, open this <a href="http://gazebosim.org/tutorials?cat=guided_b&amp;tut=guided_b2">link</a>.</p>
<h2 id="adding-models-to-simulator"><a class="header" href="#adding-models-to-simulator">Adding models to Simulator</a></h2>
<ol>
<li>
<p>Let’s first open a gazebo simulator environment.</p>
<pre><code class="language-bash">roslaunch gazebo_ros empty_world.launch 
</code></pre>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/../gazebo.png" alt="Gazebo" /></p>
</li>
<li>
<p>You can add primitive shapes like cube, sphere and sphere from upper toolbar.</p>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/sphere.png" alt="Sphere" /></p>
</li>
<li>
<p>You can also add some other models by going to <code>Insert</code> on the left panel. Let’s try adding <code>Ambulance</code> to the scene which is under <code>http://models.gazebosim.org/</code>. <em>It can take some time to download and load.</em></p>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/ambulance.png" alt="Ambulance" /></p>
</li>
<li>
<p>You can also add some other custom models saved on you hard disk by adding path.</p>
</li>
</ol>
<h2 id="applying-forcetorque-to-a-model"><a class="header" href="#applying-forcetorque-to-a-model">Applying force/torque to a model</a></h2>
<p>First, select sphere. Right-click on it and select apply force/torque. Fill in the details as shown below.</p>
<center>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/apply_force.png" alt="Applying force" /></p>
</center>
<blockquote>
<p><strong>Note</strong>: Don’t forget to click on play button to start the simulation.</p>
</blockquote>
<p>Now click on apply force. You can see the force being applied. Notice that the force is applied for <strong>1ms</strong>, so we’ve provided such high force for such a small ball to increase the impulse.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-knock-down-the-bowling-pin"><a class="header" href="#example-knock-down-the-bowling-pin">Example: Knock down the bowling pin</a></h1>
<p><strong>Goal</strong>: Using a sphere knock down the bowling pin spawned in bowling game.</p>
<h2 id="1-prerequisites"><a class="header" href="#1-prerequisites">1 Prerequisites</a></h2>
<ol>
<li>
<p>A package <code>ros_gazebo</code> as per the instructions in <a href="ROS_with_Gazebo/Gazebo_Simulator/../installation.html#Installation%20Guide">Installation Guide</a>.</p>
</li>
<li>
<p>Add these models and textures to <code>pkg_gazebo</code> =&gt; <a href="ROS_with_Gazebo/Gazebo_Simulator/gazebo_resources.zip" download><button>Download Resources</button></a></p>
</li>
</ol>
<br/>
<h2 id="tasks-4"><a class="header" href="#tasks-4">Tasks</a></h2>
<br/>
<h3 id="2-create-a-launch-file"><a class="header" href="#2-create-a-launch-file">2 Create a launch file</a></h3>
<ul>
<li>Let’s create a launch to load bowling game in gazebo simulator.</li>
</ul>
<p><code>bowling_game_one_pin.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
	&lt;arg name=&quot;static&quot; default=&quot;&quot;/&gt;
        &lt;include 
            file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;
            &lt;arg name=&quot;world_name&quot;  value=&quot;$(find pkg_gazebo)/worlds/bowling_game_one$(arg static).world&quot;/&gt;
        &lt;/include&gt;
&lt;/launch&gt;
</code></pre>
<br/>
<h3 id="3-launch-the-bowling-game"><a class="header" href="#3-launch-the-bowling-game">3 Launch the bowling game</a></h3>
<pre><code class="language-bash">roslaunch pkg_gazebo bowling_game_one_pin.launch 
</code></pre>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/bowling_game_one.png" alt="Bowling Game One pin" /></p>
<br/>
<h3 id="spawn-a-sphere-on-the-bowling-track"><a class="header" href="#spawn-a-sphere-on-the-bowling-track">Spawn a sphere on the bowling track</a></h3>
<ul>
<li>Click on sphere on the top toolbar.</li>
<li>Click on the bowling alley to spawn sphere there as shown in the image below. </li>
</ul>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/sphere_spawn.png" alt="Sphere spawn" /></p>
<blockquote>
<p><strong>Hint</strong>: You can always move the sphere using the Transition Tool or by selecting the sphere and pressing T.</p>
</blockquote>
<br/>
<h3 id="4-knock-the-bowling-pin-using-sphere"><a class="header" href="#4-knock-the-bowling-pin-using-sphere">4 Knock the bowling pin using sphere</a></h3>
<ul>
<li>
<p>Click on sphere to select it.</p>
</li>
<li>
<p>Right-click on it and select <strong>Apply Force/Torque</strong>.</p>
</li>
<li>
<p>Apply a force of <code>10000 N</code> in y-direction. Remember this force is applied for <em>1ms</em>. So, the impulse is 10 N-s.</p>
<p><img src="ROS_with_Gazebo/Gazebo_Simulator/apply_force.png" alt="Apply Force" /></p>
</li>
<li>
<p>Click to Apply Force to start the simulation. (<em>Don’t forget to unpause the simulation.</em>)</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: If you want to try this again, go to <code>Edit &gt; Reset World</code> or press <code>Ctrl+R</code>.</p>
</blockquote>
<br/>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>You’ve learnt how to load a world in gazebo simulator using launch files. Also, you’ve successfully used gazebo simulator tools to knock down the bowling pin.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="rviz-1"><a class="header" href="#rviz-1">RViz</a></h1>
<br/>
<ul>
<li>
<p>RViz is short for <code>ROS Visualization</code>.</p>
</li>
<li>
<p>It is a 3D visualization software tool for robots, sensors, and algorithms.</p>
</li>
<li>
<p>It enables you to see the robot’s perception of its world (real or simulated).</p>
</li>
<li>
<p>The purpose of rviz is to enable you to visualize the state of a robot. It uses sensor data to try to create an accurate depiction of what is going on in the robot’s environment.</p>
</li>
</ul>
<br/>
<p>To launch rviz, type the following command in your terminal:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in a different terminal tab, type:</p>
<pre><code class="language-bash">rosrun rviz rviz
</code></pre>
<p>Here is the screen you should see when you launch rviz:</p>
<p><img src="ROS_with_Gazebo/rviz.png" alt="RViz" /></p>
<p>The left panel is the Displays panel. It has a list of plugins. These plugins enable you to view sensor data and robot state information. To add a plugin, you would click the Add button on the bottom left of the window.</p>
<h2 id="difference-between-rviz-and-gazebo"><a class="header" href="#difference-between-rviz-and-gazebo">Difference between RViz and Gazebo</a></h2>
<p>The difference between the two can be summed up in the following excerpt from Morgan Quigley (one of the original developers of ROS) in his book <em>Programming Robots with ROS</em>:</p>
<p>“rviz shows you what the robot thinks is happening, while Gazebo shows you what is really happening.”</p>
<ul>
<li>
<p><code>gazebo</code> shows the simulated environment in which a robot is placed.</p>
</li>
<li>
<p><code>rviz</code> shows the same environment through the eyes of a robot with the help of sensors.</p>
</li>
</ul>
<br/>
<blockquote>
<p><strong>Note</strong>: To get more familiar with the RViz tool, check out the tutorial videos in this <a href="http://wiki.ros.org/rviz/Tutorials">link</a>.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="urdf-1"><a class="header" href="#urdf-1">URDF</a></h1>
<h2 id="what-is-a-urdf-model"><a class="header" href="#what-is-a-urdf-model">What is a URDF Model?</a></h2>
<p>The URDF (Universal Robot Description Format) model is a collection of files that describe a robot’s physical description to ROS. These files are used by ROS to tell the computer what the robot actually looks like in real life. URDF files are needed in order for ROS to understand and be able to simulate situations with the robot before a researcher or engineer actually acquires the robot. You can learn more about URDF files and packages on <a href="http://wiki.ros.org/urdf">wiki.ROS.org</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-visula-robot-model-with-urdf"><a class="header" href="#building-a-visula-robot-model-with-urdf">Building A visula robot model with URDF</a></h1>
<p>In this tutorial, we’re going to build a visual model of a robot that vaguely looks like a car. In later tutorials we will learn how to add physical properties to our model, generate neater code with xacro and make it move in Gazebo. But for now, we’re going to focus on getting the visual geometry correct.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Lets make a package called myrobot_description which will depend on URDF. Go to your workspace <code>src</code> folder and run.</p>
<pre><code class="language-bash">cd workspace/src
catkin_create_pkg myrobot_description urdf
</code></pre>
<p>After that make a directory called <code>urdf</code> and in it create a file called <code>myrobot.urdf</code>. Now we are ready to make our robot.</p>
<h2 id="1-one-simple-shape"><a class="header" href="#1-one-simple-shape">1. One Simple Shape</a></h2>
<p>First, we’re just going to explore one simple shape. Here’s about as simple as a urdf as you can make. Open the <code>myrobot.urdf</code> file in your text editor and copy paste the following:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot;&gt;
	  &lt;link name=&quot;base_link&quot;&gt;
      &lt;visual&gt;
          &lt;geometry&gt;
              &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
          &lt;/geometry&gt;
       &lt;/visual&gt;
  &lt;/link&gt;
&lt;/robot&gt;
</code></pre>
<p>To translate the XML into English, this is a robot with the name myfirst, that contains only one link (a.k.a. part), whose visual component is just a box 0.8 meters wide, 1.8 meters long and 0.6 meter height.</p>
<p>To examine the model in rviz we need to do the following:</p>
<ol>
<li>Create a <code>launch</code> directory in your package and create a file called <code>display.launch</code> and paste the following in it:</li>
</ol>
<pre><code class="language-xml">&lt;launch&gt;
	&lt;!-- arguments that can be given during executing the launch file --&gt;
	&lt;!-- stores the path to your urdf file in model argument --&gt;
	&lt;arg name=&quot;model&quot; default=&quot;$(find myrobot_description)/urdf/myrobot.urdf&quot;/&gt;
	&lt;arg name=&quot;gui&quot; default=&quot;true&quot; /&gt;
	&lt;!-- stores the path to your rviz configuration file --&gt;
	&lt;arg name=&quot;rvizconfig&quot; default=&quot;$(find myrobot_description)/rviz/config.rviz&quot; /&gt;

	&lt;!-- This parameter loads the urdf file we have created --&gt;
	&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(arg model)&quot; /&gt;

	&lt;!-- this simply loads the joint state publisher to know more about that vist: (http://wiki.ros.org/joint_state_publisher) --&gt;
	&lt;node if=&quot;$(arg gui)&quot; name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; /&gt;
	&lt;node unless=&quot;$(arg gui)&quot; name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;
	&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;
	&lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(arg rvizconfig)&quot; required=&quot;true&quot; /&gt;

&lt;/launch&gt;
</code></pre>
<ol start="2">
<li>As you can see in the above code we are also loading a file called <code>config.rviz</code> which is a configuration file for rviz so lets just do that. Make a directory called <code>rviz</code> in your package and copy the following file in it.</li>
</ol>
<center>config.rviz</center>
  <center><a href="ROS_with_Gazebo/URDF/./config.rviz" download><button>Download</button></a></center>
<ol start="3">
<li>Now run build your package and run the launch file.</li>
</ol>
<pre><code class="language-bash">cd workspace
catkin_make
roslaunch myrobot_description display.launch
</code></pre>
<p>You should be able to see the following:
<img src="ROS_with_Gazebo/URDF/./simple_shape.png" alt="image" /></p>
<h2 id="2-multiple-shapes"><a class="header" href="#2-multiple-shapes">2. Multiple Shapes</a></h2>
<p>Now let’s look at how to add multiple shapes/links. If we just add more link elements to the urdf, the parser won’t know where to put them. So, we have to add joints. Joint elements can refer to both flexible and inflexible joints. We’ll start with inflexible, or fixed joints.</p>
<pre><code class="language-xml">&lt;link name=&quot;right_front_wheel&quot;&gt;
    &lt;visual&gt;
        &lt;geometry&gt;
            &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/visual&gt;
&lt;/link&gt;
&lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;fixed&quot;&gt;
    &lt;parent link=&quot;base_link&quot;/&gt;
    &lt;child link=&quot;right_front_wheel&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<ul>
<li>
<p>note how we have defined a cylinder with length 0.2 and radius 0.3</p>
</li>
<li>
<p>The joint is defined in terms of a parent and a child. URDF is ultimately a tree structure with one root link. This means that the wheel’s position is dependent on the base_link’s position.</p>
</li>
</ul>
<h2 id="3-origins"><a class="header" href="#3-origins">3. Origins</a></h2>
<p>we need to specify the position of the wheels and also the orientation for that we will use the origin tag:</p>
<pre><code class="language-bash">&lt;link name=&quot;right_front_wheel&quot;&gt;
    &lt;visual&gt;
        &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
        &lt;geometry&gt;
            &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/visual&gt;
&lt;/link&gt;
&lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;fixed&quot;&gt;
    &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
    &lt;parent link=&quot;base_link&quot;/&gt;
    &lt;child link=&quot;right_front_wheel&quot;/&gt;
    &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 0.5 0.3&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<ul>
<li>This will rotate the cylinder and fix its position on the base_link.</li>
</ul>
<h2 id="4-adding-material-and-finishing-the-model"><a class="header" href="#4-adding-material-and-finishing-the-model">4. Adding Material And Finishing The Model</a></h2>
<p>The material tag allows us to define the color of our links. Ex:</p>
<pre><code class="language-xml">&lt;material name=&quot;blue&quot;&gt;
    &lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;
&lt;/material&gt;
</code></pre>
<p>Now lets finish the model with all four wheels and their materials. The complete urdf file should look like this:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot;&gt;
    
    &lt;material name=&quot;blue&quot;&gt;
        &lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;white&quot;&gt;
        &lt;color rgba=&quot;1 1 1 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;black&quot;&gt;
        &lt;color rgba=&quot;0 0 0 1&quot;/&gt;
    &lt;/material&gt;


    &lt;link name=&quot;base_link&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;blue&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;link name=&quot;right_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;fixed&quot;&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_front_wheel_joint&quot; type=&quot;fixed&quot;&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;right_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_back_wheel_joint&quot; type=&quot;fixed&quot;&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_back_wheel_joint&quot; type=&quot;fixed&quot;&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;
&lt;/robot&gt;

</code></pre>
<p>now lets see our robot.</p>
<pre><code class="language-bash">roslaunch urdf_tutorial display.launch
</code></pre>
<p><img src="ROS_with_Gazebo/URDF/./robot_model.png" alt="image" /></p>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-movable-robot-model-with-urdf"><a class="header" href="#building-a-movable-robot-model-with-urdf">Building a Movable Robot Model with URDF</a></h1>
<p>In this tutorial, we’re going to revise the model we made in the previous tutorial so that it has movable joints.</p>
<p>Below is the new urdf with flexible joints. You can compare it to the previous version to see everything that has changed.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot;&gt;
    
    &lt;material name=&quot;blue&quot;&gt;
        &lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;white&quot;&gt;
        &lt;color rgba=&quot;1 1 1 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;black&quot;&gt;
        &lt;color rgba=&quot;0 0 0 1&quot;/&gt;
    &lt;/material&gt;


    &lt;link name=&quot;base_link&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;blue&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;link name=&quot;right_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_front_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;right_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_back_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_back_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;
&lt;/robot&gt;

</code></pre>
<p>Lets take look at the <code>right_front_wheel_joint</code>:</p>
<pre><code class="language-xml">&lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;continuous&quot;&gt;
    &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
    &lt;parent link=&quot;base_link&quot;/&gt;
    &lt;child link=&quot;right_front_wheel&quot;/&gt;
    &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 0.5 0.3&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<p>the connection between the wheel and the body is a continuous joint, meaning that it can take on any angle from negative infinity to positive infinity, so that they can roll in both directions forever.</p>
<p>The only additional information we have to add is the axis of rotation, here specified by an xyz triplet, which specifies a vector around which the head will rotate. Since we want it to go around the X axis we specify the vector “1 0 0”.</p>
<p>To visualize and control this model, run the same command as the last tutorial:</p>
<pre><code class="language-bash">roslaunch urdf_tutorial display.launch
</code></pre>
<p>However now this will also pop up a GUI that allows you to control the values of all the non-fixed joints. Play with the model some and see how it moves.</p>
<h2 id="other-types-of-joints"><a class="header" href="#other-types-of-joints">Other Types of Joints</a></h2>
<p>There are other kinds of joints that move around in space. Whereas the prismatic joint can only move along one dimension, a planar joint can move around in a plane, or two dimensions, a revolute joint rotate in the same way that the continuous joints do, but they have strict limits. Hence, we must include the limit tag specifying the upper and lower limits of the joint (in radians). We also must specify a maximum velocity and effort for this joint but the actual values don’t matter for our purposes here. Furthermore, a floating joint is unconstrained, and can move around in any of the three dimensions.</p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="adding-physical-and-collision-properties-to-a-urdf-model"><a class="header" href="#adding-physical-and-collision-properties-to-a-urdf-model">Adding Physical and Collision Properties to a URDF Model</a></h1>
<p>In this tutorial, we’ll look at how to add some basic physical properties to your URDF model and how to specify its collision properties.</p>
<h2 id="1-collision"><a class="header" href="#1-collision">1. Collision</a></h2>
<p>So far, we’ve only specified our links with a single sub-element, visual, which defines what the robot looks like. However, in order to get collision detection to work or to simulate the robot in something like Gazebo, we need to define a collision element as well.</p>
<p>Here is the code for our new base link. </p>
<pre><code class="language-xml">&lt;link name=&quot;base_link&quot;&gt;
    &lt;visual&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
        &lt;material name=&quot;blue&quot;/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
&lt;/link&gt;
</code></pre>
<ul>
<li>The collision element is a direct subelement of the link object, at the same level as the visual tag </li>
<li>The collision element defines its shape the same way the visual element does, with a geometry tag. The format for the geometry tag is exactly the same here as with the visual.</li>
<li>You can also specify an origin in the same way as a subelement of the collision tag (as with the visual) </li>
</ul>
<p>In many cases, you’ll want the collision geometry and origin to be exactly the same as the visual geometry and origin. However, there are two main cases where you wouldn’t. </p>
<ul>
<li>Quicker Processing - Doing collision detection for two meshes is a lot more computational complex than for two simple geometries. Hence, you may want to replace the meshes with simpler geometries in the collision element. </li>
<li>Safe Zones - You may want to restrict movement close to sensitive equipment. For instance, if we didn’t want anything to collide with R2D2’s head, we might define the collision geometry to be a cylinder encasing his head to prevent anything from getting to near his head.</li>
</ul>
<h2 id="2-physical-properties"><a class="header" href="#2-physical-properties">2. Physical Properties</a></h2>
<p>In order to get your model to simulate properly, you need to define several physical properties of your robot, i.e. the properties that a physics engine like Gazebo would need.</p>
<h3 id="21-inertia"><a class="header" href="#21-inertia">2.1 Inertia</a></h3>
<p>Every link element being simulated needs an inertial tag. Here is a simple one.</p>
<pre><code class="language-xml">&lt;link name=&quot;base_link&quot;&gt;
    &lt;visual&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
        &lt;material name=&quot;blue&quot;/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
        &lt;mass value=&quot;10&quot;/&gt;
        &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
    &lt;/inertial&gt;
&lt;/link&gt;
</code></pre>
<ul>
<li>This element is also a subelement of the link object. </li>
<li>The mass is defined in kilograms. </li>
<li>The 3x3 rotational inertia matrix is specified with the inertia element. Since this is symmetrical, it can be represented by only 6 elements, as such.</li>
</ul>
<p><strong>ixx</strong> <strong>ixy</strong> <strong>ixz</strong></p>
<p>ixy <strong>iyy</strong> <strong>iyz</strong></p>
<p>ixz iyz <strong>izz</strong></p>
<ul>
<li>This information can be provided to you by modeling programs such as MeshLab. The inertia of geometric primitives (cylinder, box, sphere) can be computed using Wikipedia’s <a href="https://en.wikipedia.org/wiki/List_of_moments_of_inertia#List_of_3D_inertia_tensors">list of moment of inertia tensors</a>.</li>
<li>The inertia tensor depends on both the mass and the distribution of mass of the object. A good first approximation is to assume equal distribution of mass in the volume of the object and compute the inertia tensor based on the object’s shape.</li>
<li>If unsure what to put, a matrix with ixx/iyy/izz=1e-3 or smaller is often a reasonable default for a mid-sized link (it corresponds to a box of 0.1 m side length with a mass of 0.6 kg). Although often chosen, the identity matrix is a particularly bad default, since it is often much too high (it corresponds to a box of 0.1 m side length with a mass of 600 kg!).</li>
<li>You can also specify an origin tag to specify the center of gravity and the inertial reference frame (relative to the link’s reference frame).</li>
<li>When using realtime controllers, inertia elements of zero (or almost zero) can cause the robot model to collapse without warning, and all links will appear with their origins coinciding with the world origin.</li>
</ul>
<h3 id="22-contact-coefficients"><a class="header" href="#22-contact-coefficients">2.2 Contact Coefficients</a></h3>
<p>You can also define how the links behave when they are in contact with one another. This is done with a subelement of the collision tag called contact_coefficients. There are three attributes to specify:</p>
<ul>
<li>mu - <a href="https://simple.wikipedia.org/wiki/Coefficient_of_friction">Friction coefficient</a></li>
<li>kp - <a href="https://en.wikipedia.org/wiki/Stiffness">Stiffness coefficient</a></li>
<li>kd - <a href="https://en.wikipedia.org/wiki/Damping_ratio#Definition">Dampening coefficient</a></li>
</ul>
<h3 id="23-joint-dynamics"><a class="header" href="#23-joint-dynamics">2.3 Joint Dynamics</a></h3>
<p>How the joint moves is defined by the dynamics tag for the joint. There are two attributes here:</p>
<ul>
<li>friction - The physical static friction. For prismatic joints, the units are Newtons. For revolving joints, the units are Newton meters.</li>
<li>damping - The physical damping value. For prismatic joints, the units are Newton seconds per meter. For revolving joints, Newton meter secons per radian.</li>
</ul>
<p>If not specified, these coefficients default to zero. </p>
<h2 id="3-other-tags"><a class="header" href="#3-other-tags">3. Other Tags</a></h2>
<p>In the realm of pure URDF (i.e. excluding Gazebo-specific tags), there are two remaining tags to help define the joints: calibration and safety controller. Check out the <a href="http://wiki.ros.org/urdf/XML/joint">spec</a>, as they are not included in this tutorial.</p>
<h2 id="final-urdf-file"><a class="header" href="#final-urdf-file">Final urdf file</a></h2>
<p>This is the final URDF file with collision and physical properties.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot;&gt;
    
    &lt;material name=&quot;blue&quot;&gt;
        &lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;white&quot;&gt;
        &lt;color rgba=&quot;1 1 1 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;black&quot;&gt;
        &lt;color rgba=&quot;0 0 0 1&quot;/&gt;
    &lt;/material&gt;


    &lt;link name=&quot;base_link&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;blue&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;10&quot;/&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
        &lt;/inertial&gt;
    &lt;/link&gt;

    &lt;link name=&quot;right_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;1&quot;/&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
        &lt;/inertial&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_front_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_front_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;1&quot;/&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
        &lt;/inertial&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_front_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_front_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;right_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;1&quot;/&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
        &lt;/inertial&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;right_back_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;right_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;

    &lt;link name=&quot;left_back_wheel&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 1.57075 0&quot; xyz=&quot;0 0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;cylinder length=&quot;0.2&quot; radius=&quot;0.3&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;1&quot;/&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;
        &lt;/inertial&gt;
    &lt;/link&gt;
    &lt;joint name=&quot;left_back_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;axis rpy=&quot;0 0 0&quot; xyz=&quot;1 0 0&quot;/&gt;
        &lt;parent link=&quot;base_link&quot;/&gt;
        &lt;child link=&quot;left_back_wheel&quot;/&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;-0.4 -0.5 0.3&quot;/&gt;
    &lt;/joint&gt;
&lt;/robot&gt;

</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="difference-between-urdf-and-sdf"><a class="header" href="#difference-between-urdf-and-sdf">Difference between URDF and SDF</a></h1>
<h2 id="what-is-urdf"><a class="header" href="#what-is-urdf">What is URDF</a></h2>
<p>The URDF (Universal Robot Description Format) model is a collection of files that describe a robot’s physical description to ROS. These files are used by a program called ROS (Robot Operating System) to tell the computer what the robot actually looks like in real life.</p>
<h2 id="what-is-sdf"><a class="header" href="#what-is-sdf">What is SDF</a></h2>
<p>SDFormat (Simulation Description Format), sometimes abbreviated as SDF, is an XML format that describes objects and environments for robot simulators, visualization, and control. Originally developed as part of the Gazebo robot simulator, SDFormat was designed with scientific robot applications in mind.</p>
<h2 id="what-is-the-difference"><a class="header" href="#what-is-the-difference">what is the difference</a></h2>
<p>URDF specifies a robot, but SDF also specifies a world for the robot to live in, which is a much larger set of things. Based on this premise, SDF is designed to represent a superset of everything that can be represented in URDF. URDF is the established format for describing robot structure in ROS. URDF could not specify information necessary for other robotics domains. SDF was devised by Gazebo to meet simulation needs, but Gazebo can consume URDF when it is augmented by information within <code>&lt;gazebo&gt;</code> tags.</p>
<p>You can learn more about why sdf was developed for gazebo <a href="http://gazebosim.org/tutorials?tut=ros_urdf">here</a>.</p>
<h3 id="reference-16"><a class="header" href="#reference-16">Reference</a></h3>
<ul>
<li><a href="https://newscrewdriver.com/2018/07/31/ros-notes-urdf-vs-gazebo-sdf/">URDF vs. Gazebo SDF</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xacro-1"><a class="header" href="#xacro-1">XACRO</a></h1>
<p>Xacro is an XML macro language</p>
<p>With Xacro, you can construct shorter and more readable XML files by using macros that expand to larger XML expressions. Documentation can be found in the wiki: <a href="http://wiki.ros.org/xacro">ROS Wiki</a></p>
<p>The xacro program runs all of the macros and outputs the result. Typical usage looks something like this:</p>
<pre><code class="language-xml">xacro --inorder model.xacro &gt; model.urdf
</code></pre>
<p>On ROS distros melodic and later, you should omit the {–inorder} argument.</p>
<p>You can also automatically generate the urdf in a launch file. This is convenient because it stays up to date and doesn’t use up hard drive space. However, it does take time to generate, so be aware that your launch file might take longer to start up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-xacro-to-clean-up-a-urdf-file"><a class="header" href="#using-xacro-to-clean-up-a-urdf-file">Using Xacro to Clean Up a URDF File</a></h1>
<p>By now, if you’re following all these steps at home with your own robot design, you might be sick of doing all sorts of math to get very simple robot descriptions to parse correctly. Fortunately, you can use the <a href="http://wiki.ros.org/xacro">xacro</a> package to make your life simpler. It does three things that are very helpful.</p>
<ul>
<li>Constants</li>
<li>Simple Math</li>
<li>Macros </li>
</ul>
<p>In this tutorial, we take a look at all these shortcuts to help reduce the overall size of the URDF file and make it easier to read and maintain.</p>
<h2 id="1-using-xacro"><a class="header" href="#1-using-xacro">1. Using Xacro</a></h2>
<p>At the top of the URDF file, you must specify a namespace in order for the file to parse properly. For example, these are the first two lines of a valid xacro file:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot; xmlns:xacro=&quot;http://ros.org/wiki/xacro&quot;&gt;
</code></pre>
<h2 id="2-constants"><a class="header" href="#2-constants">2. Constants</a></h2>
<p>Let’s take a quick look at our base_link</p>
<pre><code class="language-xml">&lt;link name=&quot;base_link&quot;&gt;
    &lt;visual&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
        &lt;material name=&quot;blue&quot;/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;0.8 1.8 0.6&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
&lt;/link&gt;
</code></pre>
<p>The information here is a little redundant. We specify the length and breadth and height of the box twice. Worse, if we want to change that, we need to do so in two different places.</p>
<p>Fortunately, xacro allows you to specify properties which act as constants. Instead, of the above code, we can write this.</p>
<pre><code class="language-xml">&lt;xacro:property name=&quot;width&quot; value=&quot;0.8&quot; /&gt;
&lt;xacro:property name=&quot;bodylen&quot; value=&quot;1.8&quot; /&gt;
&lt;xacro:property name=&quot;height&quot; value=&quot;0.6&quot; /&gt;

&lt;link name=&quot;base_link&quot;&gt;
    &lt;visual&gt;
        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;${width} ${bodylen} ${height}&quot;/&gt;
        &lt;/geometry&gt;
        &lt;material name=&quot;blue&quot;/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;box size=&quot;${width} ${bodylen} ${height}&quot;/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
&lt;/link&gt;
</code></pre>
<ul>
<li>The values are specified in the first three lines. They can be defined just about anywhere (assuming valid XML), at any level, before or after they are used. Usually they go at the top.</li>
<li>Instead of specifying the actual width in the geometry element, we use a dollar sign and curly brackets to signify the value.</li>
</ul>
<p>The value of the contents of the ${} construct are then used to replace the ${}. This means you can combine it with other text in the attribute.</p>
<p>For example: </p>
<pre><code class="language-xml">&lt;xacro:property name=&quot;robotname&quot; value=&quot;marvin&quot; /&gt;
&lt;link name=&quot;${robotname}s_leg&quot; /&gt;
</code></pre>
<p>This will generate</p>
<pre><code class="language-xml">&lt;link name=&quot;marvins_leg&quot; /&gt;
</code></pre>
<p>However, the contents in the ${} don’t have to only be a property, which brings us to our next point… </p>
<h2 id="3-math"><a class="header" href="#3-math">3. Math</a></h2>
<p>You can build up arbitrarily complex expressions in the ${} construct using the four basic operations, the unary minus, and parenthesis. Examples:</p>
<pre><code class="language-xml">&lt;cylinder radius=&quot;${wheeldiam/2}&quot; length=&quot;0.1&quot;/&gt;
&lt;origin xyz=&quot;${reflect*(width+.02)} 0 0.25&quot; /&gt;
</code></pre>
<p>All of the math is done using floats, hence</p>
<pre><code class="language-xml">&lt;link name=&quot;${5/6}&quot;/&gt;
</code></pre>
<p>evaluates to</p>
<pre><code class="language-bash">&lt;link name=&quot;0.833333333333&quot;/&gt;
</code></pre>
<p>In <a href="http://wiki.ros.org/xacro#Math_expressions">Jade</a> and later distros, you can use more than the basic operations listed above, notably sin and cos.</p>
<h2 id="4-macros"><a class="header" href="#4-macros">4. Macros</a></h2>
<p>Here’s the biggest and most useful component to the xacro package.</p>
<h3 id="41-simple-macro"><a class="header" href="#41-simple-macro">4.1 Simple Macro</a></h3>
<p>Let’s take a look at a simple useless macro.</p>
<pre><code class="language-xml">&lt;xacro:macro name=&quot;default_origin&quot;&gt;
	&lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot;/&gt;
&lt;/xacro:macro&gt;
&lt;xacro:default_origin /&gt;
</code></pre>
<p>(This is useless, since if the origin is not specified, it has the same value as this.) This code will generate the following. </p>
<pre><code class="language-xml">&lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0&quot;/&gt;
</code></pre>
<ul>
<li>The name is not technically a required element, but you need to specify it to be able to use it.</li>
<li>Every instance of the <code>&lt;xacro:$NAME /&gt;</code> is replaced with the contents of the xacro:macro tag.</li>
<li>If the xacro with a specified name is not found, it will not be expanded and will NOT generate an error.</li>
</ul>
<h3 id="42-parameterized-macro"><a class="header" href="#42-parameterized-macro">4.2 Parameterized Macro</a></h3>
<p>You can also parameterize macros so that they don’t generate the same exact text every time. When combined with the math functionality, this is even more powerful.</p>
<p>First, let’s take an example of a simple macro we will use in our model.</p>
<pre><code class="language-xml">&lt;xacro:macro name=&quot;default_inertial&quot; params=&quot;mass&quot;&gt;
	&lt;inertial&gt;
		&lt;mass value=&quot;${mass}&quot; /&gt;
		&lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot; /&gt;
	&lt;/inertial&gt;
&lt;/xacro:macro&gt;
</code></pre>
<p>This can be used with the code </p>
<pre><code class="language-xml">&lt;xacro:default_inertial mass=&quot;10&quot;/&gt;
</code></pre>
<p>The parameters act just like properties, and you can use them in expressions</p>
<p>You can also use entire blocks as parameters too.</p>
<pre><code class="language-xml">&lt;xacro:macro name=&quot;blue_shape&quot; params=&quot;name *shape&quot;&gt;
	&lt;link name=&quot;${name}&quot;&gt;
 		&lt;visual&gt;
			&lt;geometry&gt;
				&lt;xacro:insert_block name=&quot;shape&quot; /&gt;
			&lt;/geometry&gt;
			&lt;material name=&quot;blue&quot;/&gt;
		&lt;/visual&gt;
		&lt;collision&gt;
			&lt;geometry&gt;
				&lt;xacro:insert_block name=&quot;shape&quot; /&gt;
			&lt;/geometry&gt;
		&lt;/collision&gt;
	&lt;/link&gt;
&lt;/xacro:macro&gt;

&lt;xacro:blue_shape name=&quot;base_link&quot;&gt;
	&lt;cylinder radius=&quot;.42&quot; length=&quot;.01&quot; /&gt;
&lt;/xacro:blue_shape&gt;
</code></pre>
<ul>
<li>To specify a block parameter, include an asterisk before its parameter name.</li>
<li>A block can be inserted using the insert_block command </li>
<li>Insert the block as many times as you wish. </li>
</ul>
<h2 id="5-practical-usage"><a class="header" href="#5-practical-usage">5. Practical Usage</a></h2>
<p>The xacro language is rather flexible in what it allows you to do. This is the macroed version of our urdf model made in previous tutorials simply called <code>macroed.urdf.xacro</code>.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;robot name=&quot;myrobot&quot; xmlns:xacro=&quot;http://ros.org/wiki/xacro&quot;&gt;
    
    &lt;xacro:property name=&quot;width&quot; value=&quot;0.8&quot; /&gt;
    &lt;xacro:property name=&quot;bodylen&quot; value=&quot;1.8&quot; /&gt;
    &lt;xacro:property name=&quot;height&quot; value=&quot;0.6&quot; /&gt;
    &lt;xacro:property name=&quot;wheellen&quot; value=&quot;0.2&quot; /&gt;
    &lt;xacro:property name=&quot;wheeldiam&quot; value=&quot;0.6&quot; /&gt;
    &lt;xacro:property name=&quot;pi&quot; value=&quot;3.1415&quot; /&gt;

    &lt;material name=&quot;blue&quot;&gt;
        &lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;white&quot;&gt;
        &lt;color rgba=&quot;1 1 1 1&quot;/&gt;
    &lt;/material&gt;
    &lt;material name=&quot;black&quot;&gt;
        &lt;color rgba=&quot;0 0 0 1&quot;/&gt;
    &lt;/material&gt;

    &lt;xacro:macro name=&quot;default_inertial&quot; params=&quot;mass&quot;&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;${mass}&quot; /&gt;
            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot; /&gt;
        &lt;/inertial&gt;
    &lt;/xacro:macro&gt;

    &lt;link name=&quot;base_link&quot;&gt;
        &lt;visual&gt;
            &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;0 0 0.5&quot;/&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;${width} ${bodylen} ${height}&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;blue&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;box size=&quot;${width} ${bodylen} ${height}&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;xacro:default_inertial mass=&quot;10&quot;/&gt;
    &lt;/link&gt;

     &lt;xacro:macro name=&quot;wheel&quot; params=&quot;prefix suffix reflect_x reflect_y&quot;&gt;
        &lt;link name=&quot;${prefix}_${suffix}_wheel&quot;&gt;
            &lt;visual&gt;
                &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 ${pi/2} 0&quot; /&gt;
                &lt;geometry&gt;
                    &lt;cylinder radius=&quot;${wheeldiam/2}&quot; length=&quot;${wheellen}&quot;/&gt;
                &lt;/geometry&gt;
                &lt;material name=&quot;black&quot;/&gt;
            &lt;/visual&gt;
            &lt;collision&gt;
                &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 ${pi/2} 0&quot; /&gt;
                &lt;geometry&gt;
                    &lt;cylinder radius=&quot;${wheeldiam/2}&quot; length=&quot;${wheellen}&quot;/&gt;
                &lt;/geometry&gt;
            &lt;/collision&gt;
            &lt;xacro:default_inertial mass=&quot;1&quot;/&gt;
        &lt;/link&gt;
        &lt;joint name=&quot;${prefix}_${suffix}_wheel_joint&quot; type=&quot;continuous&quot;&gt;
            &lt;axis xyz=&quot;1 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;
            &lt;parent link=&quot;base_link&quot;/&gt;
            &lt;child link=&quot;${prefix}_${suffix}_wheel&quot;/&gt;
            &lt;origin xyz=&quot;${reflect_x*width/2} ${reflect_y*bodylen/4} ${wheeldiam/2}&quot; rpy=&quot;0 0 0&quot;/&gt;
        &lt;/joint&gt;
    &lt;/xacro:macro&gt;

    &lt;xacro:wheel prefix=&quot;right&quot; suffix=&quot;front&quot; reflect_x=&quot;1&quot; reflect_y=&quot;1&quot; /&gt;
    &lt;xacro:wheel prefix=&quot;left&quot; suffix=&quot;front&quot; reflect_x=&quot;-1&quot; reflect_y=&quot;1&quot; /&gt;
    &lt;xacro:wheel prefix=&quot;right&quot; suffix=&quot;back&quot; reflect_x=&quot;1&quot; reflect_y=&quot;-1&quot; /&gt;
    &lt;xacro:wheel prefix=&quot;left&quot; suffix=&quot;back&quot; reflect_x=&quot;-1&quot; reflect_y=&quot;-1&quot; /&gt;
&lt;/robot&gt;

</code></pre>
<p>To see the model generated by a xacro file, run the following command:</p>
<p>first make sure you are in your package directory.</p>
<pre><code class="language-bash">roscd myrobot_description
</code></pre>
<p>and then run:</p>
<pre><code class="language-bash">roslaunch myrobot_description display.launch model:=urdf/macroed.urdf.xacro
</code></pre>
<p>This should give the same output as our previous tutorial.</p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="gazebo-plugins-1"><a class="header" href="#gazebo-plugins-1">Gazebo Plugins</a></h1>
<p>Gazebo plugins give your URDF models greater functionality and can tie in ROS messages and service calls for sensor output and motor input. You can use both preexisting plugins and create your own custom plugins that can work with ROS.</p>
<h2 id="plugin-types"><a class="header" href="#plugin-types">Plugin Types</a></h2>
<p>Gazebo supports several plugin types, and all of them can be connected to ROS, but only a few types can be referenced through a URDF file:</p>
<ol>
<li><a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html">ModelPlugins</a>, to provide access to the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Model.html">physics::Model</a> API</li>
<li><a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1SensorPlugin.html">SensorPlugins</a>, to provide access to the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1sensors_1_1Sensor.html">sensors::Sensor</a> API</li>
<li><a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1VisualPlugin.html">VisualPlugins</a>, to provide access to the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1rendering_1_1Visual.html">rendering::Visual</a> API</li>
</ol>
<p>You can read more about it <a href="http://gazebosim.org/tutorials?tut=ros_gzplugins">here</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-urdf-in-gazebo"><a class="header" href="#using-a-urdf-in-gazebo">Using a URDF in Gazebo</a></h1>
<p>In this section we will learn how to spawn and control our robot in Gazebo.</p>
<h2 id="1-nonfunctional-gazebo-interface"><a class="header" href="#1-nonfunctional-gazebo-interface">1. Nonfunctional Gazebo Interface</a></h2>
<p>We can spawn the model we already created into Gazebo for that lets create a launch file called <code>gazebo.launch</code>.</p>
<pre><code class="language-xml">&lt;launch&gt;

	&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;
	&lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;
	&lt;arg name=&quot;use_sim_time&quot; default=&quot;true&quot;/&gt;
	&lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;
	&lt;arg name=&quot;headless&quot; default=&quot;false&quot;/&gt;
	&lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;
	&lt;arg name=&quot;model&quot; default=&quot;$(find myrobot_description)/urdf/macroed.urdf.xacro&quot;/&gt;

	&lt;!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched --&gt;
	&lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;
		&lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;
		&lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;
		&lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot;/&gt;
		&lt;arg name=&quot;use_sim_time&quot; value=&quot;$(arg use_sim_time)&quot;/&gt;
		&lt;arg name=&quot;headless&quot; value=&quot;$(arg headless)&quot;/&gt;
	&lt;/include&gt;

	&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(arg model)&quot; /&gt;

	&lt;!-- push robot_description to factory and spawn robot in gazebo --&gt;
	&lt;node name=&quot;urdf_spawner&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;-z 1.0 -unpause -urdf -model robot -param robot_description&quot; respawn=&quot;false&quot; output=&quot;screen&quot; /&gt;

	&lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot;  name=&quot;robot_state_publisher&quot;&gt;
		&lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;30.0&quot; /&gt;
	&lt;/node&gt;

&lt;/launch&gt;
</code></pre>
<p>This launch file </p>
<ul>
<li>Loads the urdf from the macro tutorial into the parameter description (as before)</li>
<li>Launches an empty gazebo world</li>
<li>Runs the script to read the urdf from the parameter and spawn it in gazebo.</li>
<li>By default, the gazebo gui will also be displayed.</li>
</ul>
<p>However, it doesn’t do anything, and is missing lots of key information that ROS would need to use this robot. Previously we had been using <a href="http://wiki.ros.org/joint_state_publisher">joint_state_publisher</a> to specify the pose of each joint. However, the robot itself should provide that information in the real world or in gazebo. Yet without specifying that, Gazebo doesn’t know to publish that information.</p>
<p>To get the robot to be interactive (with you and ROS), we need to specify two things: Plugins and Transmissions. </p>
<h2 id="2-gazebo-plugin"><a class="header" href="#2-gazebo-plugin">2. Gazebo Plugin</a></h2>
<p>To get ROS to interact with Gazebo, we have to dynamically link to the ROS library that will tell Gazebo what to do. Theoretically, this allows for other Robot Operating Systems to interact with Gazebo in a generic way. In practice, its just ROS.</p>
<p>To link Gazebo and ROS, we specify the plugin in the URDF, right before the closing <code>&lt;/robot&gt;</code> tag:</p>
<pre><code class="language-xml">&lt;gazebo&gt;
    &lt;plugin name=&quot;gazebo_ros_control&quot; filename=&quot;libgazebo_ros_control.so&quot;&gt;
        &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;
    &lt;/plugin&gt;
&lt;/gazebo&gt;
</code></pre>
<p>you can run this by the command:</p>
<pre><code class="language-bash">roslaunch myrobot_description gazebo.launch
</code></pre>
<p>However, this won’t do anything new yet. For that we need to specify more information outside the URDF.</p>
<h2 id="3-spawning-controllers"><a class="header" href="#3-spawning-controllers">3. Spawning Controllers</a></h2>
<p>Now that we’ve linked ROS and Gazebo, we need to specify some bits of ROS code that we want to run within Gazebo, which we generically call controllers. These are initially loaded into the ROS parameter space. We will create a yaml file joints.yaml that specifies our first controller.</p>
<p>make a directory named <code>config</code> in your package and in it make a file called <code>joints.yaml</code> and copy the following in it:</p>
<pre><code class="language-yaml">type: &quot;joint_state_controller/JointStateController&quot;
publish_rate: 50
</code></pre>
<p>load this yaml file into the <code>myrobot_joint_state_controller</code> namespace add the following in your launch file before the <code>&lt;/launch&gt;</code> tag:</p>
<pre><code class="language-xml">&lt;rosparam command=&quot;load&quot; file=&quot;$(find myrobot_description)/config/joints.yaml&quot; ns=&quot;myrobot_joint_state_controller&quot; /&gt;

&lt;node name=&quot;myrobot_controller_spawner&quot; pkg=&quot;controller_manager&quot; type=&quot;spawner&quot; args=&quot;myrobot_joint_state_controller --shutdown-timeout 3&quot;/&gt;
</code></pre>
<p>You can launch this, but its still not quite there.
This will run the controller and in fact publish on the /joint_states topic….but with nothing in them.</p>
<p>What else do you want Gazebo!? Well, it wants to know what joints to publish information about.</p>
<h2 id="4-transmissions"><a class="header" href="#4-transmissions">4. Transmissions</a></h2>
<p>For every non-fixed joint, we need to specify a transmission, which tells Gazebo what to do with the joint. Lets specify transmissions to our wheel joints and add the following for each of the wheels from within the wheel macro. :</p>
<pre><code class="language-xml">&lt;transmission name=&quot;${prefix}_${suffix}_wheel_trans&quot;&gt;
	&lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
	&lt;actuator name=&quot;${prefix}_${suffix}_wheel_motor&quot;&gt;
		&lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
	&lt;/actuator&gt;
	&lt;joint name=&quot;${prefix}_${suffix}_wheel_joint&quot;&gt;
		&lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
	&lt;/joint&gt;
&lt;/transmission&gt;
</code></pre>
<p>This is just like the other transmissions, except</p>
<ul>
<li>
<p>It uses macro parameters to specify names</p>
</li>
<li>
<p>It uses a VelocityJointInterface.</p>
</li>
</ul>
<p>Since the wheels are actually going to touch the ground and thus interact with it physically, we also specify some additional information about the material of the wheels.</p>
<pre><code class="language-xml">&lt;gazebo reference=&quot;${prefix}_${suffix}_wheel&quot;&gt;
    &lt;mu1 value=&quot;200.0&quot; /&gt;
    &lt;mu2 value=&quot;100.0&quot; /&gt;
    &lt;kp value=&quot;10000000.0&quot; /&gt;
    &lt;kd value=&quot;1.0&quot; /&gt;
    &lt;material&gt;Gazebo/Grey&lt;/material&gt;
&lt;/gazebo&gt;
</code></pre>
<p>We could specify controllers for each of the individual wheels, but we want to control all the wheels together. For that, we’re going to need a lot of ros parameters.</p>
<p>make another file called <code>diffdrive.yaml</code> in your <code>config</code> folder and copy the following in it.</p>
<pre><code class="language-yaml">type: &quot;diff_drive_controller/DiffDriveController&quot;
publish_rate: 50

left_wheel: ['left_front_wheel_joint', 'left_back_wheel_joint']
right_wheel: ['right_front_wheel_joint', 'right_back_wheel_joint']

wheel_separation: 0.44

# Odometry covariances for the encoder output of the robot. These values should
# be tuned to your robot's sample odometry data, but these values are a good place
# to start
pose_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]
twist_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]

# Top level frame (link) of the robot description
base_frame_id: base_link

# Velocity and acceleration limits for the robot
linear:
  x:
    has_velocity_limits    : true
    max_velocity           : 0.2   # m/s
    has_acceleration_limits: true
    max_acceleration       : 0.6   # m/s^2
angular:
  z:
    has_velocity_limits    : true
    max_velocity           : 2.0   # rad/s
    has_acceleration_limits: true
    max_acceleration       : 6.0   # rad/s^2
</code></pre>
<p>The DiffDriveController subscribes to a standard Twist cmd_vel message and moves the robot accordingly.</p>
<p>We will have to load this file just like we did with <code>joints.yaml</code>.</p>
<p>This is the final macroed version of the urdf file: <a href="ROS_with_Gazebo/Gazebo_Plugins/ROS_with_Gazebo/Gazebo_Plugins/macroed.urdf.xacro" download><button>Download</button></a></p>
<p>This is the final version of the launch file: <a href="ROS_with_Gazebo/Gazebo_Plugins/ROS_with_Gazebo/Gazebo_Plugins/gazebo.launch" download><button>Download</button></a></p>
<pre><code class="language-bash">roslaunch myrobot_description gazebo.launch
</code></pre>
<p>In addition to loading the above configuration, this also opens the RobotSteering panel, allowing you to drive the R2D2 robot around, while also observing its actual behavior (in Gazebo):</p>
<p><img src="ROS_with_Gazebo/Gazebo_Plugins/./simulation.png" alt="image" /></p>
<p>Congrats! Now you’re simulating robots with URDF.</p>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="micromouse"><a class="header" href="#micromouse">Micromouse</a></h1>
<br>
<h2 id="difficulty-intermediate-1"><a class="header" href="#difficulty-intermediate-1">Difficulty: Intermediate</a></h2>
<hr />
<p><img src="Micromouse/micromouse.jpg" alt="micromouse" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide-1"><a class="header" href="#installation-guide-1">Installation Guide</a></h1>
<ol>
<li>
<p>Download the <code>micromouse</code> package =&gt; <a href="Micromouse/micromouse.zip" download><button>Download</button></a></p>
</li>
<li>
<p>Extract files to your <code>workspace/src</code> folder.</p>
</li>
<li>
<p>Once the repository is updated build your workspace and source the setup.bash of your workspace.</p>
<pre><code class="language-bash">cd ~/workspace
catkin_make
source devel/setup.bash
</code></pre>
</li>
<li>
<p>To check if everything is installed properly enter the following command:</p>
<pre><code class="language-bash">roslaunch micromouse micromouse.launch
</code></pre>
<p>If everything is in place you should see the following environment in Gazebo.</p>
<p><img src="Micromouse/launch_maze.png" alt="launch_maze" /></p>
</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-your-own-micromouse"><a class="header" href="#creating-your-own-micromouse">Creating your own Micromouse</a></h1>
<ul>
<li>
<p>Create a new xacro file in <code>urdf</code> folder of <code>micromouse</code> package.</p>
<pre><code class="language-bash">roscd micromouse
touch urdf/micromouse_bot.urdf.xacro
touch urdf/micromouse_bot.gazebo
</code></pre>
<p><code>micromouse_bot.urdf.xacro</code></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;robot name=&quot;micromouse&quot; xmlns:xacro=&quot;https://www.ros.org/wiki/xacro&quot;&gt;

    &lt;!-- Import all Gazebo-customization elements, including Gazebo colors --&gt;
    &lt;xacro:include filename=&quot;$(find micromouse)/urdf/micromouse_bot.gazebo&quot; /&gt;

    &lt;material name=&quot;green&quot;&gt;
        &lt;color rgba=&quot;0.2 0.4 0.2 1.0&quot;/&gt;
    &lt;/material&gt;

    &lt;material name=&quot;black&quot;&gt;
        &lt;color rgba=&quot;0.0 0.0 0.0 1.0&quot;/&gt;
    &lt;/material&gt;

    &lt;xacro:property name=&quot;rotate&quot; value=&quot;1.57079632679&quot;/&gt;
    &lt;xacro:property name=&quot;head_radius&quot; value=&quot;0.025&quot;/&gt;
    &lt;xacro:property name=&quot;body_radius&quot; value=&quot;0.020&quot;/&gt;
    &lt;xacro:property name=&quot;body_length&quot; value=&quot;0.05&quot;/&gt;

    &lt;xacro:macro name=&quot;default_inertial&quot;&gt;
        &lt;inertial&gt;
            &lt;mass value=&quot;0.001&quot; /&gt;
            &lt;inertia ixx=&quot;1e-06&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1e-06&quot; iyz=&quot;0.0&quot; izz=&quot;1e-06&quot; /&gt;
        &lt;/inertial&gt;
    &lt;/xacro:macro&gt;
    
    &lt;link name=&quot;mouse_body_link&quot;&gt;
        &lt;inertial&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt;
            &lt;mass value=&quot;0.5&quot;/&gt;
            &lt;inertia ixx=&quot;0.00022083&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;0.00022083&quot; iyz=&quot;0.0&quot; izz=&quot;0.00040833&quot;/&gt;
        &lt;/inertial&gt;
        &lt;visual&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;${rotate} 0.0 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;${body_radius}&quot; length=&quot;${body_length}&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;green&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision name=&quot;body&quot;&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;${rotate} 0.0 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;${body_radius}&quot; length=&quot;${body_length}&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;visual&gt;
            &lt;origin xyz=&quot;0.0 ${body_length/2} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;${body_radius}&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;green&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision name=&quot;butt&quot;&gt;
            &lt;origin xyz=&quot;0.0 ${body_length/2} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;${body_radius}&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;visual&gt;
            &lt;origin xyz=&quot;0.0 -${body_length/2} 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;${head_radius}&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;green&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;0.0 -${body_length/2} 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;${head_radius}&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;visual name=&quot;left_eye&quot;&gt;
            &lt;origin xyz=&quot;-0.01 -${body_length/2+head_radius-0.005} 0.01&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;0.004&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;-0.01 -${body_length/2+head_radius-0.005} 0.01&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;0.004&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;visual name=&quot;right_eye&quot;&gt;
            &lt;origin xyz=&quot;0.01 -${body_length/2+head_radius-0.005} 0.01&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;0.004&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;0.01 -${body_length/2+head_radius-0.005} 0.01&quot;/&gt;
            &lt;geometry&gt;
                &lt;sphere radius=&quot;0.004&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
        &lt;visual name=&quot;nose&quot;&gt;
            &lt;origin xyz=&quot;0.0 -${body_length/2+head_radius-0.005} -0.01&quot; rpy=&quot;${2*rotate} 0.0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.006&quot; length=&quot;0.0055&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;0.0 -${body_length/2+head_radius-0.005} -0.01&quot; rpy=&quot;${2*rotate} 0.0 0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.006&quot; length=&quot;0.0055&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
    &lt;/link&gt;

    &lt;link name=&quot;right_wheel_link&quot;&gt;
        &lt;inertial&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;mass value=&quot;0.2&quot;/&gt;
            &lt;inertia ixx=&quot;2.3e-06&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;2.3e-06&quot; iyz=&quot;0.0&quot; izz=&quot;4.5e-06&quot;/&gt;
        &lt;/inertial&gt;
        &lt;visual&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.02&quot; length=&quot;0.01&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.02&quot; length=&quot;0.01&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
    &lt;/link&gt;

    &lt;joint name=&quot;right_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;parent link=&quot;mouse_body_link&quot;/&gt;
        &lt;child link=&quot;right_wheel_link&quot;/&gt;
        &lt;axis xyz=&quot;1 0 0&quot;/&gt;
        &lt;origin xyz=&quot;-0.025  0.02 -0.005&quot; rpy=&quot;0 0 0&quot;/&gt;
        &lt;limit effort=&quot;-1&quot; velocity=&quot;100&quot;/&gt;
        &lt;joint_properties damping=&quot;0.01&quot; friction=&quot;0.0&quot; /&gt;
    &lt;/joint&gt;

    &lt;transmission name=&quot;right_wheel_trans&quot;&gt;
        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
        &lt;joint name=&quot;right_wheel_joint&quot;&gt;
            &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
        &lt;/joint&gt;
        &lt;actuator name=&quot;right_wheel_motor&quot;&gt;
            &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
            &lt;mechanicalReduction&gt;7&lt;/mechanicalReduction&gt;
        &lt;/actuator&gt;
    &lt;/transmission&gt;

    &lt;link name=&quot;left_wheel_link&quot;&gt;
        &lt;inertial&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;mass value=&quot;0.2&quot;/&gt;
            &lt;inertia ixx=&quot;2.3e-06&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;2.3e-06&quot; iyz=&quot;0.0&quot; izz=&quot;4.5e-06&quot;/&gt;
        &lt;/inertial&gt;
        &lt;visual&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.02&quot; length=&quot;0.01&quot;/&gt;
            &lt;/geometry&gt;
            &lt;material name=&quot;black&quot;/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 ${rotate} 0.0&quot;/&gt;
            &lt;geometry&gt;
                &lt;cylinder radius=&quot;0.02&quot; length=&quot;0.01&quot;/&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
    &lt;/link&gt;

    &lt;joint name=&quot;left_wheel_joint&quot; type=&quot;continuous&quot;&gt;
        &lt;parent link=&quot;mouse_body_link&quot;/&gt;
        &lt;child link=&quot;left_wheel_link&quot;/&gt;
        &lt;axis xyz=&quot;1 0 0&quot;/&gt;
        &lt;origin xyz=&quot;0.025  0.02 -0.005&quot; rpy=&quot;0 0 0&quot;/&gt;
        &lt;limit effort=&quot;-1&quot; velocity=&quot;100&quot;/&gt;
        &lt;joint_properties damping=&quot;0.01&quot; friction=&quot;0.0&quot; /&gt;
    &lt;/joint&gt;

    &lt;transmission name=&quot;left_wheel_trans&quot;&gt;
        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
        &lt;joint name=&quot;left_wheel_joint&quot;&gt;
            &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
        &lt;/joint&gt;
        &lt;actuator name=&quot;left_wheel_motor&quot;&gt;
            &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
            &lt;mechanicalReduction&gt;7&lt;/mechanicalReduction&gt;
        &lt;/actuator&gt;
    &lt;/transmission&gt;

&lt;/robot&gt;
</code></pre>
<center><a href="Micromouse/micromouse_bot.urdf.xacro" download><button>Download</button></a></center>
</li>
</ul>
<br/>
<ul>
<li>
<p>Add all gazebo related tags in <code>micromouse_bot.gazebo</code>.</p>
<p><code>micromouse_bot.gazebo</code></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;robot&gt;
    &lt;!-- Gazebo plugin for ROS Control --&gt;
    &lt;!-- &lt;gazebo&gt;
        &lt;plugin name=&quot;gazebo_ros_control&quot; filename=&quot;libgazebo_ros_control.so&quot;&gt;
            &lt;robotNamespace&gt;/micromouse&lt;/robotNamespace&gt;
        &lt;/plugin&gt;
    &lt;/gazebo&gt; --&gt;

    &lt;gazebo reference=&quot;mouse_body_link&quot;&gt;
        &lt;mu1 value=&quot;0.3&quot;/&gt;
        &lt;mu2 value=&quot;0.3&quot;/&gt;
        &lt;kp value=&quot;1000000.0&quot;/&gt;
        &lt;kd value=&quot;100.0&quot;/&gt;
        &lt;maxVel value=&quot;10&quot;/&gt;
        &lt;material&gt;Gazebo/Orange&lt;/material&gt;
        &lt;turnGravityOff&gt;false&lt;/turnGravityOff&gt;
    &lt;/gazebo&gt;

    &lt;!-- Frictional Values --&gt;
    &lt;gazebo reference=&quot;left_wheel_link&quot;&gt;
        &lt;mu1 value=&quot;10.0&quot;/&gt;
        &lt;mu2 value=&quot;10.0&quot;/&gt;
        &lt;kp value=&quot;1000000.0&quot;/&gt;
        &lt;kd value=&quot;100.0&quot;/&gt;
        &lt;material&gt;Gazebo/Black&lt;/material&gt;
        &lt;turnGravityOff&gt;false&lt;/turnGravityOff&gt;
    &lt;/gazebo&gt;

    &lt;gazebo reference=&quot;right_wheel_link&quot;&gt;
        &lt;mu1 value=&quot;10.0&quot;/&gt;
        &lt;mu2 value=&quot;10.0&quot;/&gt;
        &lt;kp value=&quot;1000000.0&quot;/&gt;
        &lt;kd value=&quot;100.0&quot;/&gt;
        &lt;material&gt;Gazebo/Black&lt;/material&gt;
        &lt;turnGravityOff&gt;false&lt;/turnGravityOff&gt;
    &lt;/gazebo&gt;

    &lt;!-- Differential Drive --&gt;
    &lt;gazebo&gt;
        &lt;plugin filename=&quot;libgazebo_ros_diff_drive.so&quot; name=&quot;differential_drive_controller&quot;&gt;
            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;
            &lt;updateRate&gt;20&lt;/updateRate&gt;
            &lt;leftJoint&gt;left_wheel_joint&lt;/leftJoint&gt;
            &lt;rightJoint&gt;right_wheel_joint&lt;/rightJoint&gt;
            &lt;wheelSeparation&gt;0.4&lt;/wheelSeparation&gt;
            &lt;wheelDiameter&gt;0.2&lt;/wheelDiameter&gt;
            &lt;wheelAcceleration&gt;0&lt;/wheelAcceleration&gt;
            &lt;wheelTorque&gt;1&lt;/wheelTorque&gt;
            &lt;commandTopic&gt;/micromouse/cmd_vel&lt;/commandTopic&gt;
            &lt;odometryTopic&gt;/micromouse/odom&lt;/odometryTopic&gt;
            &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;
            &lt;!-- &lt;odometrySource&gt;world&lt;/odometrySource&gt; --&gt;
            &lt;robotBaseFrame&gt;mouse_body_link&lt;/robotBaseFrame&gt;
        &lt;/plugin&gt;
    &lt;/gazebo&gt;

    &lt;!-- SENSORS --&gt;
    &lt;gazebo reference=&quot;mouse_body_link&quot;&gt;
        &lt;sensor type=&quot;ray&quot; name=&quot;laser&quot;&gt;
            &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
            &lt;visualize&gt;true&lt;/visualize&gt;
            &lt;update_rate&gt;20&lt;/update_rate&gt;
            &lt;ray&gt;
            &lt;scan&gt;
                &lt;horizontal&gt;
                &lt;samples&gt;720&lt;/samples&gt;
                &lt;resolution&gt;1&lt;/resolution&gt;
                &lt;min_angle&gt;-3.1415926&lt;/min_angle&gt;
                &lt;max_angle&gt;3.1415926&lt;/max_angle&gt;
                &lt;/horizontal&gt;
            &lt;/scan&gt;
            &lt;range&gt;
                &lt;min&gt;0.06&lt;/min&gt;
                &lt;max&gt;3.5&lt;/max&gt;
                &lt;resolution&gt;0.01&lt;/resolution&gt;
            &lt;/range&gt;
            &lt;/ray&gt;
            &lt;plugin name=&quot;laser&quot; filename=&quot;libgazebo_ros_laser.so&quot;&gt;
                &lt;topicName&gt;/micromouse/laser/scan&lt;/topicName&gt;
                &lt;frameName&gt;mouse_body_link&lt;/frameName&gt;
            &lt;/plugin&gt;
        &lt;/sensor&gt;
    &lt;/gazebo&gt;

&lt;/robot&gt;
</code></pre>
<center><a href="Micromouse/micromouse_bot.gazebo" download><button>Download</button></a></center>
</li>
</ul>
<br/>
<ul>
<li>
<p>To test your robot model in RViz, run this command:</p>
<pre><code class="language-bash">roslaunch urdf_tutorial display.launch model:='$(find micromouse)/urdf/micromouse_bot.urdf.xacro'
</code></pre>
<p><img src="Micromouse/micromouse_urdf_rviz.png" alt="micromouse_urdf_rviz" /></p>
<blockquote>
<p><strong>Note</strong>: Select <code>mouse_body_link</code> in Fixed frame in RViz Global options to correctly visualize the robot model.</p>
</blockquote>
</li>
</ul>
<br/>
<p><img src="Micromouse/micromouse_urdf.jpg" alt="micromouse_urdf" /></p>
<p><strong>Congratulations! You’ve successfully created your own micromouse.</strong></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-codes"><a class="header" href="#example-codes">Example Codes</a></h1>
<br/>
<blockquote>
<p><strong>Note</strong>: Here we have some python scripts to make you familiar with micromouse movement and laser scan. At the end of these tutorials, you’ll be able to move micromouse in a maze with obstacle avoidance.</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>: Add demonstration videos as output in each tutorial.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-reading-laser-scan"><a class="header" href="#example-1-reading-laser-scan">Example 1: Reading Laser Scan</a></h1>
<p><strong>Goal</strong>: Subscribe to <code>/micromouse/laser/scan</code> rostopic and print laser values.</p>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<p><code>node_reading_laser.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

import rospy

from sensor_msgs.msg import LaserScan


def clbk_laser(msg):
    # 720 / 10 = 72
    regions = [
        min(min(msg.ranges[0:71]), 10),
        min(min(msg.ranges[72:143]), 10),
        min(min(msg.ranges[144:215]), 10),
        min(min(msg.ranges[216:287]), 10),
        min(min(msg.ranges[288:359]), 10),
        min(min(msg.ranges[360:431]), 10),
        min(min(msg.ranges[432:503]), 10),
        min(min(msg.ranges[504:575]), 10),
        min(min(msg.ranges[576:647]), 10),
        min(min(msg.ranges[648:719]), 10)
    ]
    rospy.loginfo(regions)


def main():
    rospy.init_node('reading_laser')

    sub = rospy.Subscriber('/micromouse/laser/scan', LaserScan, clbk_laser)

    rospy.spin()


if __name__ == '__main__':
    main()
    
</code></pre>
<center><a href="Micromouse/Example_Codes/node_reading_laser.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-use-differential-drive-to-move-micromouse"><a class="header" href="#example-2-use-differential-drive-to-move-micromouse">Example 2: Use Differential Drive to move Micromouse</a></h1>
<p><strong>Goal</strong>: Publish on <code>/micromouse/cmd_vel</code> to move micromouse.</p>
<h2 id="code-6"><a class="header" href="#code-6">Code</a></h2>
<p><code>cmd_vel_robot.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float64
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from tf import transformations

import math

x_dist = 0
y_dist = 0


def clbk_odom(msg):
    global x_dist
    global y_dist
    global yaw_
    # position
    position_ = msg.pose.pose.position
    # gives x and y distance of the bot
    x_dist = position_.x
    y_dist = position_.y

    # yaw
    # convert quaternions to euler angles, only extracting yaw angle for the robot
    quaternion = (
        msg.pose.pose.orientation.x,
        msg.pose.pose.orientation.y,
        msg.pose.pose.orientation.z,
        msg.pose.pose.orientation.w)
    euler = transformations.euler_from_quaternion(quaternion)

    # fixing joint pos by subtracting 90 degrees because they're different in gazebo and ROS
    yaw_ = euler[2]-math.pi/2
    print(x_dist, y_dist)


def clbk_laser(msg):
    region = {
        'p': msg.ranges[:],
    }
    # region['p'][0] represents the 0 degree and 0the value start from back and continues in anti-clockwise direction
    for i in range(720):
        print(region['p'][i])


def main():
    pub = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=10)
    sub_odom = rospy.Subscriber('/micromouse/odom', Odometry, clbk_odom)
    sub = rospy.Subscriber('/micromouse/laser/scan', LaserScan, clbk_laser)
    rospy.init_node('cmd_robot', anonymous=True)
    rate = rospy.Rate(50)  # 50hz

    while not rospy.is_shutdown():
        msg1 = Twist()
    # positive speed_z value represents clockwise angular velocity of the bot and positive speed_x value represents forward linear velocity of the robot
        speed_z = 0
        speed_x = 0.5
        msg1.linear.x = speed_x
        msg1.angular.z = speed_z
        pub.publish(msg1)
        rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="Micromouse/Example_Codes/cmd_vel_robot.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-use-velocity-controller-to-move-micromouse"><a class="header" href="#example-3-use-velocity-controller-to-move-micromouse">Example 3: Use Velocity Controller to move Micromouse</a></h1>
<p><strong>Goal</strong>: Control each micromouse wheel separately by publishing on each topic.</p>
<h2 id="code-7"><a class="header" href="#code-7">Code</a></h2>
<p><code>velocity_controller.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float64


def servo_cmd(servo_val, flag):
    pub = rospy.Publisher(
        '/micromouse/left_wheel_joint_velocity_controller/command', Float64, queue_size=40)
    pub2 = rospy.Publisher(
        '/micromouse/right_wheel_joint_velocity_controller/command', Float64, queue_size=40)
    rospy.init_node('servo_cmd', anonymous=True)
    rate = rospy.Rate(50)  # 50hz
    while not rospy.is_shutdown():
        pub.publish(5.0)
        pub2.publish(5.0)
        rate.sleep()


servo_val = 0.0
flag = 0.0
if __name__ == '__main__':
    try:
        servo_cmd(servo_val, flag)
    except rospy.ROSInterruptException:
        pass

</code></pre>
<center><a href="Micromouse/Example_Codes/velocity_controller.py" download><button>Download</button></a></center>
<br/>
<blockquote>
<p><strong>Note 1</strong>: Load the yaml file <code>velocity_controller.yaml</code> in config directory first.</p>
</blockquote>
<blockquote>
<p><strong>Note 2</strong>: Use ROS_CONTROL Package provided by ROS. Just read the file and <code>micromouse_bot.gazebo</code> and uncomment the plugin and use <code>velocity_controller.py</code> for further references.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-4-go-to-point"><a class="header" href="#example-4-go-to-point">Example 4: Go to point</a></h1>
<p><strong>Goal</strong>: Make micromouse reach a destination position from a yaml file.</p>
<h2 id="code-8"><a class="header" href="#code-8">Code</a></h2>
<p>First, load <code>go_to_point.yaml</code>.</p>
<pre><code class="language-bash">roscd micromouse
rosparam load config/go_to_point.yaml
</code></pre>
<p><code>node_go_to_point.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

# import ros stuff
import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist, Point
from nav_msgs.msg import Odometry
from tf import transformations
from std_srvs.srv import *

import math

active_ = False

# robot state variables
position_ = Point()
yaw_ = 0
# machine state
state_ = 0
# goal
desired_position_ = Point()
desired_position_.x = rospy.get_param('des_pos_x')
desired_position_.y = rospy.get_param('des_pos_y')
desired_position_.z = 0
# parameters
yaw_precision_ = math.pi / 90  # +/- 2 degree allowed
dist_precision_ = 0.01
# publishers
pub = None

# service callbacks


def go_to_point_switch(req):
    global active_
    active_ = req.data
    res = SetBoolResponse()
    res.success = True
    res.message = 'Done!'
    return res

# callbacks


def clbk_odom(msg):
    global position_
    global yaw_

    # position
    position_ = msg.pose.pose.position

    # yaw
    quaternion = (
        msg.pose.pose.orientation.x,
        msg.pose.pose.orientation.y,
        msg.pose.pose.orientation.z,
        msg.pose.pose.orientation.w)
    euler = transformations.euler_from_quaternion(quaternion)
    # fixing joint pos by subtracting 90 degrees because they're different in gazebo and ROS
    yaw_ = euler[2]-math.pi/2


def change_state(state):
    global state_
    state_ = state
    print('State changed to [%s]' % state_)


def normalize_angle(angle):
    if(math.fabs(angle) &gt; math.pi):
        angle = angle - (2 * math.pi * angle) / (math.fabs(angle))
    return angle


def fix_yaw(des_pos):
    global yaw_, pub, yaw_precision_, state_
    desired_yaw = math.atan2(des_pos.y - position_.y, des_pos.x - position_.x)
    err_yaw = normalize_angle(desired_yaw - yaw_)

    rospy.loginfo(err_yaw)

    twist_msg = Twist()
    if math.fabs(err_yaw) &gt; yaw_precision_:
        twist_msg.angular.z = 0.3 if err_yaw &gt; 0 else -0.3

    pub.publish(twist_msg)

    # state change conditions
    if math.fabs(err_yaw) &lt;= yaw_precision_:
        print('Yaw error: [%s]' % err_yaw)
        change_state(1)


def go_straight_ahead(des_pos):
    global yaw_, pub, yaw_precision_, state_
    desired_yaw = math.atan2(des_pos.y - position_.y, des_pos.x - position_.x)
    err_yaw = desired_yaw - yaw_
    err_pos = math.sqrt(pow(des_pos.y - position_.y, 2) +
                        pow(des_pos.x - position_.x, 2))

    if err_pos &gt; dist_precision_:
        twist_msg = Twist()
        twist_msg.linear.x = 1.0
        pub.publish(twist_msg)
    else:
        print('Position error: [%s]' % err_pos)
        change_state(2)

    # state change conditions
    if math.fabs(err_yaw) &gt; yaw_precision_:
        print('Yaw error: [%s]' % err_yaw)
        change_state(0)


def done():
    twist_msg = Twist()
    twist_msg.linear.x = 0
    twist_msg.angular.z = 0
    pub.publish(twist_msg)


def main():
    global pub, active_

    rospy.init_node('go_to_point')

    pub = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=1)

    sub_odom = rospy.Subscriber('/micromouse/odom', Odometry, clbk_odom)

    srv = rospy.Service('go_to_point_switch', SetBool, go_to_point_switch)

    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        if not active_:
            continue
        else:
            if state_ == 0:
                fix_yaw(desired_position_)
            elif state_ == 1:
                go_straight_ahead(desired_position_)
            elif state_ == 2:
                done()
            else:
                rospy.logerr('Unknown state!')

        rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="Micromouse/Example_Codes/node_go_to_point.py" download><button>Download</button></a></center>
<p>To start the micromouse go to a point call this service.</p>
<pre><code class="language-bash">rosservice call /go_to_point_switch &quot;data: true&quot;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-5-maze-runner"><a class="header" href="#example-5-maze-runner">Example 5: Maze Runner</a></h1>
<p><strong>Goal</strong>: To run the micromouse in a maze.</p>
<h2 id="code-9"><a class="header" href="#code-9">Code</a></h2>
<p><code>node_maze_runner.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import math

# Global Variables
sensor_l, sensor_c, sensor_r = 0, 0, 0
pub = 0


def clbk_laser(msg):
    global sensor_l, sensor_c, sensor_r
    # 720 / 10 = 72
    regions = [
        round(100*min(min(msg.ranges[0:71]), 100)),
        round(100*min(min(msg.ranges[72:143]), 100)),
        round(100*min(min(msg.ranges[144:215]), 100)),
        round(100*min(min(msg.ranges[216:287]), 100)),
        round(100*min(min(msg.ranges[288:359]), 100)),
        round(100*min(min(msg.ranges[360:431]), 100)),
        round(100*min(min(msg.ranges[432:503]), 100)),
        round(100*min(min(msg.ranges[504:575]), 100)),
        round(100*min(min(msg.ranges[576:647]), 100)),
        round(100*min(min(msg.ranges[648:719]), 100))
    ]
    # rospy.loginfo(regions)
    print(&quot;l: {} \t c: {} \t r: {}&quot;.format(regions[4], regions[2], regions[0]))

    sensor_l = regions[4]
    sensor_c = regions[2]
    sensor_r = regions[0]

    # print(&quot;l: {} \t c: {} \t r: {}&quot;.format(sensor_l, sensor_c, sensor_r))


def motion_go_straight():
    global pub
    msg = Twist()
    msg.linear.x = 0.5
    pub.publish(msg)


def motion_stop():
    global pub
    msg = Twist()
    msg.linear.x = 0.0
    pub.publish(msg)


def main():

    global sensor_l, sensor_c, sensor_r
    global pub

    msg = Twist()

    rospy.init_node('node_maze_runner')

    sub = rospy.Subscriber('/micromouse/laser/scan', LaserScan, clbk_laser)
    pub = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=1)

    # pub.publish(msg)

    # rospy.spin()
    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        print(&quot;l: {} \t c: {} \t r: {}&quot;.format(sensor_l, sensor_c, sensor_r))
        if(sensor_c &gt; 9):
            motion_go_straight()
        else:
            motion_stop()

        rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="Micromouse/Example_Codes/node_maze_runner.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-6-obstacle-avoidance"><a class="header" href="#example-6-obstacle-avoidance">Example 6: Obstacle Avoidance</a></h1>
<p><strong>Goal</strong>: To run the micromouse in a maze with obstacle avoidance.</p>
<h2 id="code-10"><a class="header" href="#code-10">Code</a></h2>
<p><code>node_obstacle_avoidance.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

import rospy

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
pub = None


def clbk_laser(msg):
    regions = {
        'right':  min(min(msg.ranges[0:71]), 10),
        'fright': min(min(msg.ranges[72:143]), 10),
        'front':  min(min(msg.ranges[144:215]), 10),
        'fleft':  min(min(msg.ranges[216:287]), 10),
        'left':   min(min(msg.ranges[288:359]), 10)
    }

    take_action(regions)


def take_action(regions):
    msg = Twist()
    linear_x = 0
    angular_z = 0

    state_description = ''

    d = 0.15

    if regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
        state_description = 'case 1 - nothing'
        linear_x = 0.6
        angular_z = 0
    elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
        state_description = 'case 2 - front'
        linear_x = 0
        angular_z = 0.3
    elif regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
        state_description = 'case 3 - fright'
        linear_x = 0
        angular_z = 0.3
    elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
        state_description = 'case 4 - fleft'
        linear_x = 0
        angular_z = -0.3
    elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
        state_description = 'case 5 - front and fright'
        linear_x = 0
        angular_z = 0.3
    elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
        state_description = 'case 6 - front and fleft'
        linear_x = 0
        angular_z = -0.3
    elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
        state_description = 'case 7 - front and fleft and fright'
        linear_x = 0
        angular_z = 0.3
    elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
        state_description = 'case 8 - fleft and fright'
        linear_x = 0.3
        angular_z = 0
    else:
        state_description = 'unknown case'
        rospy.loginfo(regions)

    rospy.loginfo(state_description)
    msg.linear.x = linear_x
    msg.angular.z = angular_z
    pub.publish(msg)


def main():
    global pub

    rospy.init_node('reading_laser')

    pub = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=1)

    sub = rospy.Subscriber('/micromouse/laser/scan', LaserScan, clbk_laser)

    rospy.spin()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="Micromouse/Example_Codes/node_obstacle_avoidance.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-7-follow-wall"><a class="header" href="#example-7-follow-wall">Example 7: Follow wall</a></h1>
<p><strong>Goal</strong>: To make micromouse follow a wall if a wall if found with obstacle avoidance.</p>
<h2 id="code-11"><a class="header" href="#code-11">Code</a></h2>
<p><code>node_follow_wall.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

# import ros stuff
import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from tf import transformations
from std_srvs.srv import *

import math

active_ = False
pub_ = None
regions_ = {
    'right': 0,
    'front': 0,
    'left': 0,
}
state_ = 0
state_dict_ = {
    0: 'find the wall',
    1: 'turn left',
    2: 'follow the wall',
}


def wall_follower_switch(req):
    global active_
    active_ = req.data
    res = SetBoolResponse()
    res.success = True
    res.message = 'Done!'
    return res


def clbk_laser(msg):
    global regions_
    regions_ = {
        'right':  min(min(msg.ranges[0:71]), 10),
        'fright': min(min(msg.ranges[72:143]), 10),
        'front':  min(min(msg.ranges[144:215]), 10),
        'fleft':  min(min(msg.ranges[216:287]), 10),
        'left':   min(min(msg.ranges[288:359]), 10)
    }

    take_action()


def change_state(state):
    global state_, state_dict_
    if state is not state_:
        print('Wall follower - [%s] - %s' % (state, state_dict_[state]))
        state_ = state


def take_action():
    global regions_
    regions = regions_
    msg = Twist()
    linear_x = 0
    angular_z = 0

    state_description = ''

    d = 0.15
    print(regions)
    if regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
        state_description = 'case 1 - nothing'
        change_state(0)
    elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
        state_description = 'case 2 - front'
        change_state(1)
    elif regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
        state_description = 'case 3 - fright'
        change_state(2)
    elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
        state_description = 'case 4 - fleft'
        change_state(0)
    elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
        state_description = 'case 5 - front and fright'
        change_state(1)
    elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
        state_description = 'case 6 - front and fleft'
        change_state(1)
    elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
        state_description = 'case 7 - front and fleft and fright'
        change_state(1)
    elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
        state_description = 'case 8 - fleft and fright'
        change_state(0)
    else:
        state_description = 'unknown case'
        rospy.loginfo(regions)


def find_wall():
    msg = Twist()
    msg.linear.x = 0.6
    msg.angular.z = -0.5
    return msg


def turn_left():
    msg = Twist()
    msg.angular.z = 0.5
    return msg


def follow_the_wall():
    global regions_

    msg = Twist()
    msg.linear.x = 1.0
    return msg


def main():
    global pub_, active_

    rospy.init_node('reading_laser')

    pub_ = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=1)

    sub = rospy.Subscriber('/micromouse/laser/scan', LaserScan, clbk_laser)

    srv = rospy.Service('wall_follower_switch', SetBool, wall_follower_switch)

    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        if not active_:
            rate.sleep()
            continue

        msg = Twist()
        if state_ == 0:
            msg = find_wall()
        elif state_ == 1:
            msg = turn_left()
        elif state_ == 2:
            msg = follow_the_wall()
            pass
        else:
            rospy.logerr('Unknown state!')

        pub_.publish(msg)

        rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="Micromouse/Example_Codes/node_follow_wall.py" download><button>Download</button></a></center>
<br/>
<p>To make the micromouse follow the wall call this service.</p>
<pre><code class="language-bash">rosservice call /wall_follower_switch &quot;data: true&quot;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks-5"><a class="header" href="#tasks-5">Tasks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-0"><a class="header" href="#task-0">Task 0</a></h1>
<h2 id="welcome-to-task-0-"><a class="header" href="#welcome-to-task-0-">Welcome to Task 0 !!!</a></h2>
<hr />
<p>The aim of this task is to make you familiar with rostopics and rosservices. You
need to install the mentioned software &amp; libraries by running the provided instructions in the <strong>provided sequence only</strong>; and if any error occurs at any step, please do <strong>not</strong> proceed unless the error has been rectified from your end.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h1>
<ul>
<li>The objective of this task is to spawn two turtles in a <strong>turtlesim</strong> window and make one turtle follow another.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The name of turtles should be <code>turtle1</code> and <code>turtle2</code> respectively with <code>turtle2</code> following <code>turtle1</code>. <code>turtle1</code> should be spawned at default coordinates (5.544445, 5.544445, 0) and <code>turtle2</code> at (1.0, 1.0, 0.0).</p>
</blockquote>
<ul>
<li>You can do this by creating a node name, <code>node_catch_the_turtle</code> with a python script, <code>node_catch_the_turtle.py</code>.</li>
</ul>
<p><strong>Optional</strong>:</p>
<ul>
<li>
<p>Change the color of the pen of turtles.</p>
<ul>
<li><strong>turtle1</strong>
<ul>
<li><code>r: 255</code></li>
<li><code>g: 255</code></li>
<li><code>b: 0</code></li>
<li><code>width: 5</code></li>
</ul>
</li>
<li><strong>turtle2</strong>
<ul>
<li><code>r: 255</code></li>
<li><code>g: 0</code></li>
<li><code>b: 0</code></li>
<li><code>width: 4</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Change the background to <strong>forestgreen</strong>. </p>
<ul>
<li><code>background_r: 34</code></li>
<li><code>background_g: 139</code></li>
<li><code>background_b: 34</code></li>
</ul>
</li>
</ul>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<ol>
<li>First, create a package name <code>pkg_task0</code>, within your catkin workspace. Once done, compile and source the packages.</li>
</ol>
<pre><code class="language-bash">cd ~/workspace
catkin_make
source devel/setup.bash
</code></pre>
<ol>
<li>Within this package, you should have a <code>scripts</code> folder inside which you’ll create a python script, named <code>node_catch_the_turtle.py</code>.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: Fill the script with proper programming ethics. Doing this will help us understand your code better and quicker than usual.</p>
</blockquote>
<ol>
<li>After completing the python script. Make it executable, if it isn’t already. To do that, enter the following code.</li>
</ol>
<pre><code class="language-bash">chmod +x ~/workspace/src/pkg_task0/scripts/node_catch_the_turtle.py
</code></pre>
<ol>
<li>Before executing make sure that <code>roscore</code> is running along with <code>turtlesim_node</code>. You can either run them in separate terminals or simply create a <code>task0.launch</code> file inside the <code>~/workspace/src/pkg_task0/launch/</code> folder. Launch file can run multiple nodes unlike a python/cpp script. Run the launch file, enter,</li>
</ol>
<pre><code class="language-bash">roslaunch pkg_task0 task0.launch 
</code></pre>
<ul>
<li>This should run these processes in parallel.
<ul>
<li>roscore</li>
<li>turtlesim_node</li>
<li>turtle_teleop_key</li>
<li>node_catch_the_turtle.py</li>
</ul>
</li>
</ul>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<ul>
<li>You can use linear velocity as well as angular velocity with some combination to get this done. </li>
<li>Keep tracking the distance travelled so as to know when to stop.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h1>
<ul>
<li>The following videos can be considered as a valid output.</li>
</ul>
<p><img src="tasks/task0/expected-output.gif" alt="expected-output.gif" /></p>
<blockquote>
<p><strong>Note</strong>: First, let <code>turtle2</code> reach <code>turtle1</code> then only move <code>turtle1</code>.</p>
</blockquote>
<ul>
<li>To know whether the nodes are talking to each other as expected one can use the command <code>rqt_graph</code>. Below, you can find an expected graph for this task.</li>
</ul>
<p><img src="tasks/task0/rqt_graph-output.png" alt="rqt_graph-output.png" /></p>
<ul>
<li>Your terminal should look like this at the startup of roslaunch server.</li>
</ul>
<pre><code class="language-bash">ubuntu@ros-noetic:~$ roslaunch pkg_task0 turtle-task.launch 
... logging to /home/ubuntu/.ros/log/6f7d513a-c084-11eb-9883-a5ac155eafae/roslaunch-ros-noetic-10780.log
Checking log directory for disk usage. This may take a while.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.

started roslaunch server http://ros-noetic:34763/

SUMMARY
========

PARAMETERS
 * /node_turtlesim_node/background_b: 34
 * /node_turtlesim_node/background_g: 139
 * /node_turtlesim_node/background_r: 34
 * /rosdistro: noetic
 * /rosversion: 1.15.11

NODES
  /
    node_catch_the_turtle (pkg_task0/node_catch_the_turtle.py)
    node_turtle_teleop_key (turtlesim/turtle_teleop_key)
    node_turtlesim_node (turtlesim/turtlesim_node)

auto-starting new master
process[master]: started with pid [10788]
ROS_MASTER_URI=http://localhost:11311

setting /run_id to 6f7d513a-c084-11eb-9883-a5ac155eafae
process[rosout-1]: started with pid [10798]
started core service [/rosout]
process[node_turtlesim_node-2]: started with pid [10801]
process[node_turtle_teleop_key-3]: started with pid [10805]
process[node_catch_the_turtle-4]: started with pid [10807]
Reading from keyboard
---------------------------
Use arrow keys to move the turtle. 'q' to quit.
[ INFO] [1622296061.324015602]: Starting turtlesim with node name /node_turtlesim_node
[ INFO] [1622296061.328553969]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
[ INFO] [1622296061.657708547]: Spawning turtle [turtle2] at x=[1.000000], y=[1.000000], theta=[0.000000]
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs"><a class="header" href="#recording-logs">Recording Logs</a></h1>
<ul>
<li>
<p>ROS allows us to record a log of the messages that occurred in a given time period. This is like recording a data stream. The ROS utility which does this is called rosbag, and the command to capture the data is <code>rosbag record</code>.</p>
</li>
<li>
<p>Create a folder called bag_files in your package as a save destination for the bag files.</p>
</li>
<li>
<p>You can run the rosbag record command separately on the command line. But to not loose any data you will have to start recording precisely at the same moment your turtle starts moving. Hence it is a much more preferable option to include the rosbag recording in your launch file itself.</p>
</li>
<li>
<p>Add the following lines to your launch file to have the rosbag record run in parallel with your task. Some parameters are explained below:</p>
</li>
</ul>
<pre><code class="language-xml">    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;turtle_record.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
            args=&quot;record -O $(find pkg_task0)/bag_files/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /turtle2/cmd_vel /turtle2/pose&quot; output=&quot;screen&quot; /&gt;
    &lt;/group&gt;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Make sure you have added these line before <code>&lt;/launch&gt;</code> line. And the 3 nodes, the turtlesim, teleop_key and your python script node, are already present within this launch file, for desire recording.</p>
</blockquote>
<ul>
<li>The <code>arg_name</code> tags are roslaunch parameters, meaning they can be called while calling your roslaunch file, for example:</li>
</ul>
<pre><code class="language-bash">roslaunch pkg_task0 task0.launch record:=true rec_name:=my_turtle.bag
</code></pre>
<ul>
<li>This command will.. 
<ul>
<li>Start recording.</li>
<li>Should start turtlesim and turtle_teleop_key node.</li>
<li>Should start your python script node.</li>
<li>And name the resultant bag file as <strong>my_turtle.bag</strong>.</li>
</ul>
</li>
</ul>
<p>while still retaining the default value (in seconds) for the duration parameter.</p>
<p>Thus using these parameters along with your launch file will record a bag file of appropriate <code>duration</code>. Also, Make sure that the task is completed within the recording duration. <strong>If not then shorten the duration during which you run turtle1 using teleop_key.</strong></p>
<ul>
<li>If the rosbag has started, the message:</li>
</ul>
<pre><code class="language-bash">process[rosbag_record_turtle-5]: started with pid [1056]
</code></pre>
<p>will appear on your terminal within the roslaunch output window.</p>
<blockquote>
<p><strong>Note</strong>:  bag files with the same name will be overwritten by the rosbag utility without a prompt/warning. Make sure you provide proper name for each iteration if you want to save them all. </p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<blockquote>
<p><strong>Note</strong>: Remove this md page from mdbook and delete scripts from <code>src/tasks/task0/</code> It shows one of the possible solution with autoeval script.</p>
</blockquote>
<p><code>turtle-task.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;node_turtlesim_node&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;/background_r&quot; value=&quot;34&quot; /&gt;
        &lt;param name=&quot;/background_g&quot; value=&quot;139&quot; /&gt;
        &lt;param name=&quot;/background_b&quot; value=&quot;34&quot; /&gt;
    &lt;/node&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;node_turtle_teleop_key&quot; output=&quot;screen&quot; /&gt;
    &lt;node pkg=&quot;pkg_task0&quot; type=&quot;node_catch_the_turtle.py&quot; name=&quot;node_catch_the_turtle&quot; output=&quot;screen&quot; /&gt;

    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;turtle_record.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
        args=&quot;record -O $(find pkg_task0)/bag_files/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /turtle2/cmd_vel /turtle2/pose&quot; output=&quot;screen&quot; /&gt;

    &lt;/group&gt;
    
&lt;/launch&gt;
</code></pre>
<center><a href="tasks/task0/turtle-task.launch" download><button>Download</button></a></center>
<p><code>node_catch_the_turtle.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from turtlesim.srv import Spawn, SpawnResponse
from turtlesim.srv import SetPen
import math


class turtle:
    '''This class is used to spawn another turtle on turtlesim env and make it follow original
    spawned turtle.'''

    # Constructor
    def __init__(self):

        # Initialize node
        rospy.init_node('node_catch_me_turtle', anonymous=True)

        # Subscribe to pose of turtles
        self.t1_pose_subscriber = rospy.Subscriber(
            '/turtle1/pose', Pose, self.t1_pose_callback)
        self.t2_pose_subscriber = rospy.Subscriber(
            '/turtle2/pose', Pose, self.t2_pose_callback)

        # Spawn second turtle on turtlesim env
        self.spawn_turtle_srv = rospy.ServiceProxy('/spawn', Spawn)
        self.spawn_turtle_srv.wait_for_service()
        rospy.loginfo(self.spawn_turtle_srv.call(
            1.0, 1.0, 0.0, 'turtle2').name)

        # To publish on cmd_vel of turtle2
        self.velocity_publisher = rospy.Publisher(
            '/turtle2/cmd_vel', Twist, queue_size=10)

        # Set pen of both turtles
        self.set_t1_pen_srv = rospy.ServiceProxy('/turtle1/set_pen', SetPen)
        self.set_t2_pen_srv = rospy.ServiceProxy('/turtle2/set_pen', SetPen)
        self.set_t1_pen_srv.wait_for_service()
        self.set_t2_pen_srv.wait_for_service()
        self.set_t1_pen_srv.call(255, 255, 0, 5, 0)  # yellow
        self.set_t2_pen_srv.call(255, 0, 0, 4, 0)   # red

        self.t1_pose = Pose()
        self.t2_pose = Pose()
        self.twist = Twist()
        self.rate = rospy.Rate(10)  # Rate in Hz

    def t1_pose_callback(self, pos_msg):
        self.t1_pose = pos_msg
        self.t1_pose.x = pos_msg.x
        self.t1_pose.y = pos_msg.y

    def t2_pose_callback(self, pos_msg):
        self.t2_pose = pos_msg
        self.t2_pose.x = pos_msg.x
        self.t2_pose.y = pos_msg.y
        self.t2_pose.theta = pos_msg.theta

    def turtle_follow_turtle(self):
        '''This method makes turtle2 follow turtle1.'''

        # Constants to move turtle. Change these to speed up or speed down motion.
        k_linear = 0.5
        k_angular = 4.0

        # Infinite loop
        while not rospy.is_shutdown():

            # Calculate distance between two turtles
            distance = math.sqrt(
                (self.t2_pose.x - self.t1_pose.x)**2 + (self.t2_pose.y - self.t1_pose.y)**2)
            linear_speed = k_linear * distance

            # Angle between two turtles in radians
            angle = math.atan2(self.t1_pose.y - self.t2_pose.y,
                               self.t1_pose.x - self.t2_pose.x)
            # Need to subtract current angle of turtle2 to move relatively
            angular_speed = k_angular * (angle - self.t2_pose.theta)

            # resolution of 0.01
            if distance &gt; 0.01:
                self.twist.linear.x = linear_speed
                self.twist.angular.z = angular_speed
            else:
                self.twist.linear.x = 0
                self.twist.angular.z = 0

            # Publishing values on /turtle2/cmd_vel
            self.velocity_publisher.publish(self.twist)
            self.rate.sleep()

    # Destructor
    def __del__(self):
        # Unregister from rostopics
        self.t1_pose_subscriber.unregister()
        self.t2_pose_subscriber.unregister()
        rospy.loginfo(
            '\033[94m' + &quot;Object of class controlSimEnv Deleted.&quot; + '\033[0m')


def main():
    t = turtle()
    t.turtle_follow_turtle()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="tasks/task0/node_catch_the_turtle.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoeval-script"><a class="header" href="#autoeval-script">Autoeval script</a></h1>
<blockquote>
<p><strong>Note</strong>: Save this file in a ROS package scripts folder. Then to run this script, run in terminal <code>rosrun &lt;pkg-name&gt; autoeval.py</code>. This script generates a <code>results.csv</code> file showing the results.</p>
</blockquote>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_task0 autoeval.py
# It will create a results.csv to the location where all bag_files is located.


def evaluate_score(bag):
    '''This method evaulates scores by looking into bag files. It then
    returns strings showing outcome.'''

    topics = bag.get_type_and_topic_info()[1].keys()
    if '/turtle1/pose' and '/turtle2/pose' and '/turtle1/cmd_vel' and '/turtle2/cmd_vel' in topics:
        is_topic_present = True
    else:
        is_topic_present = False

    t1_pos_msg_list = []
    t2_pos_msg_list = []

    for topic, msg, t in bag.read_messages(topics=['/turtle1/pose']):
        t1_pos_msg_list.append((t, msg))
    for topic, msg, t in bag.read_messages(topics=['/turtle2/pose']):
        t2_pos_msg_list.append((t, msg))

    dist_list = merge_list_with_calculated_distance(
        t1_pos_msg_list, t2_pos_msg_list)

    t1_cmd_vel_list = []
    t2_cmd_vel_list = []
    for topic, msg, t in bag.read_messages(topics=['/turtle1/cmd_vel']):
        t1_cmd_vel_list.append((t, msg))
    for topic, msg, t in bag.read_messages(topics=['/turtle2/cmd_vel']):
        t2_cmd_vel_list.append((t, msg))

    is_turtle2_running = is_turtle2_moving_when_turtle1_moves(
        t1_cmd_vel_list, t2_pos_msg_list)

    # Get the first publish timestamp of /turtle1/cmd_vel
    first_pub = t1_cmd_vel_list[0][0]

    # Find the closest value in the dist_list timestamp
    before_mov_t1 = min(dist_list, key=lambda list: abs(list[0] - first_pub))
    idx = dist_list.index(before_mov_t1)

    i = 1   # To ignore first element starting from 1 instead of 0
    count = 0   # Count the number of time distance is increasing.
    while i &lt; idx:
        if dist_list[i][1] &gt; dist_list[i-1][1]:
            count += 1
        i += 1
    percent_of_distance_increasing = (count * 100) / idx

    if dist_list[idx - 1][1] &lt; 0.05:
        is_reach_turtle1_spawn = True
    else:
        is_reach_turtle1_spawn = False

    if dist_list[-1][1] &lt; 0.05 and percent_of_distance_increasing &lt; 5 and is_turtle2_running:
        is_turtle2_following = True
    else:
        is_turtle2_following = False

    bag.close()
    return is_topic_present, is_reach_turtle1_spawn, is_turtle2_following


def calculate_distance(x0, y0, x1, y1):
    '''Calculate distance between two points in 2D. Input points (x0, y0) and
    (x1, y1).'''
    return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)


def is_turtle2_moving_when_turtle1_moves(list1, list2):
    '''Check if turtle2 is running when turtle1 is moving. Return True
    if successful.'''
    closest_value = []
    # Create a list with timestamps similar to turtle1 moving out of turtle2
    # timestamps.
    for t, msg in list1:
        closest_value.append(min(
            list2, key=lambda list: abs(list[0] - t)))

    count = 0
    for t, msg in closest_value:
        if msg.linear_velocity == 0 and msg.angular_velocity == 0:
            count += 1
    # Currently it is set at 5 percent.
    if (count * 100) / len(closest_value) &lt; 5:
        return True
    else:
        return False


def merge_list_with_calculated_distance(list1, list2):
    '''Takes turtle1 and turtl2 position list with timestamps as arguments and
    return a list of distance between turtle1 and turtle2 with timestamps.'''
    l1 = [(t, msg, 1) for (t, msg) in list1]
    l2 = [(t, msg, 2) for (t, msg) in list2]
    new_list = l1 + l2
    # Sort list based on timestamps and index provided for t1 and t2 as 1, 2
    sorted_list = sorted(
        new_list, key=lambda element: (element[0], element[2]))
    c1 = list1[0][1]  # first value of msg
    c2 = list2[0][1]
    last_time = -1
    result = []
    for t, msg, index in sorted_list:
        if index == 1:
            c1 = msg
        elif index == 2:
            c2 = msg
        elif t == last_time:
            result.pop()
        result.append((t, calculate_distance(c1.x, c1.y, c2.x, c2.y)))
    return result


def get_remark(score):
    '''Returns the result based on success rate.'''
    if not score[0]:
        return &quot;Task Failed! Bag file doesn't have all topics.&quot;, False
    else:
        if not score[1]:
            return &quot;Task Failed! turtle2 Couldn't reach turtle1 at it's spawn position.&quot;, True
        else:
            if not score[2]:
                return &quot;Task Failed! Probably the bag file isn't complete.&quot;, True
            else:
                return &quot;Passed.&quot;, False


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/pkg_task0/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)

    print(bag_files)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)

        data_writer.writerow(['filename', 'Is turtle2 spawned?',
                             'Does turtle2 reach turtle1 spawn position?', 'Is turtle2 following turtle1?', 'Remark', 'Is Manual Evaluation required if a query is raised?'])
        for file in bag_files:
            bag = rosbag.Bag(file)
            score = evaluate_score(bag)
            remark = get_remark(score)
            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], score[0], score[1], score[2], remark[0], remark[1]])

    print(&quot;Finished creating csv file!&quot;)


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task0/autoeval.py" download><button>Download</button></a><center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-2"><a class="header" href="#task-2">Task 2</a></h1>
<p>Welcome to Task 2!!!</p>
<p>The aim of this taks is to get you familiar with ROS Actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-1"><a class="header" href="#problem-statement-1">Problem Statement</a></h1>
<ul>
<li>
<p>The objective of this task is to Create Ros Action server and client with the help of which you will draw shapes inside the turtlesim window. For this Taks you have to send a goal to ther server to make a square shape with radius (distance of centeroid from a vertex) = 1 units and after waiting for two seconds send anpther goal to draw a circle with radius 2 which will preempt the current gaol.</p>
</li>
<li>
<p>You are supposed to do this by creating a server side script <code>shape_server.py</code> and a client side script <code>shape_client.py</code> and also a <code>.action</code> file called <code>DrawShape.action</code>.</p>
</li>
</ul>
<h2 id="procedure-1"><a class="header" href="#procedure-1">Procedure</a></h2>
<ol>
<li>
<p>First, create a package named <code>pkg_task2</code>, within your catkin workspace. Make sure you update your <code>CMakeLists.txt</code> and <code>package.xml</code> just like in previous tutorials.</p>
</li>
<li>
<p>Also create a <code>action</code> folder and create <code>DrawShape.action</code> file. It should have a string named ‘shape’ and integer ‘radius’ as goals, float variables ‘side_length’ and ‘interior_angle’ as results. You can leave the feedback portion as empty if you want.</p>
</li>
<li>
<p>After completing the <code>.action</code> file make sure you compile and source the package once again.</p>
</li>
</ol>
<pre><code class="language-bash">cd ~/workspace
catkin catkin_make
source devel/setup.bash

</code></pre>
<ol start="4">
<li>
<p>Within this package, you should have a <code>scripts</code> folder inside which you’ll create two python scripts, named <code>shape_server.py</code> and <code>shape_client.py</code>.</p>
</li>
<li>
<p>After completing the python script. Make it executable, if it isn’t already. To do that, enter the following code.</p>
</li>
</ol>
<pre><code class="language-bash">chmod +x ~/catkin_ws/src/pkg_task0/scripts/node_turtle_revolve.py

</code></pre>
<ol start="6">
<li>Before executing make sure that <code>roscore</code> is running along with <code>turtlesim_node</code>. You can either run them in separate terminals or simply create a <code>task2.launch</code> file inside the <code>~/catkin_ws/src/pkg_task0/launch/</code> folder. Launch file can run multiple nodes unlike a python/cpp script. Run the launch file, enter:</li>
</ol>
<pre><code class="language-bash">roslaunch pkg_task0 task0.launch 

</code></pre>
<ol start="7">
<li>
<p>The client side script will give shape ‘square’ and radius ‘1’ as goals to the server. The server should start drawing a square with the required dimensions.</p>
</li>
<li>
<p>After waiting for 2 seconds you should send another goal to draw a circle with radius ‘2’, which will preempt the current gaol and start drawing the circle</p>
</li>
</ol>
<h2 id="hints-1"><a class="header" href="#hints-1">Hints</a></h2>
<ol>
<li>
<p>If you are not comfortable with creating scripts from scratch you can always take help from previous tutorials covered.</p>
</li>
<li>
<p>Use linear velocity to draw straight lines and angular velocity to rotate at vertices.</p>
</li>
<li>
<p>You should try to publish the velocities until the errors are very low. For Example:</p>
</li>
</ol>
<pre><code class="language-python"># This is just and example

while (error_distance &gt; minimum_error):
	move towards objective
	error_distance = objective.distance - current_position

while (error_theta &gt; minimum_error):
	rotate towards objective
	error_theta = objective.theta - current_theta

</code></pre>
<ol start="4">
<li>To wait for a certain time limit you can use rospy.Rate() function, for example:</li>
</ol>
<pre><code class="language-python">r = rospy.Rate(1) # 1 Hz (frequency)
r.sleep() # sleep for 1 second

</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-1"><a class="header" href="#expected-output-1">Expected Output</a></h1>
<ul>
<li>
<p>If you draw a square it should look something like this.
<img src="tasks/task_2/task2_output.gif" alt="task2_output_gif" /></p>
</li>
<li>
<p>This can be considered as a valid output or end result.
<img src="tasks/task_2/task2_result.png" alt="result" /></p>
</li>
<li>
<p>To know whether the nodes are talking to each other as expected one can use the command <code>rqt_graph</code>. Below, you can find an expected graph for this task.
<img src="tasks/task_2/rqt_graph_task2.png" alt="rqt_graph" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-1"><a class="header" href="#recording-logs-1">Recording Logs</a></h1>
<ul>
<li>
<p>ROS allows us to record a log of the messages that occurred in a given time period. This is like recording a data stream. The ROS utility which does this is called rosbag, and the command to capture the data is <code>rosbag record</code>.</p>
</li>
<li>
<p>Create a folder called bagfiles in your package as a save destination for the bag files.</p>
</li>
<li>
<p>You can run the rosbag record command separately on the command line. But to not loose any data you will have to start recording precisely at the same moment your turtle starts moving. Hence it is a much more preferable option to include the rosbag recording in your launch file itself.</p>
</li>
<li>
<p>Add the following lines to your launch file to have the rosbag record run in parallel with your task. Some parameters are explained below:</p>
</li>
</ul>
<pre><code class="language-xml">  &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
  &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
  &lt;arg name=&quot;rec_name&quot; default=&quot;record.bag&quot;/&gt;

  &lt;group if=&quot;$(arg record)&quot;&gt;
      &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
          args=&quot;record -O $(find pkg_task2)/bagfiles/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /DrawShape/status /DrawShape/goal /DrawShape/feedback /DrawShape/result&quot; output=&quot;screen&quot; /&gt;
  &lt;/group&gt;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Make sure you have added these line before </launch> line. And the 3 nodes, the turtlesim, teleop_key and your python script node, are already present within this launch file, for desire recording.</p>
</blockquote>
<ul>
<li>The <code>arg_name</code> tags are roslaunch parameters, meaning they can be called while calling your roslaunch file, for example:</li>
</ul>
<pre><code class="language-bash">roslaunch pkg_task2 task_2.launch record:=true rec_name:=turtle_record.bag

</code></pre>
<ul>
<li>
<p>This command will..</p>
<ul>
<li>Start recording.</li>
<li>Should start turtlesim and turtle_teleop_key node.</li>
<li>Should start your python script node.</li>
<li>And name the resultant bag file as my_turtle.bag.</li>
</ul>
</li>
</ul>
<p>while still retaining the default value (in seconds) for the duration parameter.</p>
<p>Thus using these parameters along with your launch file will record a bag file of appropriate <code>duration</code>. Also, Make sure that the task is completed within the recording duration. If not then shorten the duration during which you run turtle1 using teleop_key.</p>
<blockquote>
<p><strong>Note</strong>: bag files with the same name will be overwritten by the rosbag utility without a prompt/warning. Make sure you provide proper name for each iteration if you want to save them all.</p>
</blockquote>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-1"><a class="header" href="#solution-1">Solution</a></h1>
<blockquote>
<p><strong>Note</strong>: Remove this md page from mdbook and delete scripts from src/tasks/task0/ It shows one of the possible solution with autoeval script.</p>
</blockquote>
<p><code>task_2.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
  
  &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim_node&quot;&gt;
      &lt;param name=&quot;/turtlesim_node/background_r&quot; value=&quot;34&quot; /&gt;
      &lt;param name=&quot;/turtlesim_node/background_g&quot; value=&quot;139&quot; /&gt;
      &lt;param name=&quot;/turtlesim_node/background_b&quot; value=&quot;34&quot; /&gt;
      &lt;param name=&quot;/background_r&quot; value=&quot;34&quot; /&gt;
      &lt;param name=&quot;/background_g&quot; value=&quot;139&quot; /&gt;
      &lt;param name=&quot;/background_b&quot; value=&quot;34&quot; /&gt;
  &lt;/node&gt;

  &lt;node name=&quot;DrawShape&quot; type=&quot;shape_server.py&quot; pkg=&quot;pkg_task2&quot;/&gt;
  &lt;node name=&quot;shape_client_py&quot; type=&quot;shape_client.py&quot; pkg=&quot;pkg_task2&quot;/&gt;

  &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
  &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
  &lt;arg name=&quot;rec_name&quot; default=&quot;record.bag&quot;/&gt;

  &lt;group if=&quot;$(arg record)&quot;&gt;
      &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
          args=&quot;record -O $(find pkg_task2)/bagfiles/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /DrawShape/status /DrawShape/goal /DrawShape/feedback /DrawShape/result&quot; output=&quot;screen&quot; /&gt;
  &lt;/group&gt;


&lt;/launch&gt;

</code></pre>
<center><a href="tasks/task_2/tasks/task_2/task_2.launch" download><button>Download_launch_file</button></a></center>
<p><code>shape_server.py</code></p>
<pre><code class="language-python">	#! /usr/bin/env python3

  import rospy
  import actionlib
  import pkg_task2.msg
  import math
  import angles
  from geometry_msgs.msg import Twist
  from turtlesim.msg import Pose

  class ShapeAction:
  	# create messages that are used to publish feedback/result
  	_feedback = pkg_task2.msg.DrawShapeFeedback()
  	_result = pkg_task2.msg.DrawShapeResult()

  	def __init__(self, name):
  		self._action_name = name
  		rospy.Subscriber('/turtle1/pose', Pose, self.turtle_pose_cb)
  		self.vel_pub = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)
  		self.vel_msg = Twist()
  		self._as = actionlib.SimpleActionServer(self._action_name, pkg_task2.msg.DrawShapeAction, execute_cb=self.execute_cb, auto_start = False)
  		self._as.start()
  		rospy.loginfo('Server Started.')

  	def execute_cb(self, goal):
  		success = True
  		if goal.shape == 'square':
  			# helper variables
  			r = rospy.Rate(1)
  			edge_len = math.sqrt(2)*goal.radius
  			self._result.side_length = edge_len
  			self._result.interior_angle = math.pi/2
  			l_scale = 6.0
  			a_scale = 6.0
  			min_error = 0.00001
  			
  			# starting execution
  			rospy.loginfo('Executing, drawing a square with edge length %f', edge_len)
  			for edge in range(4): # drawing individual edges
  				# check that preempt has not been requested by the client
  				if self._as.is_preempt_requested():
  					rospy.loginfo('%s: Preempted' % self._action_name)
  					self._as.set_preempted()
  					success = False
  					break

  				start_x = self.turtle_x
  				start_y = self.turtle_y
  				start_theta = self.turtle_theta

  				rospy.loginfo('Rotating...')
  				theta_error = angles.normalize_angle_positive(math.pi - self._result.interior_angle - (self.turtle_theta - start_theta))
  				while (theta_error &gt; min_error):
  					self.vel_msg.linear.x = 0
  					self.vel_msg.angular.z = theta_error*a_scale
  					self.vel_pub.publish(self.vel_msg)
  					theta_error = angles.normalize_angle_positive(math.pi - self._result.interior_angle - (self.turtle_theta - start_theta))

  				rospy.loginfo('Forward march!')
  				dis_error = edge_len - abs(math.sqrt((start_x - self.turtle_x)*(start_x - self.turtle_x) + (start_y - self.turtle_y)*(start_y - self.turtle_y)))
  				while (dis_error &gt; min_error):
  					self.vel_msg.linear.x = dis_error*l_scale
  					self.vel_msg.angular.z = 0
  					self.vel_pub.publish(self.vel_msg)
  					dis_error = edge_len - abs(math.sqrt((start_x - self.turtle_x)*(start_x - self.turtle_x) + (start_y - self.turtle_y)*(start_y - self.turtle_y)))
  				
  				self._feedback.percent = 25.0+25.0*edge
  				self._as.publish_feedback(self._feedback)
  		elif goal.shape == 'circle':
  			circumference = 2*math.pi*goal.radius
  			rospy.loginfo('Executing, drawing a circle with circumference %f', circumference)
  			self.vel_msg.linear.x = circumference
  			self.vel_msg.angular.z = 2*math.pi
  			self.vel_pub.publish(self.vel_msg)
  			self._result.side_length = circumference
  			self._result.interior_angle = 0

  		if success:
  			rospy.loginfo('%s: Succeeded' % self._action_name)
  			self._as.set_succeeded(self._result)

  	def turtle_pose_cb(self, pose):
  		self.turtle_x = pose.x
  		self.turtle_y = pose.y
  		self.turtle_theta = pose.theta
  		self.l_vel = pose.linear_velocity
  		self.a_vel = pose.angular_velocity

  if __name__ == '__main__':
  	rospy.init_node('DrawShape')
  	server = ShapeAction(rospy.get_name())
  	rospy.spin()
</code></pre>
<center><a href="tasks/task_2/tasks/task_2/shape_server.py" download><button>Download_server_script</button></a></center>
<p><code>shape_client.py</code></p>
<pre><code class="language-python">	#! /usr/bin/env python3

  import rospy
  import actionlib
  import pkg_task2.msg

  def shape_client():
  	client = actionlib.SimpleActionClient('DrawShape', pkg_task2.msg.DrawShapeAction)
  	rospy.loginfo('client ready.... waiting for server')
  	# Waits until the action server has started up and started
  	# listening for goals.
  	client.wait_for_server()

  	# Creates a goal to send to the server
  	rospy.loginfo('Sending gaol1...')
  	goal = pkg_task2.msg.DrawShapeGoal()
  	goal.shape = 'square'
  	goal.radius = 1
  	# Sends goal to the action server
  	client.send_goal(goal)


  	r = rospy.Rate(0.25)
  	r.sleep()
  	rospy.loginfo('Sending gaol2...')
  	goal.shape = 'circle'
  	goal.radius = 2
  	client.send_goal(goal)

  	# wait for ther server to finish performing the action
  	client.wait_for_result()

  	# return result
  	return client.get_result()

  if __name__ == '__main__':
  	try:
  		# Initializes a rospy node so that the SimpleActionClient can
  		rospy.init_node('shape_client_py')
  		result = shape_client()
  		rospy.loginfo(&quot;Result: side length = %f, interior angle = %f&quot; % (result.side_length, result.interior_angle))
  	except:
  		rospy.loginfo('program interrupted before completion')

</code></pre>
<center><a href="tasks/task_2/tasks/task_2/shape_client.py" download><button>Download_client_script</button></a></center>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="autoeval-script-1"><a class="header" href="#autoeval-script-1">Autoeval script</a></h1>
<blockquote>
<p><strong>Note</strong>: Save this file in a ROS package scripts folder. Then to run this script, run in terminal rosrun <pkg-name> autoeval.py. TThis script prints the result in the terminal window.
<code>autoeval.py</code></p>
</blockquote>
<pre><code class="language-python">	#!/usr/bin/env python3
  import glob
  import rosbag
  import math
  import csv

  # USAGE: rosrun pkg_task2 autoeval.py
  # This file will print results on the terminal window


  def main():
  	bag_files = []
  	is_passed = True
  	# Change this path to where all bag files are located.
  	path = &quot;/home/ubuntu/workspace/src/pkg_task2/bagfiles&quot;
  	for file in glob.glob(path + &quot;/*.bag&quot;):
  		bag_files.append(file)

  	# iterate through each file
  	for file in bag_files:
  		bag = rosbag.Bag(file)
  		# look throuhg topics
  		topics = bag.get_type_and_topic_info()[1].keys()
  		if '/turtle1/pose' and '/turtle1/cmd_vel' and '/DrawShape/status' and '/DrawShape/goal' and '/DrawShape/feedback' and '/DrawShape/result' in topics:
  			is_topic_present = True
  		else:
  			is_topic_present = False
  			print('topic not present')
  			is_passed = False

  		count = [0, 0, 0, 0]
  		last_val = 0
  		for topic, msg, t in bag.read_messages(topics=['/DrawShape/status']):
  			if not msg.status_list:
  				continue
  			if msg.status_list[0].status &lt; last_val:
  				print('last_val')
  				is_passed = False
  				break
  			last_val = msg.status_list[0].status
  			count[last_val] = count[last_val]+1

  		if count[1] == 0 or count[2] == 0 or count[3] == 0:
  			print('count')
  			is_passed = False

  		circle_mov = 0
  		square_mov = 0
  		for topic, msg, t in bag.read_messages(topics=['/turtle1/cmd_vel']):
  			if msg.linear.x != 0 and msg.angular.z != 0:
  				circle_mov = circle_mov+1
  			elif msg.linear.x != 0 and msg.angular.z == 0:
  				square_mov = square_mov+1

  		if square_mov &gt;= 1 and circle_mov &gt;= 1:
  			is_passed = True
  		else:
  			print(square_mov, circle_mov, 'sc')
  			is_passed = False

  		if is_topic_present == True and is_passed == True:
  			print(file + ' Result: passed!')
  		else:
  			print(file + ' Result: failed!')

if __name__ == '__main__':
  main()
</code></pre>
<center><a href="tasks/task_2/tasks/task_2/autoeval.py" download><button>Download</button></a><center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-on-gazebo"><a class="header" href="#task-on-gazebo">Task on Gazebo</a></h1>
<h2 id="welcome-to-task-on-gazebo-"><a class="header" href="#welcome-to-task-on-gazebo-">Welcome to Task on Gazebo !!!</a></h2>
<hr />
<p>The aim of this task is to make you familiar with Gazebo simulator, urdf, rviz and gazebo plugins. You need to install the mentioned software &amp; models by running the provided instructions in the <strong>provided sequence only</strong>; and if any error occurs at any step, please don <strong>not</strong> proceed unless the error has been rectified from your end.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-2"><a class="header" href="#problem-statement-2">Problem Statement</a></h1>
<ul>
<li>
<p><strong>Objective</strong>: The objective of this task is to create a spherical bowling ball bot in urdf and use it to do an automatic strike in bowling game.</p>
</li>
<li>
<p><strong>Bowling ball Specifications</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Value</th></tr></thead><tbody>
<tr><td>Mass</td><td>8.0</td></tr>
<tr><td>Radius</td><td>0.2</td></tr>
<tr><td>ixx</td><td>0.03872</td></tr>
<tr><td>ixy</td><td>0.004</td></tr>
<tr><td>ixz</td><td>0.005</td></tr>
<tr><td>iyy</td><td>0.03872</td></tr>
<tr><td>iyz</td><td>0.003</td></tr>
<tr><td>izz</td><td>0.03872</td></tr>
</tbody></table>
</div></li>
<li>
<p>The ball needs to spawned at <strong>(x=0, y=0, z=0.5)</strong>.</p>
<blockquote>
<p><strong>Note</strong>: You’re allowed to choose any color/texture for bowling ball.</p>
</blockquote>
</li>
<li>
<p><strong>Launching the game environment</strong></p>
<p><code>bowling_game.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;

    &lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;
    &lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; default=&quot;true&quot;/&gt;
    &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;
    &lt;arg name=&quot;headless&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;extra_gazebo_args&quot; default=&quot;--verbose&quot;/&gt;

    &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;
        &lt;arg name=&quot;world_name&quot; value=&quot;$(find pkg_gazebo)/worlds/bowling_empty.world&quot;/&gt;
        &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;
        &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;
        &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot;/&gt;
        &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(arg use_sim_time)&quot;/&gt;
        &lt;arg name=&quot;headless&quot; value=&quot;$(arg headless)&quot;/&gt;
        &lt;arg name=&quot;extra_gazebo_args&quot; value=&quot;$(arg extra_gazebo_args)&quot;/&gt;
    &lt;/include&gt;

&lt;/launch&gt;
</code></pre>
<p>To load the bowling ball game environment. Launch this file <code>bowling_game.launch</code></p>
<pre><code class="language-bash">roslaunch pkg_gazebo bowling_game.launch
</code></pre>
<p><img src="tasks/task_bowling_game/bowling-game-empty.png" alt="bowling-game-empty" /></p>
</li>
</ul>
<h2 id="procedure-2"><a class="header" href="#procedure-2">Procedure</a></h2>
<ol>
<li>
<p>You have to use the package <code>pkg_gazebo</code> we created in the <a href="tasks/task_bowling_game/../../ROS_with_Gazebo/installation.html">learn section</a>.</p>
</li>
<li>
<p>You need to create a spherical bowling ball using urdf file in <code>urdf directory</code> in <code>pkg_gazebo</code> package.</p>
</li>
<li>
<p>You would need to add <strong>effort controllers</strong> to control the bowling ball from the python script. </p>
</li>
<li>
<p>Create a python script which would automatically control the bowling ball to do a strike.</p>
</li>
<li>
<p>Finally, use a launch file <code>bowling_game_solution.launch</code> to load the bowling game environment, load the bowling ball, and the required nodes to do an automatic strike.</p>
<p>Your launch file <code>bowling_game_solution.launch</code> would look something like this.</p>
<p><code>bowling_game_solution.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;

&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;
&lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;use_sim_time&quot; default=&quot;true&quot;/&gt;
&lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;
&lt;arg name=&quot;headless&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;model&quot; default=&quot;$(find pkg_gazebo)/urdf/bowling_ball_bot.urdf.xacro&quot;/&gt;
&lt;arg name=&quot;extra_gazebo_args&quot; default=&quot;--verbose&quot;/&gt;

&lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;
    &lt;arg name=&quot;world_name&quot; value=&quot;$(find pkg_gazebo)/worlds/bowling_empty.world&quot;/&gt;
    &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;
    &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;
    &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(arg use_sim_time)&quot;/&gt;
    &lt;arg name=&quot;headless&quot; value=&quot;$(arg headless)&quot;/&gt;
    &lt;arg name=&quot;extra_gazebo_args&quot; value=&quot;$(arg extra_gazebo_args)&quot;/&gt;
&lt;/include&gt;

&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(arg model)&quot;/&gt;
&lt;rosparam file=&quot;$(find pkg_gazebo)/config/effort_control.yaml&quot; command=&quot;load&quot;/&gt;

&lt;node name=&quot;controller_spawner&quot; pkg =&quot;controller_manager&quot; type=&quot;spawner&quot; ns=&quot;/bowling_game&quot; args=&quot;
x_effort_joint_controller y_effort_joint_controller z_effort_joint_controller joint_state_controller&quot;/&gt;

&lt;!-- push robot_description to factory and spawn bowling ball in gazebo --&gt;
&lt;node name=&quot;urdf_spawner&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot;
        args=&quot;-x 0 -y 0 -z 0.5 -unpause -urdf -model robot -param robot_description&quot; respawn=&quot;false&quot; output=&quot;screen&quot; /&gt;

&lt;!-- node to control the bowling ball --&gt;
&lt;node name=&quot;node_control_bowling_game&quot; pkg=&quot;pkg_gazebo&quot; type=&quot;node_control_bowling_ball.py&quot;/&gt;

&lt;/launch&gt;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Your launch file could be different than this. But, keep the naming same as <code>bowling_game_solution.launch</code> as we would use this launch file to check your solution.</p>
</blockquote>
</li>
</ol>
<h2 id="hint"><a class="header" href="#hint">Hint</a></h2>
<ul>
<li>
<p>Try to make a <strong>shoulder joint</strong> in urdf so that rotation is possible in all directions. You can create some dummy links to do this.</p>
</li>
<li>
<p>You could reset the world in gazebo for testing purposes.</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Strike here means knocking down all the 10 pins using the bowling ball.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-2"><a class="header" href="#expected-output-2">Expected Output</a></h1>
<ul>
<li>The following video can be considered as a valid output.</li>
</ul>
<center><iframe width="824" height="476"
src="https://www.youtube.com/embed/7zDawMZmOmM">
</iframe></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-2"><a class="header" href="#recording-logs-2">Recording Logs</a></h1>
<ul>
<li>
<p>For recording the bags in this Task, you can refer to this <a href="tasks/task_bowling_game/../task0/recording-logs.html">section</a>.</p>
</li>
<li>
<p>This launch file will specifically make use of <code>/gazebo/link_states</code> ROS topic so make sure to specify these as shown below.</p>
</li>
<li>
<p>We recommend you to add the following in your <code>bowling_game_solution.launch</code> in order to record everything properly as soon as you start other nodes.</p>
</li>
<li>
<p>Make sure to create a directory called <code>bag_files</code> within your <code>pkg_gazebo</code> package where your bag files will get stored.</p>
<pre><code class="language-xml">&lt;!-- Recording Bag File for Submission --&gt;
    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;bowling.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_pick&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
    args=&quot;record -O $(find pkg_gazebo)/bag_files/$(arg rec_name) --chunksize=10 /gazebo/link_states&quot; output=&quot;screen&quot;/&gt;
    &lt;/group&gt;
</code></pre>
</li>
<li>
<p>Verify that your bag file is properly recorded by using the <code>rosbag info</code> command followed by the absolute or relative path of the file.</p>
</li>
<li>
<p>You can use the <code>rostopic echo -b bowling.bag /gazebo/link_states</code> command to display the messages from the topic onto your bag file.</p>
</li>
<li>
<p>If you want to record the bag file needed for submission you would have to run the following command.</p>
<pre><code class="language-bash">roslaunch pkg_gazebo bowling_game_solution.launch record:=true rec_name:=bowling.bag
</code></pre>
</li>
<li>
<p>If you just want to run your implementation without recording a bag file. Do the following.</p>
<pre><code class="language-bash">roslaunch pkg_gazebo bowling_game_solution.launch
</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-2"><a class="header" href="#solution-2">Solution</a></h1>
<ul>
<li>
<p>Complete solution is in this zip file =&gt; <a href="tasks/task_bowling_game/pkg_gazebo.zip" download><button>Download</button></a></p>
</li>
<li>
<p>To run the solution, launch this file.</p>
<pre><code class="language-bash">roslaunch pkg_gazebo bowling_game_solution.launch
</code></pre>
</li>
</ul>
<br/>
<p>This file defines the effort controller to move the bowling ball in 3-axis.</p>
<p><code>effort_control.yaml</code></p>
<pre><code class="language-yaml">bowling_game:
  # Publish all joint states -----------------------------------
  joint_state_controller:
    type: &quot;joint_state_controller/JointStateController&quot;
    publish_rate: 50

  # Position Controllers ---------------------------------------
  x_effort_joint_controller:
    type: &quot;effort_controllers/JointEffortController&quot;
    joint: rotate_x
    pid: {p: 100.0, i: 0.01, d: 10.0}

  y_effort_joint_controller:
    type: &quot;effort_controllers/JointEffortController&quot;
    joint: rotate_y
    pid: {p: 100.0, i: 0.01, d: 10.0}

  z_effort_joint_controller:
    type: &quot;effort_controllers/JointEffortController&quot;
    joint: rotate_z
    pid: {p: 100.0, i: 0.01, d: 10.0}

</code></pre>
<center><a href="tasks/task_bowling_game/effort_control.yaml" download><button>Download</button></a></center>
<br/>
<p>This node controls the bowling ball to do a Strike!</p>
<p><code>node_control_bowling_ball.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

import rospy

from std_msgs.msg import Float64
from sensor_msgs.msg import JointState

import math


class BowlingBall:
    def __init__(self):
        rospy.init_node('control_bowling_ball', anonymous=True)

        self.sub_ = rospy.Subscriber(
            '/bowling_game/joint_states', JointState, self.clbk_pos)

        self.pub_x = rospy.Publisher(
            '/bowling_game/x_effort_joint_controller/command', Float64, queue_size=1)

        self.pub_y = rospy.Publisher(
            '/bowling_game/y_effort_joint_controller/command', Float64, queue_size=1)

        self.pub_z = rospy.Publisher(
            '/bowling_game/z_effort_joint_controller/command', Float64, queue_size=1)

        self.ball_state = JointState()
        self.pos_y = 0
        self.rate = rospy.Rate(20)  # Rate in Hz

    def clbk_pos(self, msg):
        self.ball_state.position = msg.position
        self.pos_y = msg.position[1]

    def knock_pins(self):
        # Infinite Loop
        i = 0
        while not rospy.is_shutdown():
            if i &lt; 5:
                self.pub_x.publish(3.5)
            print(self.pos_y)
            if self.pos_y &lt; -0.1:
                self.pub_y.publish(-0.5)
            elif self.pos_y &gt; -0.1:
                self.pub_y.publish(0.5)
            self.rate.sleep()

    def __del__(self):
        self.sub_.unregister()
        rospy.loginfo(&quot;Object of class BowlingBall deleted.&quot;)


def main():
    b = BowlingBall()
    b.knock_pins()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

</code></pre>
<center><a href="tasks/task_bowling_game/node_control_bowling_ball.py" download><button>Download</button></a></center>
<br/>
<p>This node shows the video of the bowling ball coming towards the bowling pins. Looks cool!</p>
<p><code>node_bowling_pin_cam.py</code></p>
<pre><code class="language-python">#! /usr/bin/env python3

import rospy

from std_msgs.msg import Float64
from sensor_msgs.msg import JointState
from sensor_msgs.msg import Image

from cv_bridge import CvBridge, CvBridgeError
import math
import cv2


class DepthCamera(object):
    def __init__(self):
        rospy.init_node('node_live_cam', anonymous=True)

        self.bridge = CvBridge()

        self.sub_cam = rospy.Subscriber(
            &quot;/depth_camera/color/image_raw&quot;, Image, self.clbk_cam)

        self.image = None
        self.rate = rospy.Rate(20)  # Rate in Hz

    def clbk_cam(self, msg):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, &quot;bgr8&quot;)
        except CvBridgeError as err:
            rospy.logerr(err)

        self.image = cv_image
        cv2.imshow(&quot;bowling pin cam&quot;, self.image)
        cv2.waitKey(1)

    def work(self):
        # Infinite Loop
        while not rospy.is_shutdown():
            self.rate.sleep()

    def __del__(self):
        self.sub_cam.unregister()
        rospy.loginfo(&quot;Object of class BowlingBall deleted.&quot;)


def main():
    dc = DepthCamera()
    dc.work()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

</code></pre>
<center><a href="tasks/task_bowling_game/node_bowling_pin_cam.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoevaluation-script"><a class="header" href="#autoevaluation-script">Autoevaluation Script</a></h1>
<h2 id="how-to-use"><a class="header" href="#how-to-use">How to use</a></h2>
<p>This script can take any number of bag files stored in <code>/home/ubuntu/workspace/src/pkg_gazebo/bag_files</code>
and create a <code>results.csv</code> output which will show the result of bowling ball game bag files.</p>
<pre><code class="language-bash">rosrun pkg_gazebo autoeval.py
</code></pre>
<p>This will generate <code>results.csv</code> in bag files location.</p>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv
import tf
from operator import countOf, itemgetter

# USAGE: rosrun pkg_gazebo autoeval.py
# ROS Topics required: /gazebo/link_states


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/pkg_gazebo/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)
        data_writer.writerow(['Filename', 'Does bag files has rostopic?', 'Total Pins knocked',
                              'Strike', 'Remark'])

        # iterate through each file
        for file in bag_files:
            bag = rosbag.Bag(file)
            strike = False
            is_topic_present = False
            pins_knocked = 0
            # look throuhg topics
            topics = bag.get_type_and_topic_info()[1].keys()
            if '/gazebo/link_states' in topics:
                is_topic_present = True
            else:
                is_topic_present = False
                print('topic not present')
                strike = False

            for topic, msg, t in bag.read_messages(topics=['/gazebo/link_states']):
                # check the orientation of links
                rpy_list = []
                index = [i for i in range(2, 12)]
                bowling_pins_links = itemgetter(*index)(msg.pose)
                for pose in bowling_pins_links:
                    quaternion = (pose.orientation.x, pose.orientation.y,
                                  pose.orientation.z, pose.orientation.w)
                    rpy_list.append(tf.transformations.euler_from_quaternion(
                        quaternion))

            # check if all pins are knocked down
            strike = all(round(rpy[0], 2) != 1.57 for rpy in rpy_list)

            for rpy in rpy_list:
                if round(rpy[0], 2) != 1.57:
                    pins_knocked += 1

            if is_topic_present and strike:
                remark = &quot;Strike! All pins knocked down.&quot;
                print(file + ' Result: passed!')
            elif is_topic_present and pins_knocked &gt; 0:
                remark = str(pins_knocked) + &quot; pins knocked down!&quot;
            else:
                remark = &quot;Failed!&quot;
                print(file + ' Result: failed!')

            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], is_topic_present, pins_knocked, strike, remark])

        bag.close()
    data_file.close()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task_bowling_game/autoeval.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="micromouse-1"><a class="header" href="#micromouse-1">Micromouse</a></h1>
<p>Welcome to the Micromouse Mini-Project !!!</p>
<hr />
<p>The aim of this task is to make you familiar with creating your own robot in urdf and using that robot to solve a maze. You are free to use the robot in <a href="tasks/task_micromouse/../../Micromouse/creating_your_own_micromouse.html">Learn Section</a> or create your own robot.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-3"><a class="header" href="#problem-statement-3">Problem Statement</a></h1>
<ul>
<li>
<p><strong>Objective</strong>: The objective of this task is to code an autonomous self-contained bot on ROS to be simulated on Gazebo, Micromouse, which can find its way and get to the centre of a maze in the shortest possible time.</p>
</li>
<li>
<p><strong>Collision Avoidance</strong></p>
<ul>
<li>
<p>Collision avoidance can be done by using laser scan data.</p>
</li>
<li>
<p>The run will be considered invalid if there is any collision with the walls of the maze.</p>
</li>
</ul>
</li>
<li>
<p>The micromouse should be spawned at <strong>x=-1.35</strong> and <strong>y=1.35</strong>.</p>
</li>
<li>
<p><strong>Simulation Time</strong></p>
<ul>
<li>In this task simulation time will be considered for grading. So, the teams must make sure to keep the simulation time as low as possible by quickly navigating the maze.</li>
</ul>
</li>
<li>
<p><strong>Odom</strong></p>
<ul>
<li>
<p>Odometry is to be used by the micromouse to estimate its position and orientation relative to a starting location.</p>
</li>
<li>
<p>Use <code>/micromouse/odom</code> rostopic to publish odom data.</p>
</li>
</ul>
</li>
<li>
<p><strong>Laser Scan</strong></p>
<ul>
<li>
<p>The laser scan can be used to detect walls or obstacles around the micromouse robot.</p>
</li>
<li>
<p>Use <code>/micromouse/laser/scan</code> rostopic to publish laser scan data.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Only laser scan and odom data should be used to navigate the maze.</p>
</blockquote>
<h2 id="procedure-3"><a class="header" href="#procedure-3">Procedure</a></h2>
<ol>
<li>
<p><strong>Optional</strong>: Create your own micromouse robot model in urdf.</p>
</li>
<li>
<p>Create a launch file <code>micromouse_solution.launch</code> which should launch the gazebo environment of maze, spawn the micromouse robot and all the nodes necessary to solve the problem statement. We’ll use this launch file to check your solution.</p>
</li>
<li>
<p>For reference you can check the <code>micromouse.launch</code> file.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>:You can make any number of python nodes to solve the problem statement.</p>
</blockquote>
<ol>
<li>
<p>The team would also have to create a <code>bag_files</code> folder in <code>micromouse</code> package for storing the bag file.</p>
</li>
<li>
<p>Instructions to record bag file is given in Submission Instruction section.</p>
</li>
</ol>
<br/>
<h2 id="hint-1"><a class="header" href="#hint-1">Hint</a></h2>
<p>There are many path planning algorithms like <strong><code>BFS</code></strong>, <strong><code>DFS</code></strong>, <strong><code>Djikstra</code></strong>, <strong><code>A-star</code></strong>. You will be able to find plenty of online resources for the same.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-3"><a class="header" href="#expected-output-3">Expected Output</a></h1>
<ul>
<li>The following video can be considered as a valid output.</li>
</ul>
<center><iframe width="824" height="476"
src="https://www.youtube.com/embed/eMSUBrvtv6U">
</iframe></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-3"><a class="header" href="#recording-logs-3">Recording Logs</a></h1>
<ul>
<li>
<p>For recording the bags in this Task, you can refer to this <a href="tasks/task_micromouse/../task0/recording-logs.html">section</a>.</p>
</li>
<li>
<p>This launch file will specifically make use of <code>/micromouse/odom</code> and <code>/micromouse/laser/scan</code> ROS topics so make sure to specify these as shown below.</p>
</li>
<li>
<p>We recommend you to add the following in your <code>micromouse_solution.launch</code> in order to record everything properly as soon as you start other nodes.</p>
</li>
<li>
<p>Make sure to create a directory called <code>bag_files</code> within your <code>micromouse</code> package where your bag files will get stored.</p>
<pre><code class="language-xml">&lt;!-- Recording Bag File for Submission --&gt;
    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;mm.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_pick&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
    args=&quot;record -O $(find micromouse)/bag_files/$(arg rec_name) --chunksize=10 /micromouse/odom /micromouse/laser/scan&quot; output=&quot;screen&quot;/&gt;
    &lt;/group&gt;
</code></pre>
</li>
<li>
<p>Verify that your bag file is properly recorded by using the <code>rosbag info</code> command followed by the absolute or relative path of the file.</p>
</li>
<li>
<p>You can use the <code>rostopic echo -b mm.bag /micromouse/odom</code> command to display the messages from the topic onto your bag file.</p>
</li>
<li>
<p>If you want to record the bag file needed for submission you would have to run the following command.</p>
<pre><code class="language-bash">roslaunch micromouse micromouse_solution.launch record:=true rec_name:=mm.bag
</code></pre>
</li>
<li>
<p>If you just want to run your implementation without recording a bag file. Do the following.</p>
<pre><code class="language-bash">roslaunch micromouse micromouse_solution.launch
</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="not-for-sharing"><a class="header" href="#not-for-sharing">NOT FOR SHARING</a></h1>
<ul>
<li>This directory has the solution and autoevaluations scripts.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-3"><a class="header" href="#solution-3">Solution</a></h1>
<p>Solution package can be downloaded from here. =&gt;  <a href="tasks/task_micromouse/NOT_FOR_SHARING/micromouse.zip" download><button>Download</button></a></p>
<h3 id="to-run-the-solution"><a class="header" href="#to-run-the-solution">To run the solution.</a></h3>
<ol>
<li>
<p>Launch this file <code>micromouse_solution.launch</code>. This will spawn the micromouse robot model in maze and also run nodes -&gt; <code>maze_algorithms.py</code>, <code>node_micromouse.py</code>.</p>
<pre><code class="language-bash">roslaunch micromouse micromouse_solution.launch
</code></pre>
</li>
<li>
<p>Call this service to start the run.</p>
<pre><code class="language-bash">rosservice call /go_to_point_switch &quot;data: true&quot; 
</code></pre>
</li>
</ol>
<h3 id="scripts"><a class="header" href="#scripts">Scripts</a></h3>
<p><code>maze_algrorithm.py</code></p>
<p>This script will create a maze using laser scan and odom data and publish a destination point using custom message that can be reached while avoiding obstacles.</p>
<pre><code class="language-python">#! /usr/bin/env python3

# maintain maze state in 2d numpy array. Subscribe to micromouse/odom and micromouse/laser/scan.
# Iterate through all 360 degrees and find (x,y) from
# distances in micromouse/laser/scan topic. Add some constant for each
# iteration that a particular grid has been exposed.


import message_filters
from nav_msgs.msg import Odometry
from micromouse.msg import dest

import rospy
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Int32
import tf

import math
import numpy as np

import maze_solver


class Maze:
    def __init__(self):
        # For debugging
        self.start_time = None

        # Maze parameters
        self.d = 0.012  # Wall thickness in m
        self.s = 0.18-self.d  # Side length of each grid square sans the walls
        self.N = 16  # Number of grid squares in one row
        # Ensure that: N*(s+d)+d = total side length of maze

        # Tunable heuristics
        self.confidence_threshold = 16
        self.lower_thres = 0.2
        self.upper_thres = 0.8
        self.center_precision = 0.04  # (metres)

        # Maze state and maze confidence matrices
        self.w = 2*self.N-1
        self.h = 2*self.N-1
        self.maze_size = [self.w, self.h]
        self.maze_state = np.zeros(self.maze_size)
        self.maze_state[1::2, 1::2] = 1  # Both i and j odd, lattice point
        self.maze_confidence = np.zeros(self.maze_size)
        self.maze_confidence[1::2, 1::2] = - \
            1  # Both i and j odd, lattice point
        # Both i and j even, empty grid cell
        self.maze_confidence[::2, ::2] = -1

        self.goal = None
        self.prev_goal = None

        # Remember start position
        self.start_pos = None
        self.first_callback = True

        # Switch between modes
        self.run_number = Int32()
        self.run_number.data = 1
        self.run_number_pub = rospy.Publisher(
            '/run_number', Int32, queue_size=1)
        self.run_number_pub.publish(self.run_number)

    def remap(self, t):
        '''
        remaps from range [-N*(s+d)/2, N*(s+d)/2] to [0, N]
        t can be either {x_wall, y_wall}
        '''
        return t/(self.s+self.d) + self.N/2

    def inverseRemap(self, T):
        return (T-self.N/2)*(self.s+self.d)

    def updateMazeConfidence(self, x, y):
        fx, ix = math.modf(x)
        fy, iy = math.modf(y)

        if (fx &lt; self.lower_thres or fx &gt; self.upper_thres) and (fy &lt; self.lower_thres or fy &gt; self.upper_thres):
            return

        elif (fx &lt; self.lower_thres and ix == 0) or \
             (fx &gt; self.upper_thres and ix == self.N-1) or \
             (fy &lt; self.lower_thres and iy == 0) or \
             (fy &gt; self.upper_thres and iy == self.N-1):
            return

        elif fx &lt; self.lower_thres:
            X = ix*2 - 1
            Y = iy*2
        elif fx &gt; self.upper_thres:
            X = ix*2 + 1
            Y = iy*2
        elif fy &lt; self.lower_thres:
            X = ix*2
            Y = iy*2 - 1
        elif fy &gt; self.upper_thres:
            X = ix*2
            Y = iy*2 + 1
        else:
            return

        X = int(X)
        Y = int(Y)

        # print(&quot;%f\t%f&quot; % (X,Y))
        try:
            if self.maze_confidence[X, Y] == -1:
                rospy.logfatal(&quot;Trying to update non-updatable grid&quot;)
                return

            if (self.maze_confidence[X, Y] &lt; self.confidence_threshold):
                self.maze_confidence[X, Y] += 1
                if (self.maze_confidence[X, Y] == self.confidence_threshold):
                    self.maze_state[X, Y] = 1
        except IndexError as error:
            # rospy.loginfo(&quot;IndexError on updating (%f,%f)&quot; % (x,y))
            pass

    def mazeCallback(self, odom, scan):
        if (odom is not None and scan is not None):
            # rospy.loginfo(&quot;Update requested&quot;)

            # Extract robot's (x,y,theta) from micromouse/odom
            x_bot = odom.pose.pose.position.x
            y_bot = odom.pose.pose.position.y
            quaternion = (
                odom.pose.pose.orientation.x,
                odom.pose.pose.orientation.y,
                odom.pose.pose.orientation.z,
                odom.pose.pose.orientation.w)
            rpy = tf.transformations.euler_from_quaternion(quaternion)
            theta_bot = rpy[2]

            if self.run_number != 1:
                # Obtain (x,y) of laser end-points from /scan + /odom
                laser_ranges = scan.ranges
                no_of_points = len(laser_ranges)
                max_range = scan.range_max

                # print(&quot;Bot pose: (%f,%f,%f)&quot; % (x_bot, y_bot, theta_bot*180/math.pi))

                for i in range(no_of_points):
                    angle = scan.angle_min + i*scan.angle_increment
                    radial_distance = laser_ranges[i]
                    # Eliminate infinity ranges(idk if this is actually needed, for safety)
                    if (radial_distance &lt;= max_range):
                        x_wall = x_bot + radial_distance * \
                            math.cos(theta_bot + angle)
                        y_wall = y_bot + radial_distance * \
                            math.sin(theta_bot + angle)
                        # print(&quot;Wall(laser): (%f,%f,%f)&quot; % (x_wall, y_wall, (theta_bot + angle)*180/math.pi))
                        # rospy.signal_shutdown(&quot;Debug over&quot;)
                        # return

                        # print(&quot;Global: %f\t%f&quot; % (x_wall, y_wall))
                        x_wall_remapped = self.remap(x_wall)
                        y_wall_remapped = self.remap(y_wall)
                        # print(&quot;[0,N]: %f\t%f&quot; % (x_wall_remapped, y_wall_remapped))

                        self.updateMazeConfidence(
                            x_wall_remapped, y_wall_remapped)

            # Breadth First Search

            # Coordinates in 16*16 representation
            # print(&quot;Bot pose: (%f,%f)&quot; % (x_bot, y_bot))
            x_bot_remapped = self.remap(x_bot)
            y_bot_remapped = self.remap(y_bot)

            # Coordinates in 31*31 maze_state representation
            X = int(x_bot_remapped)*2
            Y = int(y_bot_remapped)*2
            rospy.loginfo(&quot;Position: (%d,%d)&quot; % (X, Y))

            if self.first_callback:
                self.start_pos = [X, Y]
                self.start_time = rospy.get_time()
                self.first_callback = False
                # rospy.loginfo(self.start_pos)

            # Finding next point in bfs path
            if self.run_number.data % 2:
                # Odd numbered run
                # rospy.loginfo(&quot;From corner to center...&quot;)
                if X == 14 and Y == 14:
                    rospy.loginfo(&quot;Reached center(exploratory)!&quot;)
                    rospy.loginfo(rospy.get_time()-self.start_time)
                    # rospy.signal_shutdown(&quot;Time period over&quot;)
                    self.start_time = rospy.get_time()
                    self.run_number.data += 1
                    self.run_number_pub.publish(self.run_number)
                    return
                else:
                    goal_ = maze_solver.BFS(
                        self.maze_state, X, Y, 14, 14, self.w, self.h)

            else:
                # rospy.loginfo(&quot;Going back to corner...&quot;)
                if X == self.start_pos[0] and Y == self.start_pos[1]:
                    rospy.loginfo(&quot;Reached start corner&quot;)
                    rospy.loginfo(rospy.get_time()-self.start_time)
                    self.start_time = rospy.get_time()
                    self.run_number.data += 1
                    self.run_number_pub.publish(self.run_number)
                    return
                else:
                    goal_ = maze_solver.BFS(self.maze_state, X, Y, self.start_pos[0],
                                            self.start_pos[1], self.w, self.h)

            # Oh no!
            if goal_ == -1:
                rospy.logfatal(&quot;Path not found!&quot;)
                rospy.signal_shutdown(&quot;Too fast&quot;)
                return

            self.goal = [self.inverseRemap(T/2+0.5) for T in goal_]

            # Start from center of some square before pursuing new goal
            if self.prev_goal is not None and self.prev_goal != self.goal:
                desired_start = np.array(
                    [self.inverseRemap(T/2+0.5) for T in [X, Y]])
                actual_start = np.array([x_bot, y_bot])
                if np.sum(np.abs(desired_start - actual_start)) &gt; self.center_precision:
                    self.goal = desired_start
                    return

            self.prev_goal = self.goal[:]
            # print(&quot;Bot pose: (%d,%d)&quot; % (X, Y))
            # print(&quot;Goal: (%d,%d)&quot; % (goal_[0],goal_[1]))
            # print(&quot;Goal: (%f,%f)&quot; % (self.goal[0],self.goal[1]))

            # if (rospy.get_time()-self.start_time) &gt; 70:
            #   print(self.maze_confidence[12:19,12:19])
            #   np.savetxt('debug-confidence.txt', self.maze_confidence, delimiter='\t', fmt='% .0f')
            #   np.savetxt('debug-state.txt', self.maze_state, delimiter='\t', fmt='% .0f')
            # rospy.signal_shutdown(&quot;Time period over&quot;)
            # return


if __name__ == '__main__':
    try:
        rospy.init_node('maze_algorithms_node')  # , disable_signals=True)
        maze_obj = Maze()
        # maze_obj.start_time = rospy.get_time()
        while (rospy.get_time() == 0):  # Wait until nodes have loaded completely
            pass

        rospy.loginfo(&quot;Creating subscribers...&quot;)
        odom_sub = message_filters.Subscriber('/micromouse/odom', Odometry)
        scan_sub = message_filters.Subscriber(
            '/micromouse/laser/scan', LaserScan)
        rospy.loginfo(&quot;Done&quot;)

        rospy.loginfo(
            &quot;Creating time synchronizer between odom and laser scan...&quot;)
        ts = message_filters.ApproximateTimeSynchronizer(
            [odom_sub, scan_sub], queue_size=1, slop=0.1)
        ts.registerCallback(maze_obj.mazeCallback)
        rospy.loginfo(&quot;Done&quot;)

        rospy.loginfo(&quot;Creating publisher...&quot;)
        dest_pub = rospy.Publisher('/micromouse/dest', dest, queue_size=1)

        loop_rate = rospy.Rate(20)
        while not rospy.is_shutdown():
            # rospy.loginfo(&quot;Running&quot;)
            if maze_obj.goal is not None:
                msg = dest()
                msg.dest_x_coordinate = maze_obj.goal[0]
                msg.dest_y_coordinate = maze_obj.goal[1]
                dest_pub.publish(msg)
            loop_rate.sleep()

    except rospy.ROSInterruptException:
        rospy.loginfo(&quot;Node terminated&quot;)

</code></pre>
<br/>
<p><code>node_micromouse.py</code></p>
<p>This script will move the micromouse to the destination point generated by <code>maze_algorithms.py</code>.</p>
<pre><code class="language-bash">#! /usr/bin/env python3

# import ros stuff
import rospy

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist, Point
from nav_msgs.msg import Odometry
from micromouse.msg import dest
from tf import transformations
from std_srvs.srv import *

import math

active_ = False

# robot state variables
position_ = Point()
yaw_ = 0
# machine state
state_ = 0
# goal
desired_position_ = Point()
desired_position_.x = 0
desired_position_.y = 0
desired_position_.z = 0
# parameters
yaw_precision_ = math.pi / 90  # +/- 2 degree allowed
dist_precision_ = 0.01
# publishers
pub = None

# service callbacks


def go_to_point_switch(req):
    global active_
    active_ = req.data
    res = SetBoolResponse()
    res.success = True
    res.message = 'Done!'
    return res

# callbacks


def clbk_odom(msg):
    global position_
    global yaw_

    # position
    position_ = msg.pose.pose.position

    # yaw
    quaternion = (
        msg.pose.pose.orientation.x,
        msg.pose.pose.orientation.y,
        msg.pose.pose.orientation.z,
        msg.pose.pose.orientation.w)
    euler = transformations.euler_from_quaternion(quaternion)
    # fixing joint pos by subtracting 90 degrees because they're different in gazebo and ROS
    yaw_ = euler[2] - math.pi/2


def clbk_dest(msg):
    global desired_position_
    desired_position_.x = msg.dest_x_coordinate
    desired_position_.y = msg.dest_y_coordinate
    rospy.loginfo(msg)


def change_state(state):
    global state_
    state_ = state
    print('State changed to [%s]' % state_)


def normalize_angle(angle):
    if(math.fabs(angle) &gt; math.pi):
        angle = angle - (2 * math.pi * angle) / (math.fabs(angle))
    return angle


def fix_yaw(des_pos):
    global yaw_, pub, yaw_precision_, state_
    desired_yaw = math.atan2(des_pos.y - position_.y, des_pos.x - position_.x)
    err_yaw = normalize_angle(desired_yaw - yaw_)

    # rospy.loginfo(err_yaw)

    twist_msg = Twist()
    if math.fabs(err_yaw) &gt; yaw_precision_:
        twist_msg.angular.z = 0.3 if err_yaw &gt; 0 else -0.3

    pub.publish(twist_msg)

    # state change conditions
    if math.fabs(err_yaw) &lt;= yaw_precision_:
        print('Yaw error: [%s]' % err_yaw)
        change_state(1)


def go_straight_ahead(des_pos):
    global yaw_, pub, yaw_precision_, state_
    desired_yaw = math.atan2(des_pos.y - position_.y, des_pos.x - position_.x)
    err_yaw = desired_yaw - yaw_
    err_pos = math.sqrt(pow(des_pos.y - position_.y, 2) +
                        pow(des_pos.x - position_.x, 2))

    if err_pos &gt; dist_precision_:
        twist_msg = Twist()
        twist_msg.linear.x = 1.0
        # twist_msg.angular.z = 0.05 if err_yaw &gt; 0 else -0.05
        pub.publish(twist_msg)
    else:
        print('Position error: [%s]' % err_pos)
        change_state(2)

    # state change conditions
    if math.fabs(err_yaw) &gt; yaw_precision_:
        print('Yaw error: [%s]' % err_yaw)
        change_state(0)


def done():
    twist_msg = Twist()
    twist_msg.linear.x = 0
    twist_msg.angular.z = 0
    pub.publish(twist_msg)


def main():
    global pub, active_

    rospy.init_node('go_to_point')

    pub = rospy.Publisher('/micromouse/cmd_vel', Twist, queue_size=1)

    sub_odom = rospy.Subscriber('/micromouse/odom', Odometry, clbk_odom)

    sub_dest = rospy.Subscriber(
        '/micromouse/dest', dest, clbk_dest)

    srv = rospy.Service('go_to_point_switch', SetBool, go_to_point_switch)

    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        if not active_:
            continue
        else:
            if state_ == 0:
                fix_yaw(desired_position_)
            elif state_ == 1:
                go_straight_ahead(desired_position_)
            elif state_ == 2:
                done()
            else:
                rospy.logerr('Unknown state!')

        rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-evaluation"><a class="header" href="#auto-evaluation">Auto Evaluation</a></h1>
<h2 id="how-to-use-1"><a class="header" href="#how-to-use-1">How to use</a></h2>
<p>This script can take any number of bag files stored in <code>/home/ubuntu/workspace/src/micromouse/bag_files</code>
and create a <code>results.csv</code> output which will show the result of micromouse bag files.</p>
<pre><code class="language-bash">rosrun micromouse autoeval.py
</code></pre>
<p>This will generate <code>results.csv</code> in bag files location.</p>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun micromouse autoeval.py
# This file will print results on the terminal window


def remap(t):
    d = 0.012  # Wall thickness in m
    s = 0.18-d  # Side length of each grid square sans the walls
    N = 16  # Number of grid squares in one row
    return t/(s+d) + N/2


def calc_simulation_time(pos_time_list):
    '''Take space-time list of micromouse as argument and returns simulation
    time between the time micromouse starts moving till it reaches the centre
    of maze.'''
    start_pos = (pos_time_list[0][0], pos_time_list[0][1])
    if start_pos[0] == 0 and start_pos[1] == 30:
        is_spawned_at_correct_pos = True
    else:
        is_spawned_at_correct_pos = False
    is_start_time_found = False
    for space_time in pos_time_list:
        # Going over the space-time list of micrmouse
        if (start_pos[0]-space_time[0] != 0 or start_pos[1]-space_time[1] != 0) and not is_start_time_found:
            # If the micromouse starts moving
            start_time = space_time[2].to_sec()
            is_start_time_found = True
        if space_time[0] == 14 and space_time[1] == 14:
            end_time = space_time[2].to_sec()
            break
    return is_spawned_at_correct_pos, end_time - start_time


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/micromouse/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)
        data_writer.writerow(['Filename', 'Does bag files has rostopics?',
                              'Is spawned at correct position?', 'Remark', 'Simulation Time'])

        # iterate through each file
        for file in bag_files:
            bag = rosbag.Bag(file)
            is_passed = False
            is_topic_present = False
            dest_reached = False
            collision = False
            is_spawned_correctly = False
            pos_time_list = []
            time_taken = None
            # look throuhg topics
            topics = bag.get_type_and_topic_info()[1].keys()
            if '/micromouse/odom' in topics and '/micromouse/laser/scan' in topics:
                is_topic_present = True
            else:
                is_topic_present = False
                print('topic not present')
                is_passed = False

            for topic, msg, t in bag.read_messages(topics=['/micromouse/odom']):
                # check if destination reached
                x_bot = msg.pose.pose.position.x
                y_bot = msg.pose.pose.position.y
                x_bot_remapped = remap(x_bot)
                y_bot_remapped = remap(y_bot)

                # Coordinates in 31*31 maze_state representation
                X = int(x_bot_remapped)*2
                Y = int(y_bot_remapped)*2

                pos_time_list.append((X, Y, t))

            for topic, msg, t in bag.read_messages(topics=['/micromouse/laser/scan']):
                # check collision
                laser_ranges = msg.ranges
                no_of_points = len(laser_ranges)
                for i in range(no_of_points):
                    # assuming distance less than 0.005 will result in collision
                    # This value won't even be detected if the min_range parameter of laser is too high in urdf
                    if laser_ranges[i] &lt; 0.005:
                        collision = True

            if X == 14 and Y == 14:
                dest_reached = True
                is_spawned_correctly, time_taken = calc_simulation_time(
                    pos_time_list)

            if dest_reached and not collision and is_spawned_correctly:
                is_passed = True

            if is_topic_present and is_passed:
                remark = &quot;Passed!&quot;
                print(file + ' Result: passed!')
            elif not dest_reached:
                remark = &quot;Failed!, maze not solved.&quot;
                print(file + ' Result: failed!')
            elif collision:
                remark = &quot;Failed!, collision detected.&quot;
            else:
                print(file + ' Result: failed!')

            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], is_topic_present, is_spawned_correctly, remark, time_taken])

        bag.close()
    data_file.close()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task_micromouse/NOT_FOR_SHARING/autoeval.py" download><button>Download</button></a><center/>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-more-mazes"><a class="header" href="#add-more-mazes">Add more Mazes</a></h1>
<ul>
<li>
<p>For adding mazes in gazebo <code>gzmaze</code> package is used.</p>
</li>
<li>
<p>Instructions to use this package can be on their github repository.</p>
</li>
</ul>
<h2 id="github-repository"><a class="header" href="#github-repository">Github Repository</a></h2>
<p><a href="https://github.com/PeterMitrano/gzmaze">https://github.com/PeterMitrano/gzmaze</a></p>
<h2 id="steps-to-create-a-new-maze"><a class="header" href="#steps-to-create-a-new-maze">Steps to create a new maze</a></h2>
<ol>
<li>
<p>Clone the <code>gzmaze</code> package in your <code>workspace/src</code> directory.</p>
<pre><code class="language-bash">cd ~/workspace/src
git clone https://github.com/PeterMitrano/gzmaze.git
</code></pre>
</li>
<li>
<p>Navigate to <code>gzmaze</code> directory.</p>
<pre><code class="language-bash">cd ~/workspace/src/gzmaze
</code></pre>
</li>
<li>
<p>Build the package.</p>
<pre><code class="language-bash">mkdir build
cd build
cmake .. &amp;&amp; make
</code></pre>
</li>
<li>
<p>Running <code>gzmaze</code>.</p>
<ul>
<li>
<p>Make sure to add the following to your <code>.gazebo/gui.ini</code> file.</p>
<pre><code class="language-txt">    [overlay_plugins]
    filenames=libregenerate_widget.so
</code></pre>
</li>
<li>
<p>Setup the environment variables you need and run gazebo.</p>
<pre><code class="language-bash">cd ~/workspace/src/gzmaze
source setup.sh
gazebo --verbose gzmaze.world
</code></pre>
</li>
</ul>
</li>
<li>
<p>You will see a window like this. Click on <strong>Regenerate Randomly</strong>. This will create a random maze.</p>
<p><img src="tasks/task_micromouse/NOT_FOR_SHARING/./regenerate_randomly.png" alt="regenerate_randomly" /></p>
</li>
<li>
<p>Now, reset the simulation time and save this maze into a world. <code>File &gt; Save World as</code> and type the filename.</p>
<p><img src="tasks/task_micromouse/NOT_FOR_SHARING/./maze_generated.png" alt="maze_generated.png" /></p>
</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="simbhabot"><a class="header" href="#simbhabot">Simbhabot</a></h1>
<br/>
<br/>
<p><img src="tasks/task_simbhabot/simbha-top.png" alt="simbha-top" /></p>
<br/>
<p><strong>Welcome to the Simbhabot Mini-Project !!!</strong></p>
<hr />
<p>The aim of this task is make you familiar with depth camera and how to use it to navigate an environment without collisions. You need to install the mentioned software &amp; libraries by running the provided instructions in the <strong>provided sequence only</strong>; and if any error occurs at any step, please do not proceed unless the error has been rectified from your end.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide-2"><a class="header" href="#installation-guide-2">Installation Guide</a></h1>
<ul>
<li>
<p>Download Simbhabot simulation packages</p>
<ul>
<li>
<p>For this task you would have to update the simulation packages.</p>
</li>
<li>
<p>Download the resources from this link =&gt; <a href="tasks/task_simbhabot/simbha_bot_resources.zip" download><button>Download</button></a></p>
</li>
<li>
<p>Unzip and move these folders to <code>src</code> directory of your <code>workspace</code>.</p>
</li>
<li>
<p>Once the repository is downloaded build your workspace and source the <code>setup.bash</code> of your workspace.</p>
</li>
<li>
<p>To check if everything is installed properly enter the following command.</p>
<pre><code class="language-bash">roslaunch pkg_simbha_bot simbha_task.launch
</code></pre>
</li>
</ul>
<p>If everything is in place you should see the following environment in Gazebo.</p>
<p><img src="tasks/task_simbhabot/simbha_env.png" alt="Simbha-bot-env" /></p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Do not edit any files in these packages. If there is any bug in the packages we will notify you.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-4"><a class="header" href="#problem-statement-4">Problem Statement</a></h1>
<ul>
<li>
<p><strong>Objective</strong> - The objective of this task is to navigate a robot in an environment while avoiding collisions.</p>
</li>
<li>
<p>Robot has to reach the coordinates <code>x=7.0</code> and <code>y=0.0</code> while avoiding collisions.</p>
</li>
<li>
<p>Some objects will be randomly spawned around the simbhabot during the run.</p>
</li>
</ul>
<p><img src="tasks/task_simbhabot/simbha-collision.png" alt="simbha-collision" /></p>
<ul>
<li>
<p><strong>Collision Avoidance</strong></p>
<ul>
<li>
<p>Collision avoidance can be done by using laser scan data.</p>
</li>
<li>
<p>The run will be considered invalid if there is any collision with the walls or objects.</p>
</li>
</ul>
</li>
<li>
<p><strong>Odom</strong></p>
<ul>
<li>
<p>Odometry is to be used by the robot to estimate its position and orientation relative to a starting location.</p>
</li>
<li>
<p>Odometry values will be published on <code>/odom</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Laser Scan</strong></p>
<ul>
<li>
<p>The laser scan can be used to detect walls or obstacles around the robot.</p>
</li>
<li>
<p>Laser values will be published on <code>/scan</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Depth Camera</strong></p>
<ul>
<li>
<p>There is a depth camera attached to the simbhabot.</p>
</li>
<li>
<p>It provides raw image data on a rostopic.</p>
</li>
<li>
<p>It also provides depth sensibility from an image which can be used to avoid obstacles.</p>
</li>
</ul>
</li>
<li>
<p><strong>depthimage_to_laserscan</strong></p>
<ul>
<li>
<p><code>depthimage_to_laserscan</code> takes a depth image (float encoded meters or preferably uint16 encoded millimeters for OpenNI devices) and generates a 2D laser scan based on the provided parameters. <code>depthimage_to_laserscan</code> uses lazy subscribing and will not subscribe to <code>image</code> or <code>camera_info</code> until there is a subscriber for <code>scan</code>.</p>
</li>
<li>
<p>To use this in your implementation of this task, add this to your launch file.</p>
<pre><code class="language-xml">&lt;include file = &quot;$(find pkg_simbha_bot)/launch/depthimage_to_laserscan.launch&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Octomap</strong></p>
<ul>
<li>
<p>The <strong>OctoMap</strong> library implements a 3D occupancy grid mapping approach, providing data structures and mapping algorithms in C++.</p>
</li>
<li>
<p>This can be used to build the map of the environment from the depth camera.</p>
</li>
<li>
<p>To use this in your implementation of this task, add this to your launch file.</p>
<pre><code class="language-xml">&lt;include file = &quot;$(find pkg_simbha_bot)/launch/octomap.launch&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Simulation Time</strong></p>
<ul>
<li>In this task simulation time will be considered for grading.</li>
</ul>
</li>
</ul>
<h2 id="procedure-4"><a class="header" href="#procedure-4">Procedure</a></h2>
<ul>
<li>
<p>Use <code>pkg_simbha_bot</code> package which was provided to you in <a href="tasks/task_simbhabot/installation.html">installation guide</a>.</p>
</li>
<li>
<p>teams can have any number of nodes (Python Scripts <strong>only</strong>) in order to solve this task.</p>
</li>
<li>
<p>Create a launch file <code>simbha_solution.launch</code> which should launch the gazebo environment and all the nodes necessary to solve the problem statement. We’ll use this launch file to check your solution.</p>
</li>
<li>
<p>In this launch file you need to include the following in order to spawn all the necessary models and nodes for simulation.</p>
<pre><code class="language-xml">&lt;include file = &quot;$(find pkg_simbha_bot)/launch/simbha_task.launch&quot; /&gt;
</code></pre>
</li>
<li>
<p>You can also launch the RViz directly from launch file.</p>
<pre><code class="language-xml">&lt;include file = &quot;$(find pkg_simbha_bot)/launch/rviz.launch&quot; /&gt;
</code></pre>
</li>
<li>
<p>The team would also have to create a <code>bag_files</code> folder in <code>pkg_simbha_bot</code> package for storing the bag file.</p>
</li>
<li>
<p>Instructions to record bag file is given in <a href="tasks/task_simbhabot/recording_logs.html">Recording logs</a>.</p>
</li>
</ul>
<br/>
<h2 id="hint-2"><a class="header" href="#hint-2">Hint</a></h2>
<p>You can any of the technique in order to solve this task.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-4"><a class="header" href="#expected-output-4">Expected Output</a></h1>
<ul>
<li>The following video can be considered as a valid output.</li>
</ul>
<center><iframe width="824" height="476"
src="https://www.youtube.com/embed/BzK3bO2F_FY">
</iframe></center>
<blockquote>
<p><strong>NOTE</strong>: This is just one way to solve this task and not the only way. Your way to solve this task can be different.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-4"><a class="header" href="#recording-logs-4">Recording Logs</a></h1>
<ul>
<li>
<p>For recording the bags in this Task, you can refer to this <a href="tasks/task_simbhabot/../task0/recording-logs.html">section</a>.</p>
</li>
<li>
<p>This launch file will specifically make use of <code>/odom</code> and <code>/scan</code> ROS topics so make sure to specify these as shown below.</p>
</li>
<li>
<p>We recommend you to add the following in your <code>simbha_solution.launch</code> in order to record everything properly as soon as you start other nodes.</p>
</li>
<li>
<p>Make sure to create a directory called <code>bag_files</code> within your <code>pkg_simbha_bot</code> package where your bag files will get stored.</p>
<pre><code class="language-xml">&lt;!-- Recording Bag File for Submission --&gt;
&lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;rec_name&quot; default=&quot;sm.bag&quot;/&gt;

&lt;group if=&quot;$(arg record)&quot;&gt;
    &lt;node name=&quot;rosbag_record_pick&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
args=&quot;record -O $(find pkg_simbha_bot)/bag_files/$(arg rec_name) --chunksize=10 /odom /scan&quot; output=&quot;screen&quot;/&gt;
&lt;/group&gt;
</code></pre>
</li>
<li>
<p>Verify that your bag file is properly recorded by using the <code>rosbag info</code> command followed by the absolute or relative path of the file.</p>
</li>
<li>
<p>You can use the <code>rostopic echo -b sm.bag /odom</code> command to display the messages from the topic onto your bag file.</p>
</li>
<li>
<p>If you want to record the bag file needed for submission you would have to run the following command.</p>
<pre><code class="language-bash">roslaunch pkg_simbha_bot simbha_solution.launch record:=true rec_name:=sm.bag
</code></pre>
</li>
<li>
<p>If you just want to run your implementation without recording a bag file. Do the following.</p>
<pre><code class="language-bash">roslaunch pkg_simbha_bot simbha_solution.launch
</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-4"><a class="header" href="#solution-4">Solution</a></h1>
<p>Solution package can be downloaded from here =&gt; <a href="tasks/task_simbhabot/pkg_simbha_bot.zip" download><button>Download</button></a></p>
<br/>
<h2 id="to-run-the-solution-1"><a class="header" href="#to-run-the-solution-1">To run the solution</a></h2>
<p>Launch this file <code>simbha_solution.launch</code>. This will spawn the simbhabot in gazebo environment and also run node <code>bug0_algorithm.py</code>.</p>
<pre><code class="language-bash">roslaunch pkg_simbha_bot simbha_solution.launch
</code></pre>
<p><code>bug0_algorithm.py</code></p>
<p>This script go to the destination position i.e. <strong>(7.0, 0.0)</strong> using bug0 algorithm.</p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist, Point
from sensor_msgs.msg import LaserScan
from tf import transformations
import random_spawn

import math

MX_RANGE = 10

FINAL_TARGET = Point()
FINAL_TARGET.x = 7.0
FINAL_TARGET.y = 0.0

YAW_PRECISION = 5 * (math.pi / 180)  # 5 degrees
DIST_PRECISION = 0.10


class ObstacleAvoider(object):

    def __init__(self):

        self.regions = {
            'right': 0.0,
            'fright': 0.0,
            'front': 0.0,
            'fleft': 0.0,
            'left': 0.0
        }

        self.velocity_msg = Twist()
        self.move_state = 0
        self.obstacle_avoidance_state = 0
        self.robot_state = 0
        self.reached_destination = False

        self.pose = [0.0, 0.0, 0.0]
        self.curr_position = Point()

        self.publisher_ = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self.subscription = rospy.Subscriber(
            '/odom', Odometry, self.odom_callback)

        self.subscription = rospy.Subscriber(
            '/scan', LaserScan, self.laserscan_callback)

        self.rate = rospy.Rate(20)

    # angle difference or yaw between any point and the bot.
    def error_angle(self, point):
        rx = self.pose[0]
        ry = self.pose[1]
        theta = self.pose[2]*(math.pi/180)
        theta_goal = math.atan2(point.y - ry, point.x - rx)
        error = self.normalize_angle(theta_goal - theta)
        return error

    # function that gives linear distance between any point and the bot.
    def calc_dist_points(self, point1, point2):
        dist = math.sqrt((point1.y - point2.y)**2 + (point1.x - point2.x)**2)
        return dist

    # function to limit the bot rotation between -pi to pi
    def normalize_angle(self, angle):
        if(math.fabs(angle) &gt; math.pi):
            angle = angle - (2 * math.pi * angle) / (math.fabs(angle))
        return angle

    def fix_yaw(self, des_pos):
        err_yaw = self.error_angle(des_pos)

        if math.fabs(err_yaw) &gt; YAW_PRECISION:
            if err_yaw &gt; 0:
                self.velocity_msg.linear.x = 0.0
                self.velocity_msg.angular.z = 0.5
            else:
                self.velocity_msg.linear.x = 0.0
                self.velocity_msg.angular.z = -0.5

        if math.fabs(err_yaw) &lt; YAW_PRECISION:
            self.move_state = 1

        self.publisher_.publish(self.velocity_msg)

    def go_straight_ahead(self, des_pos):
        err_yaw = self.error_angle(des_pos)
        curr_pos = Point()
        curr_pos.x = self.pose[0]
        curr_pos.y = self.pose[1]
        err_pos = self.calc_dist_points(des_pos, curr_pos)

        if err_pos &gt; DIST_PRECISION:

            self.velocity_msg.linear.x = 0.55
            self.velocity_msg.angular.z = 0.0 if err_yaw &gt; YAW_PRECISION else -0.0
            self.publisher_.publish(self.velocity_msg)
        else:
            self.done()

        # state change conditions
        if math.fabs(err_yaw) &gt; YAW_PRECISION:
            self.move_state = 0

    def done(self):
        self.velocity_msg.linear.x = 0.0
        self.velocity_msg.angular.z = 0.0
        self.publisher_.publish(self.velocity_msg)
        self.reached_destination = True

    def quaternion_to_euler(self, x, y, z, w):

        t0 = +2.0 * (w * x + y * z)
        t1 = +1.0 - 2.0 * (x * x + y * y)
        X = math.degrees(math.atan2(t0, t1))

        t2 = +2.0 * (w * y - z * x)
        t2 = +1.0 if t2 &gt; +1.0 else t2
        t2 = -1.0 if t2 &lt; -1.0 else t2
        Y = math.degrees(math.asin(t2))

        t3 = +2.0 * (w * z + x * y)
        t4 = +1.0 - 2.0 * (y * y + z * z)
        Z = math.degrees(math.atan2(t3, t4))

        return [X, Y, Z]

    def euler_to_quaternion(self, r):
        (yaw, pitch, roll) = (r[0], r[1], r[2])
        qx = math.sin(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) - \
            math.cos(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
        qy = math.cos(roll/2) * math.sin(pitch/2) * math.cos(yaw/2) + \
            math.sin(roll/2) * math.cos(pitch/2) * math.sin(yaw/2)
        qz = math.cos(roll/2) * math.cos(pitch/2) * math.sin(yaw/2) - \
            math.sin(roll/2) * math.sin(pitch/2) * math.cos(yaw/2)
        qw = math.cos(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) + \
            math.sin(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
        return [qx, qy, qz, qw]

    def odom_callback(self, data):
        x = data.pose.pose.orientation.x
        y = data.pose.pose.orientation.y
        z = data.pose.pose.orientation.z
        w = data.pose.pose.orientation.w
        self.curr_position = data.pose.pose.position
        self.pose = [data.pose.pose.position.x,
                     data.pose.pose.position.y,
                     self.quaternion_to_euler(x, y, z, w)[2]]

    def reach_goal(self):

        if self.regions['front'] &gt; 0.50 and self.regions['front'] &lt; 1:
            self.robot_state = 1

        if self.robot_state == 0:
            if self.move_state == 0:
                self.fix_yaw(FINAL_TARGET)
                rospy.loginfo('Fixing Heading to reach Target')
            elif self.move_state == 1:
                self.go_straight_ahead(FINAL_TARGET)
                rospy.loginfo('Moving towards the Target')

        if self.robot_state == 1:
            err_yaw = self.error_angle(FINAL_TARGET)
            if math.fabs(err_yaw) &lt; (math.pi / 6) and \
                    self.regions['front'] &gt; 1.5 and self.regions['fright'] &gt; 1 and self.regions['fleft'] &gt; 1:
                # print ('less than 30')
                self.robot_state = 0

            # between 30 and 90
            if err_yaw &gt; 0 and \
                    math.fabs(err_yaw) &gt; (math.pi / 6) and \
                    math.fabs(err_yaw) &lt; (math.pi / 2) and \
                    self.regions['left'] &gt; 1.5 and self.regions['fleft'] &gt; 1:
                # print ('between 30 and 90 - to the left')
                self.robot_state = 0

            if err_yaw &lt; 0 and \
                    math.fabs(err_yaw) &gt; (math.pi / 6) and \
                    math.fabs(err_yaw) &lt; (math.pi / 2) and \
                    self.regions['right'] &gt; 1.5 and self.regions['fright'] &gt; 1:
                # print ('between 30 and 90 - to the right')
                self.robot_state = 0

            self.follow_wall()

    def laserscan_callback(self, msg):
        self.regions = {
            'right': min(min(msg.ranges[0:127]), MX_RANGE),
            'fright': min(min(msg.ranges[128:255]), MX_RANGE),
            'front': min(min(msg.ranges[256:383]), MX_RANGE),
            'fleft': min(min(msg.ranges[384:511]), MX_RANGE),
            'left': min(min(msg.ranges[512:640]), MX_RANGE),
        }
        self.take_action(self.regions)

    def find_wall(self):

        self.velocity_msg.linear.x = 0.55
        self.velocity_msg.angular.z = -0.25
        self.publisher_.publish(self.velocity_msg)

    def turn_left(self):
        self.velocity_msg.linear.x = 0.0
        self.velocity_msg.angular.z = 0.55
        self.publisher_.publish(self.velocity_msg)

    def follow_the_wall(self):

        self.velocity_msg.linear.x = 0.35
        self.velocity_msg.angular.z = 0.0
        self.publisher_.publish(self.velocity_msg)
        # rospy.loginfo('%s'%str(self.velocity_msg))

    def check_sensors_for_nan(self, regions):
        for key in regions.keys():
            if regions[key] != regions[key]:
                regions[key] = math.inf
        return regions

    def take_action(self, regions):

        if self.robot_state == 1:
            state_description = ''
            d = 1.5
            regions = self.check_sensors_for_nan(regions)
            if regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
                state_description = 'case 1 - nothing'
                self.obstacle_avoidance_state = 0

            elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &gt; d:
                state_description = 'case 2 - front'
                self.obstacle_avoidance_state = 1

            elif regions['front'] &gt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
                state_description = 'case 3 - fright'
                self.obstacle_avoidance_state = 2

            elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
                state_description = 'case 4 - fleft'
                self.obstacle_avoidance_state = 0

            elif regions['front'] &lt; d and regions['fleft'] &gt; d and regions['fright'] &lt; d:
                state_description = 'case 5 - front and fright'
                self.obstacle_avoidance_state = 1

            elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &gt; d:
                state_description = 'case 6 - front and fleft'
                self.obstacle_avoidance_state = 1

            elif regions['front'] &lt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
                state_description = 'case 7 - front and fleft and fright'
                self.obstacle_avoidance_state = 1

            elif regions['front'] &gt; d and regions['fleft'] &lt; d and regions['fright'] &lt; d:
                state_description = 'case 8 - fleft and fright'
                self.obstacle_avoidance_state = 0

            else:
                state_description = 'unknown case'
                rospy.loginfo('Laser_scan_data: &quot;%s&quot;' % str(self.regions))

    def follow_wall(self):
        if self.obstacle_avoidance_state == 0:
            rospy.loginfo('Finding nearby wall')
            self.find_wall()
        elif self.obstacle_avoidance_state == 1:
            rospy.loginfo('Turning Left')
            self.turn_left()
        elif self.obstacle_avoidance_state == 2:
            rospy.loginfo('Following the wall')
            self.follow_the_wall()


def main():
    rospy.init_node('node_bug_algorithm')

    simbha_mover = ObstacleAvoider()
    while not rospy.is_shutdown():
        simbha_mover.reach_goal()
        simbha_mover.rate.sleep()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task_simbhabot/bug0_algorithm.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoevaluation-script-1"><a class="header" href="#autoevaluation-script-1">Autoevaluation Script</a></h1>
<br/>
<h2 id="how-to-use-2"><a class="header" href="#how-to-use-2">How to use</a></h2>
<p>This script can take any number of bag files stored in <code>/home/ubuntu/workspace/src/pkg_simbha_bot/bag_files</code> and create a <code>results.csv</code> output which will show the result of simbhabot bag files.</p>
<pre><code class="language-bash">rosrun pkg_simbha_bot autoeval.py
</code></pre>
<p>This will generate <code>results.csv</code> in bag files location.</p>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_simbha_bot autoeval.py
# This file will print results on the terminal window


def calc_simulation_time(pos_time_list):
    '''Take space-time list of simbhabot as argument and returns simulation
    time between the time micromouse starts moving till it reaches the centre
    of maze.'''
    start_pos = (pos_time_list[0][0], pos_time_list[0][1])
    if abs(start_pos[0]) &lt; 0.1 and abs(start_pos[1]) &lt; 0.1:
        is_spawned_at_correct_pos = True
    else:
        is_spawned_at_correct_pos = False
    is_start_time_found = False
    for space_time in pos_time_list:
        # Going over the space-time list of micrmouse
        if (abs(start_pos[0]-space_time[0]) &gt; 0.1 or abs(start_pos[1]-space_time[1]) &gt; 0.1) and not is_start_time_found:
            # If the micromouse starts moving
            start_time = space_time[2].to_sec()
            is_start_time_found = True
        if 6.9 &lt; space_time[0] &lt; 7.1 and -0.1 &lt; space_time[1] &lt; 0.1:
            end_time = space_time[2].to_sec()
            break
    return is_spawned_at_correct_pos, end_time - start_time


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/pkg_simbha_bot/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)
        data_writer.writerow(['Filename', 'Does bag files has rostopics?',
                              'Is spawned at correct position?', 'Collision', 'Remark', 'Simulation Time'])

        # iterate through each file
        for file in bag_files:
            bag = rosbag.Bag(file)
            is_passed = False
            is_topic_present = False
            dest_reached = False
            collision = False
            is_spawned_correctly = False
            pos_time_list = []
            time_taken = None
            # look throuhg topics
            topics = bag.get_type_and_topic_info()[1].keys()
            if '/odom' in topics and '/scan' in topics:
                is_topic_present = True
            else:
                is_topic_present = False
                print('topic not present')
                is_passed = False

            for topic, msg, t in bag.read_messages(topics=['/odom']):
                # check if destination reached
                x_bot = msg.pose.pose.position.x
                y_bot = msg.pose.pose.position.y

                pos_time_list.append((x_bot, y_bot, t))

            for topic, msg, t in bag.read_messages(topics=['/scan']):
                # check collision
                laser_ranges = msg.ranges
                no_of_points = len(laser_ranges)
                for i in range(no_of_points):
                    # assuming distance less than 0.07 will result in collision
                    # This value won't even be detected if the min_range parameter of laser is too high in urdf
                    if laser_ranges[i] &lt; 0.07:
                        collision = True

            if 6.9 &lt; x_bot &lt; 7.1 and -0.1 &lt; y_bot &lt; 0.1:
                dest_reached = True
                is_spawned_correctly, time_taken = calc_simulation_time(
                    pos_time_list)

            if dest_reached and not collision and is_spawned_correctly:
                is_passed = True

            if is_topic_present and is_passed:
                remark = &quot;Passed!&quot;
                print(file + ' Result: passed!')
            elif not dest_reached:
                remark = &quot;Failed!, goal not reached.&quot;
                print(file + ' Result: failed!')
            elif collision:
                remark = &quot;Failed!, collision detected.&quot;
            else:
                remark = &quot;Failed!&quot;
                print(file + ' Result: failed!')

            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], is_topic_present, is_spawned_correctly, collision, remark, time_taken])

        bag.close()
    data_file.close()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task_simbhabot/autoeval.py" download><button>Download</button></a><center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-follower"><a class="header" href="#line-follower">Line Follower</a></h1>
<p>Welcome to the line follower mini-project</p>
<p>The aim of this task is to create a line follower robot with differential drive and camera plugins and also make a script to make the robot follow the line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-5"><a class="header" href="#problem-statement-5">Problem Statement</a></h1>
<p>This Task is divided into two sub tasks.</p>
<ul>
<li><a href="tasks/task_line_follower/./create_robot.html">Creating the robot</a> - Creata a simple diff-drive robot with a camera installed.</li>
<li><a href="tasks/task_line_follower/./create_script.html">Creating the script</a> - Designing a line following script.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-simple-mobile-robot-in-gazebo"><a class="header" href="#create-a-simple-mobile-robot-in-gazebo">Create a Simple mobile Robot in Gazebo</a></h1>
<p>The objective is to create a simple diff-drive robot with a camera plugin installed.</p>
<p>For example:</p>
<p><img src="tasks/task_line_follower/./model.png" alt="model_image" /></p>
<p>As you can see in the above image, the robot contains 4 wheels and 1 camera at the head location.</p>
<pre><code>Note: You dont have to make the exact model shown in the image, any mobile robot with a camera installed and ability to move in a 2-d plane will be sufficient.
</code></pre>
<h2 id="adding-the-camera-and-camera-plugin"><a class="header" href="#adding-the-camera-and-camera-plugin">Adding the camera and camera plugin</a></h2>
<p>To add a camera simply create <code>camera</code> link with the shape of a box and attach it to the <code>base_link</code> of your model with a fixed joint.</p>
<p>To add the camera plugin you can simple add the following line in your urdf file.</p>
<pre><code class="language-xml">&lt;gazebo reference=&quot;camera&quot;&gt;
    &lt;material&gt;Gazebo/Green&lt;/material&gt;
    &lt;sensor type=&quot;camera&quot; name=&quot;camera1&quot;&gt;
        &lt;update_rate&gt;30.0&lt;/update_rate&gt;
        &lt;camera name=&quot;head&quot;&gt;
            &lt;horizontal_fov&gt;1.3962634&lt;/horizontal_fov&gt;
            &lt;image&gt;
                &lt;width&gt;800&lt;/width&gt;
                &lt;height&gt;800&lt;/height&gt;
                &lt;format&gt;R8G8B8&lt;/format&gt;
            &lt;/image&gt;
            &lt;clip&gt;
                &lt;near&gt;0.02&lt;/near&gt;
                &lt;far&gt;300&lt;/far&gt;
            &lt;/clip&gt;
        &lt;/camera&gt;
        &lt;plugin name=&quot;camera_controller&quot; filename=&quot;libgazebo_ros_camera.so&quot;&gt;
            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;
            &lt;updateRate&gt;0.0&lt;/updateRate&gt;
            &lt;cameraName&gt;follower/camera1&lt;/cameraName&gt;
            &lt;imageTopicName&gt;image_raw&lt;/imageTopicName&gt;
            &lt;cameraInfoTopicName&gt;camera_info&lt;/cameraInfoTopicName&gt;
            &lt;frameName&gt;camera&lt;/frameName&gt;
            &lt;hackBaseline&gt;0.07&lt;/hackBaseline&gt;
            &lt;distortionK1&gt;0.0&lt;/distortionK1&gt;
            &lt;distortionK2&gt;0.0&lt;/distortionK2&gt;
            &lt;distortionK3&gt;0.0&lt;/distortionK3&gt;
            &lt;distortionT1&gt;0.0&lt;/distortionT1&gt;
            &lt;distortionT2&gt;0.0&lt;/distortionT2&gt;
        &lt;/plugin&gt;
    &lt;/sensor&gt;
&lt;/gazebo&gt;
</code></pre>
<p>you can read more about this <a href="http://gazebosim.org/tutorials?tut=ros_gzplugins">here</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="design-a-script-to-follow-the-yellow-lines"><a class="header" href="#design-a-script-to-follow-the-yellow-lines">Design a script to follow the yellow lines</a></h1>
<ul>
<li>
<p>The objective is to design a script to follow yellow line strips in ht gazebo world.</p>
</li>
<li>
<p>For the yellow lines you can simply use the following sdf file <code>yellow_line.world</code>.</p>
</li>
</ul>
<center><a href="tasks/task_line_follower/./yellow_line.world" download><button>Download</button></a></center>
<ul>
<li>
<p>Create a <code>world</code> directory in your package and move the above file in it.</p>
</li>
<li>
<p>To load the world file add the following in your launch file.</p>
</li>
</ul>
<pre><code class="language-xml">&lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;
    &lt;arg name=&quot;world_name&quot; value=&quot;$(find line_follower)/world/yellow_line.world&quot;/&gt;
&lt;/include&gt;
</code></pre>
<h2 id="making-the-script"><a class="header" href="#making-the-script">Making the script</a></h2>
<p>For making the line follower script you can download the boiler script below and move it in your <code>scripts</code> directory of your package.</p>
<center><a href="tasks/task_line_follower/./line_follower.py" download><button>Download</button></a></center>
<p>you will publish velocities using the topic <code>/follower_diff_drive_controller/cmd_vel</code>. You can change the topic name accordingly to your model’s diff-drive controller name.</p>
<p>use <code>rostopic info</code> command to know more about the rosmsg used for communication</p>
<p><img src="tasks/task_line_follower/./geometry_msg.png" alt="geometry_msg" /></p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-5"><a class="header" href="#expected-output-5">Expected Output</a></h1>
<p>After successfully creating the robot model and making the line follower script your robot should be able to follow the yellow lines.</p>
<p><img src="tasks/task_line_follower/./line_follower_output.gif" alt="output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-5"><a class="header" href="#recording-logs-5">Recording Logs</a></h1>
<ul>
<li>
<p>Create a folder called bagfiles in your package as a save destination for the bag files.</p>
</li>
<li>
<p>Add the following lines to your launch file to have the rosbag record run in parallel with your task.</p>
</li>
</ul>
<pre><code class="language-xml">&lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;duration&quot; default=&quot;180&quot;/&gt;
&lt;arg name=&quot;rec_name&quot; default=&quot;record.bag&quot;/&gt;

&lt;group if=&quot;$(arg record)&quot;&gt;
    &lt;node name=&quot;rosbag_record_drone&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot; args=&quot;record -O $(find line_follower)/bagfiles/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /gazebo/link_states&quot; output=&quot;screen&quot; /&gt;
&lt;/group&gt;
</code></pre>
<ul>
<li>Launch the launch file with the following command:</li>
</ul>
<pre><code class="language-bash">roslaunch line_follower gazebo.launch record:=true rec_name:=follower_record.bag
</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="solution-5"><a class="header" href="#solution-5">Solution</a></h1>
<blockquote>
<p><strong>Note</strong>: Remove this md page from mdbook and delete scripts from src/tasks/task0/ It shows one of the possible solution with autoeval script.</p>
</blockquote>
<p><code>gazebo.launch</code> <center><a href="tasks/task_line_follower/tasks/task_line_follower/solution/gazebo.launch" download><button>Download_launch_file</button></a></center></p>
<p><code>line_follower.py</code> <center><a href="tasks/task_line_follower/tasks/task_line_follower/solution/line_follower.py" download><button>Download_script</button></a></center></p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="autoeval-script-2"><a class="header" href="#autoeval-script-2">Autoeval script</a></h1>
<blockquote>
<p><strong>Note</strong>: Save this file in a ROS package scripts folder. Then to run this script, run in terminal rosrun autoeval.py. This script prints the result in the terminal window.</p>
</blockquote>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_task2 autoeval.py
# This file will print results on the terminal window

def main():
	bag_files = []
	is_passed = False
	# Change this path to where all bag files are located.
	path = &quot;/home/ubuntu/workspace/src/eysip/line_follower/bagfiles&quot;
	for file in glob.glob(path + &quot;/*.bag&quot;):
		bag_files.append(file)

	# iterate through each file
	for file in bag_files:
		bag = rosbag.Bag(file)
		# look throuhg topics
		topics = bag.get_type_and_topic_info()[1].keys()
		if '/gazebo/link_states' in topics:
			is_topic_present = True
		else:
			is_topic_present = False
			print('topic not present')
			is_passed = False

		for topic, msg, t in bag.read_messages(topics=['/gazebo/link_states']):
			if (len(msg.pose) &lt; 9):
				continue
			if (abs(msg.pose[9].position.x-(-3)) &lt;= 0.2 and abs(msg.pose[9].position.y-(-6.387296170000643)) &lt;= 0.2):
				is_passed = True

		if is_topic_present == True and is_passed == True:
			print(file + ' Result: passed!')
		else:
			print(file + ' Result: failed!')

if __name__ == '__main__':
	main()
</code></pre>
<center><a href="tasks/task_line_follower/tasks/task_line_follower/autoeval.py" download><button>Download</button></a></center>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="vitarana-drone"><a class="header" href="#vitarana-drone">Vitarana Drone</a></h1>
<p>welcome to the Vitarana Drone mini-project</p>
<p>The aim of this task is to make an obstacle-avoidance script for drone navigation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<h2 id="git"><a class="header" href="#git">Git</a></h2>
<ul>
<li>
<p>The first step is to install git. If you have not installed it already then install by executing the following command in a terminal</p>
<pre><code class="language-bash">sudo apt install git
</code></pre>
</li>
</ul>
<h2 id="vitarana_drone-ros-package"><a class="header" href="#vitarana_drone-ros-package">vitarana_drone ROS package</a></h2>
<ul>
<li>
<p>Next, clone the <code>vitarana_drone</code> package from github in your <code>workspace/src</code> folder, to do that, execute the following commands</p>
<pre><code class="language-bash">cd ~/catkin_ws/src
git clone https://github.com/smitkesaria/vitarana_drone.git
</code></pre>
</li>
<li>
<p>Now build the package that you have cloned by executing the following command</p>
<pre><code class="language-bash">cd ..
catkin build
</code></pre>
</li>
<li>
<p>If the build was successful without any errors you will get a message 100% built .</p>
</li>
<li>
<p>Next step is to source <code>setup.bash</code> present in the <code>workspace/devel</code> so that the terminal shell recognises the ROS package that you just built</p>
<pre><code class="language-bash">source ~/workspace/devel/setup.bash
</code></pre>
</li>
<li>
<p>Alternatively if you have already copied the above command in your <code>~/.bashrc</code> then you can also source the <code>~/.bashrc</code> and do not need to write the above command always</p>
<pre><code class="language-bash">source ~/.bashrc
</code></pre>
</li>
<li>
<p>Now launch the gazebo world containing the eDrone model</p>
<pre><code class="language-bash">roslaunch vitarana_drone drone.launch
</code></pre>
<p>This will open gazebo window and voila, you will be able to see the eDrone model.</p>
<p>If you follow everything correctly, you will be able to see the world just like shown in the figure below</p>
<p><img src="tasks/task_vd/./eDrone.png" alt="eDrone" /></p>
</li>
<li>
<p>Open another terminal window and execute the following command to get info of the topics being published/subscribed currently</p>
<pre><code class="language-bash">rostopic list
</code></pre>
<p><img src="tasks/task_vd/./rostopic_list.png" alt="rostopic" /></p>
</li>
</ul>
<h2 id="pid_tune-gui-ros-package"><a class="header" href="#pid_tune-gui-ros-package">pid_tune GUI ROS package</a></h2>
<ul>
<li>
<p>This ROS package will help you to tune Proportional Integrate Derivative (PID) control gains throughout Task 1A and 1B.</p>
</li>
<li>
<p>Clone the <code>pid_tune</code> ROS package from github in your <code>workspace/src</code> folder</p>
<pre><code class="language-bash">cd ~/catkin_ws/src
git clone https://github.com/simmubhangu/pid_tune.git
</code></pre>
</li>
<li>
<p>Now build the package</p>
<pre><code class="language-bash">cd ..
catkin build
</code></pre>
</li>
<li>
<p>Do not forget to source <code>~/workspace/devel/setup.bash</code> or <code>~/.bashrc</code> after a successful build</p>
<pre><code class="language-bash">source ~/workspace/devel/setup.bash

</code></pre>
</li>
<li>
<p>To run the pid_tune_drone rosnode, type</p>
<pre><code class="language-bash">rosrun pid_tune pid_tune_drone.py
</code></pre>
<p>This will start 4 GUI windows with sliders for Kp, Ki and Kd each for Roll, Pitch, Yaw and Throttle.</p>
<p><strong>NOTE</strong>: A <em>rosnode</em> can only run when there is <em>rosmaster</em> running in background, if not started already then start <em>rosmaster</em> using</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
</ul>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="learning"><a class="header" href="#learning">Learning</a></h1>
<p>Here are some topics that you will need to cover for successfully completing your task.</p>
<ul>
<li><a href="tasks/task_vd/./learn_edrone_model.html">Exploring eDrone ROS-Gazebo model</a></li>
<li><a href="tasks/task_vd/./path_planning.html">Path planning and navigation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploring-edrone-ros-gazebo-model"><a class="header" href="#exploring-edrone-ros-gazebo-model">Exploring eDrone ROS-Gazebo model</a></h1>
<p>In this section, we will explore the sensors &amp; actuators present on eDrone and how to get the values from sensors and give command the rotate the propellers.</p>
<h2 id="sensors"><a class="header" href="#sensors">Sensors</a></h2>
<h3 id="inertial-measurement-unit-imu"><a class="header" href="#inertial-measurement-unit-imu">Inertial Measurement Unit (IMU)</a></h3>
<ul>
<li>
<p>An Inertial Measurement Unit (IMU) is an electronic device that measures and reports a body’s specific force, angular rate, and sometimes the orientation of the body, using a combination of accelerometers, gyroscopes, and sometimes magnetometers. IMUs are typically used to maneuver aircraft including unmanned aerial vehicles (UAVs).</p>
</li>
<li>
<p>Typically complex filtering techniques are used to estimate the orientation and heading of the aircraft by fusing readings from all the above mentioned sensors. The filtering techniques are beyond the scope of this task.</p>
</li>
<li>
<p>The eDrone also has an IMU which directly publishes the filtered data ie. the orientation and heading of the eDrone over a rostopic named <code>/edrone/imu/data</code>.</p>
</li>
<li>
<p>To check the IMU data being published from the sensor, you can first launch the gazebo world with eDrone using the command in previous section and then to get sensor data, type the following command.</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /erone/imu/data
</code></pre>
<p><img src="tasks/task_vd//rostopic_echo_imu.png" alt="rostopic_echo_imu" /></p>
<ul>
<li>Bonus: If you want to get the info of the topic <code>/edrone/imu/data</code> then type</li>
</ul>
<pre><code class="language-bash">rostopic info /edrone/imu/data
</code></pre>
<p><img src="tasks/task_vd/./rostopic_info_imu.png" alt="rostopic_info_imu" /></p>
<p>As you can see, the msg type used by this rostopic is <code>sensor_msgs/Imu</code>
To get more info about the msg type, use the command</p>
<pre><code class="language-bash">rosmsg show sensor_msgs/Imu
</code></pre>
<p><img src="tasks/task_vd/./rosmsg_show_imu.png" alt="rosmsg_show_imu" /></p>
<ul>
<li>To know the rate at which the IMU sensor in gazebo publishes data, you can type</li>
</ul>
<pre><code class="language-bash">rostopic hz /edrone/imu/data
</code></pre>
<p><img src="tasks/task_vd/./rostopic_hz_imu.png" alt="rostopic_hz_imu" /></p>
<h3 id="global-positioning-system-sensor-gps-sensor"><a class="header" href="#global-positioning-system-sensor-gps-sensor">Global Positioning System sensor (GPS sensor)</a></h3>
<ul>
<li>
<p>GPS sensors are receivers with antennas that use a satellite-based navigation system with a network of multiple satellites in orbit around the earth to provide position, velocity, and timing information.</p>
</li>
<li>
<p>However a GPS sensor on eDrone is simulated in gazebo which publishes the latitude, longitude and altitude data along with other data but we are concerned about the position of the eDrone ie, latiude, longitude and altitude.</p>
</li>
<li>
<p>The GPS sensor of eDrone publishes data on the topic <code>/edrone/gps</code>.</p>
</li>
<li>
<p>To get check the data being published by the <code>/edrone/gps</code> topic, type</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /edrone/gps
</code></pre>
<p><img src="tasks/task_vd/./rostopic_echo_gps.png" alt="rostopic_echo_gps" /></p>
<ul>
<li>To get more info of the topic, msg type and update rate of /edrone/gps you can follow the similar steps as explained in the IMU section.</li>
</ul>
<h3 id="range-finder-bottom"><a class="header" href="#range-finder-bottom">Range finder-Bottom</a></h3>
<ul>
<li>
<p>Usually UAV’s or drones have a range finder (usually SONAR or LiDAR) at the bottom that measures the distance of the drone from the ground/obstacle.</p>
</li>
<li>
<p>The eDrone also has a bottom facing range finder to measure the distance of eDrone from the ground.</p>
</li>
</ul>
<p><strong>NOTE</strong>: The altitude reading from the GPS sensor is above the sea level or you can consider it as the altitude with reference to global co-ordinate system. Let us consider a case when the eDrone is exactly 1m above a building that is 10m tall, the GPS altitude will give the reading of 11m whereas the range finder will give the actual distance of the obstacle (terrace of the building) from the eDrone.</p>
<ul>
<li>
<p>The range finder at the bottom publishes ROS messages on the topic <code>/edrone/range_finder_bottom</code></p>
</li>
<li>
<p>To get check the data being published by the <code>/edrone/range_finde_bottom</code> topic, type</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /edrone/range_finder_bottom
</code></pre>
<p><img src="tasks/task_vd/./rostopic_echo_range_bottom.png" alt="rostopic_echo_range_bottom" /></p>
<ul>
<li>
<p>To get more info of the topic, msg type and update rate of <code>/edrone/range_finder_bottom</code> you can follow the similar steps as explained in the IMU section.</p>
</li>
<li>
<p>You will be accessing the ROS messages using your python scripts. The msg files are like packets with many variables of different data types. The msg sensor_msgs/LaserScan has a variable array named ranges, this is an array of float data type. Use this information while you implement your tasks.
<img src="tasks/task_vd/./rosmsg_show_laserscan.png" alt="rosmsg_show_laserscan" /></p>
</li>
</ul>
<h3 id="range-finder-top"><a class="header" href="#range-finder-top">Range finder-top</a></h3>
<ul>
<li>
<p>Some autonomous UAV’s or drones have range finders facing front, right, back and left to detect any obstacle and avoid collision.</p>
</li>
<li>
<p>Some autonomous UAV’s or drones have range finders facing front, right, back and left to detect any obstacle and avoid collision.</p>
</li>
<li>
<p>The range finder is placed at the top and hence lets call it as range finder-top to distinguish from the range finder-bottom.</p>
</li>
<li>
<p>The range finder-top publishes ROS messages on the topic <code>/edrone/range_finder_top</code></p>
</li>
<li>
<p>To get check the data being published by the <code>/edrone/range_finde_top</code> topic, type</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /edrone/range_finder_top
</code></pre>
<p><img src="tasks/task_vd/./rostopic_echo_range_top.png" alt="rostopic_echo_range_top" /></p>
<h2 id="actuators"><a class="header" href="#actuators">Actuators</a></h2>
<h3 id="motors-and-propellers"><a class="header" href="#motors-and-propellers">Motors and propellers</a></h3>
<ul>
<li>
<p>The eDrone has 4 propellers attached to 4 different motors.</p>
</li>
<li>
<p>Two motors spin in clockwise direction and two motors spin in counterclockwise direction.
<img src="tasks/task_vd/./eDrone_prop.png" alt="eDrone_prop" /></p>
</li>
<li>
<p>The motors used in real drones are usually Brush-less DC (BLDC) motors which are driven by Electronic Speed Controllers (ESC’s). </p>
</li>
<li>
<p>The flight controller present on the drones send the data to the ESC’s in the form of Pulse Width Modulated (PWM) signals, however the motors used on eDrone are simulated but still to keep the experience of the simulation realistic, the eDrone model also communicates in PWM format of 10 bits, which means, you can set the speed of motors by sending data ranging from 0 to 210 - 1 ie. 0 to 1023.</p>
</li>
<li>
<p>The eDrone accepts the PWM values for setting the speed of motors over the rostopic <code>/edrone/pwm</code></p>
</li>
<li>
<p>To know more about the topic and message types, use </p>
</li>
</ul>
<pre><code class="language-bash">rostopic info /edrone/pwm
</code></pre>
<pre><code class="language-bash">rosmsg show vitarana_drone/prop_speed
</code></pre>
<ul>
<li>Now lets try to fly the eDrone by publishing the PWM values for the speed of 4 motors by typing</li>
</ul>
<pre><code class="language-bash">rostopic pub /edrone/pwm vitarana_drone/prop_speed &quot;prop1: 512.0
prop2: 512.0
prop3: 512.0
prop4: 512.0&quot; 
</code></pre>
<p>Voila, you just made the eDrone fly ! </p>
<p>Now experiment publishing different and unequal values to the propellers and observe how the eDrone performs rotation in Roll and Pitch axes.</p>
<h2 id="tip"><a class="header" href="#tip">Tip</a></h2>
<ul>
<li>If you want to see the IMU, GPS, Range finder’s or Camera readings while you move the eDrone’s position and orientation, use the static parameter to launch the eDrone</li>
</ul>
<pre><code class="language-bash">roslaunch vitarana_drone drone.launch static:='static'
</code></pre>
<p>This will disable gravity and you can play around with the eDrone and observe the readings, this will be helpful to interpret the sensor’s readings for roll, pitch, lattitude, longitude, altitude etc.</p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="path-planning-and-navigation"><a class="header" href="#path-planning-and-navigation">Path planning and navigation</a></h1>
<p><strong>Note</strong>: While you can finish this task by just hard-coding the setpoints, while it may work for a static scenario with not a long path, it will be unsustainable to do for larger paths and dynamic scenarios and hence you should NOT do this. If hard-coding is found, it may lead to disqualification.</p>
<p>Hence it is recommended that you implement proper path planning algorithms.</p>
<ul>
<li>
<p>On the controls side, looking into waypoint navigation (with the help of position controller and attitude controller) or trajectory tracking.</p>
</li>
<li>
<p>On the planning algorithm side look into simple algorithms like the Bug algorithms. You can also utilize algorithms like A* and Djikstra’s, but pay special attention to your data structures as you’re operating on a larger scale.</p>
</li>
</ul>
<p><a href="https://spacecraft.ssl.umd.edu/academics/788XF14/788XF14L14/788XF14L14.pathbugsmapsx.pdf">This PDF</a> gives a nice overview of the points discussed above.</p>
<p>You can use <strong>any</strong> sorts of algorithms or packages that involve no prior knowledge of the arena/scene. i.e. you cannot use algorithms which take the sector mesh or its derivatives as inputs and plan around the obstacles using that approach.</p>
<p>If you choose to do all of this, this task will be much more programming heavy than earlier ones, it will be beneficial in the future tasks and impart lots of learning.</p>
<p><strong>Pro-Tip</strong>: Try to bring the GPS coordinates into x, y pose (in metres) you can do this by using simple algebra. This will enable you to take into account things like distance etc. more easily while planning trajectories, to what degree you include position is metres into your script is up to you, i.e. just for planning, or maybe for both planning and the control loop (same or similar gains will likely work).</p>
<pre><code class="language-python">def lat_to_x(self, input_latitude):
    return 110692.0702932625 * (input_latitude - 19)

def long_to_y(self, input_longitude):
    return -105292.0089353767 * (input_longitude - 72)
    # if you use this for control, you may have to change the relevant pitch   direction because of the sign

</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-6"><a class="header" href="#problem-statement-6">Problem Statement</a></h1>
<ul>
<li>
<p>The eDrone starts from the start position i.e. latitude: 19.0009248718 longitude: 71.9998318945 altitude: 22.16, this position is already entered in the relevant world file and the eDrone will spawn at this location itself and it will be in view.</p>
</li>
<li>
<p>It is mandatory that the eDrone start from here during your submission recording.</p>
</li>
<li>
<p>It has to go to latitude: 18.999981931836018 longitude: 71.99983191056211 altitude: 32.15999670352447. There is a building in between the starting point and ending point.</p>
</li>
<li>
<p>Reach the destination with obstacle avoidance and path planning. Use the onboard rangefinder sensors on the eDrone to detect obstacles and navigate around them. While there is no limitation on script structure, it is recommended that you merge the navigation logic in your position control script as we think that will be the easiest way forward.</p>
</li>
</ul>
<h2 id="hints-2"><a class="header" href="#hints-2">Hints</a></h2>
<ul>
<li>
<p>You will use the following boiler scripts:</p>
<ul>
<li>
<p>attitude_controller.py: <center><a href="tasks/task_vd/./attitude_controller.py" download><button>Download</button></a></center></p>
</li>
<li>
<p>position_controller.py: <center><a href="tasks/task_vd/./position_controller.py" download><button>Download</button></a></center></p>
</li>
</ul>
</li>
<li>
<p>attitude controller maked the drone change its roll, pitch, yaw and throttle speed, position controller achieves a postion i.e. height, latitude and longitude with the help of attitude controller.</p>
</li>
<li>
<p>You dont need to do any changes in attitude controller, follow the position controller boiler script and after completing it run you scripts to check the result.</p>
</li>
<li>
<p>first run position controller:</p>
</li>
</ul>
<pre><code class="language-bash">rosrun vitarana_drone position_controller.py
</code></pre>
<ul>
<li>then attitude controller:</li>
</ul>
<pre><code class="language-bash">rosrun vitarana_drone attitude_controller.py

</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-6"><a class="header" href="#expected-output-6">Expected Output</a></h1>
<p><a href="https://www.youtube.com/watch?v=oq6TBaZ-F1o"><img src="https://img.youtube.com/vi/oq6TBaZ-F1o/0.jpg" alt="IMAGE ALT TEXT HERE" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-6"><a class="header" href="#recording-logs-6">Recording Logs</a></h1>
<ul>
<li>
<p>Create a folder called bagfiles in your package as a save destination for the bag files.</p>
</li>
<li>
<p>You can run the rosbag record command separately on the command line. But to not loose any data you will have to start recording precisely at the same moment your drone starts moving. Hence it is a much more preferable option to include the rosbag recording in your launch file itself.</p>
</li>
<li>
<p>Add the following lines to your launch file to have the rosbag record run in parallel with your task.</p>
</li>
</ul>
<pre><code class="language-xml">&lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
&lt;arg name=&quot;duration&quot; default=&quot;120&quot;/&gt;
&lt;arg name=&quot;rec_name&quot; default=&quot;record.bag&quot;/&gt;

&lt;group if=&quot;$(arg record)&quot;&gt;
    &lt;node name=&quot;rosbag_record_drone&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot; args=&quot;record -O $(find vitarana_drone)/bagfiles/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /edrone/gps&quot; output=&quot;screen&quot; /&gt;
&lt;/group&gt;
</code></pre>
<ul>
<li>launch the launch file with the following command:</li>
</ul>
<pre><code class="language-bash">roslaunch vitarana_drone vitarana_drone.launch record:=true rec_name:=drone_record.bag
</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="solution-6"><a class="header" href="#solution-6">Solution</a></h1>
<blockquote>
<p><strong>Note</strong>: Remove this md page from mdbook and delete scripts from src/tasks/task0/ It shows one of the possible solution with autoeval script.</p>
</blockquote>
<p><code>vitarana_drone.launch</code> <center><a href="tasks/task_vd/tasks/task_vd/solution/vitarana_drone.launch" download><button>Download_launch_file</button></a></center></p>
<p><code>position_controller.py</code> <center><a href="tasks/task_vd/tasks/task_vd/solution/position_controller.py" download><button>Download_script</button></a></center></p>
<p><code>attitude_controller.py</code> <center><a href="tasks/task_vd/tasks/task_vd/solution/attitude_controller.py" download><button>Download_script</button></a></center></p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="autoeval-script-3"><a class="header" href="#autoeval-script-3">Autoeval script</a></h1>
<blockquote>
<p>Note: Save this file in a ROS package scripts folder. Then to run this script, run in terminal rosrun autoeval.py. This script prints the result in the terminal window.</p>
</blockquote>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_task2 autoeval.py
# This file will print results on the terminal window

def lat_to_x(input_latitude):
    return 110692.0702932625 * (input_latitude - 19)

def long_to_y(input_longitude):
    return -105292.0089353767 * (input_longitude - 72)

def x_to_lat(input_x):
    return 19 + (input_x)/110692.0702932625

def y_to_lon(input_y):
    return 72 - (input_y)/105292.0089353767

def main():
	bag_files = []
	is_passed = False
	# Change this path to where all bag files are located.
	path = &quot;/home/ubuntu/workspace/src/eysip/vitarana_drone/bagfiles&quot;
	for file in glob.glob(path + &quot;/*.bag&quot;):
		bag_files.append(file)

	# iterate through each file
	for file in bag_files:
		bag = rosbag.Bag(file)
		# look throuhg topics
		topics = bag.get_type_and_topic_info()[1].keys()
		if '/edrone/gps' in topics:
			is_topic_present = True
		else:
			is_topic_present = False
			print('topic not present')
			is_passed = False

		for topic, msg, t in bag.read_messages(topics=['/edrone/gps']):
			if abs(msg.altitude-32.15999670352447) &lt;= 0.2 and abs(lat_to_x(msg.latitude)-lat_to_x(18.999981931836018)) &lt;= 0.2 and abs(long_to_y(msg.longitude)-long_to_y(71.99983191056211)) &lt;= 0.2:
				is_passed = True

		if is_topic_present == True and is_passed == True:
			print(file + ' Result: passed!')
		else:
			print(file + ' Result: failed!')

if __name__ == '__main__':
	main()
</code></pre>
<center><a href="tasks/task_vd/tasks/task_vd/autoeval.py" download><button>Download</button></a></center>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="ur5-multiple-arm"><a class="header" href="#ur5-multiple-arm">UR5 Multiple-Arm</a></h1>
<blockquote>
<p>Welcome to the Task of UR5 Multiple Arm.</p>
</blockquote>
<blockquote>
<p>The aim of this task is to get used to ROS Perception and use it to do sorting using two UR5 Robotics Arms in Gazebo environment.</p>
</blockquote>
<br/>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide-3"><a class="header" href="#installation-guide-3">Installation Guide</a></h1>
<ul>
<li>
<p>Download Vargi Bots Simulation Packages</p>
<ul>
<li>
<p>For this task you would have to update the simulation packages.</p>
</li>
<li>
<p>Download the resources from this link =&gt; <a href="tasks/task_ur5_multiple_arm/vargi_bot_resources.zip" download><button>Download</button></a></p>
</li>
<li>
<p>Unzip and move these folders to <code>src</code> directory of your <code>workspace</code>.</p>
</li>
<li>
<p>Once the repository is downloaded build your workspace and source the <code>setup.bash</code> of your workspace.</p>
</li>
<li>
<p>To check if everything is installed properly enter the following command.</p>
<pre><code class="language-bash">roslaunch pkg_vb_task task_multiple_ur5.launch
</code></pre>
<p>If everything is in place you should see the following environment in Gazebo.</p>
<p><img src="tasks/task_ur5_multiple_arm/./task-multiple-ur5.png" alt="task-multiple-ur5" /></p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Do not edit any files in these packages. If there is any bug in the packages we will notify you.</p>
</blockquote>
<hr />
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement-7"><a class="header" href="#problem-statement-7">Problem Statement</a></h1>
<ul>
<li>
<p><strong>Objective</strong> - The objective of this task is to sort the packages as quickly as possible using the two UR5 Arms (UR5#1 and UR5#2).</p>
<p><img src="tasks/task_ur5_multiple_arm/task-multiple-ur5.png" alt="task-multiple-ur5.png" /></p>
</li>
<li>
<p><strong>Sorting</strong></p>
<ul>
<li>The UR5 (UR5#1 and UR5#2) needs to pick the packages from the conveyor belt and place it the green bins on either side of conveyor belt.</li>
</ul>
</li>
<li>
<p><strong>Collision Avoidance</strong></p>
<ul>
<li>
<p>While sorting the packages the team needs to make sure that the UR5 (UR5#1 and UR5#2) are not colliding with the conveyor belt, packages on conveyor belt, the bins or with itself.</p>
</li>
<li>
<p>Once a package is picked, the team needs to make sure the package is also not colliding with anything.</p>
</li>
<li>
<p>You can add scene objects directly from launch file to RViz to avoid collision.</p>
</li>
</ul>
</li>
<li>
<p><strong>Logical Camera and Conveyor Belt</strong></p>
<ul>
<li>
<p>The team needs to use the feed from Logical Camera in this task to detect packages.</p>
</li>
<li>
<p>The team would also have to control the conveyor belt in order to make the packages reach the UR5 (UR5#1 and UR5#2).</p>
</li>
</ul>
</li>
<li>
<p><strong>TF</strong></p>
<ul>
<li>In this task do not rely on TF values as they can fluctuate since we are using two UR5 arms. We would suggest the teams to use <code>Logical Camera#2</code> feed to manually calculate the translations. </li>
</ul>
</li>
<li>
<p><strong>Simulation Time</strong></p>
<ul>
<li>
<p>In this task simulation time will be considered for grading. So, the teams must make sure to keep the simulation time as low as possible by quickly sorting the packages.</p>
</li>
<li>
<p><strong>Strategies to decrease Simulation Time</strong></p>
<ul>
<li>The team can make use of both arms to quickly sort packages.</li>
<li>The team can operate the conveyor belt at maximum speed so that packages reach the UR5 faster.</li>
<li>The team can make the UR5 pick the packages from a moving conveyor belt.</li>
<li>Or any other such strategies.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>ROS Packages required:</strong></p>
<ol>
<li>
<p><code>pkg_moveit_ur5_1</code>: The team will have to generate this package using MoveIt! Setup Assistant which will configure MoveIt! for the UR5#1. For this use <code>ur5_1.urdf</code> in <code>pkg_vb_sim/urdf</code>.</p>
<blockquote>
<p><strong>NOTE</strong>: This package is also available in Vargi Bots Simulation Packages as <code>pkg_moveit_ur5_1_config</code> with default configuration. You may refer that package to generate this package if you want to configure this your own way or you are free to use this package also.</p>
</blockquote>
</li>
<li>
<p><code>pkg_moveit_ur5_2</code>: The team will have to generate this package using MoveIt! Setup Assistant which will configure MoveIt! for the UR5#2. For this use <code>ur5_2.urdf</code> in <code>pkg_vb_sim/urdf</code>.</p>
<blockquote>
<p><strong>NOTE</strong>: This package is also available in Vargi Bots Simulation Packages as <code>pkg_moveit_ur5_2_config</code> with default configuration. You may refer that package to generate this package if you want to configure this your own way or you are free to use this package also.</p>
</blockquote>
</li>
<li>
<p><code>pkg_vb_solution</code>: This is the ROS package in which the team is supposed to implement this task.</p>
</li>
<li>
<p><code>Vargi Bots Simulation Packages</code>: These packages will have the simulation environment needed for this task.</p>
</li>
</ol>
</li>
</ul>
<h2 id="pkg_vb_solution"><a class="header" href="#pkg_vb_solution">pkg_vb_solution</a></h2>
<ul>
<li>In this task, teams are allowed to have their own structure for this package. This means that teams can have any number of nodes (Python Scripts <strong>only</strong>), message files, service files, action files, config files etc. in order to solve the task.</li>
</ul>
<h3 id="task_sortlaunch"><a class="header" href="#task_sortlaunch"><code>task_sort.launch</code></a></h3>
<ul>
<li>
<p>It is compulsory for the teams to have a launch file called <code>task_sort.launch</code> that will launch the simulation environment and all the necessary nodes that are required to solve this task. While evaluating we are going to use this launch file to run your implementation so make sure that this launch file is proper.</p>
</li>
<li>
<p>In this launch file you need to include the following in order to spawn all the necessary models and nodes for simulation.</p>
<pre><code class="language-xml">&lt;!-- Launch Simulation environment in Gazebo --&gt;
&lt;include file=&quot;$(find pkg_vb_task)/launch/task_multiple_ur5.launch&quot;/&gt;
</code></pre>
</li>
<li>
<p>You will also launch <code>two_ur5_move_group.launch</code> if you decide to use <code>pkg_moveit_ur5_1_config</code> and <code>pkg_moveit_ur5_2_config</code> instead of your own MoveIt! Configuration Packages for both the UR5 arms.</p>
<pre><code class="language-xml">&lt;!-- Launch the two ur5 arms with MoveIt! in RViz --&gt;
&lt;include file=&quot;$(find pkg_vb_sim)/launch/two_ur5_move_group.launch&quot; /&gt;
</code></pre>
</li>
<li>
<p>If you are using your own <code>pkg_moveit_ur5_1</code> and <code>pkg_moveit_ur5_2</code> packages then you would have to include your own version of <code>two_ur5_move_group.launch</code>.</p>
</li>
<li>
<p>Properly comment this launch file. You need to add detailed description of all the nodes that you are going to include in this file as comments. For example,</p>
<pre><code class="language-xml">&lt;!-- This node is for .....  --&gt;
&lt;!-- It is also .....  --&gt;
&lt;node name= &quot;node_sort&quot; pkg= &quot;pkg_vb_solution&quot; type=&quot;node_packages_sort.py&quot; output=&quot;screen&quot;/&gt;
</code></pre>
</li>
</ul>
<h3 id="bag_files-folder"><a class="header" href="#bag_files-folder"><code>bag_files</code> folder</a></h3>
<ul>
<li>
<p>The team would have to create this folder in <code>pkg_vb_solution</code> for storing the bag file.</p>
</li>
<li>
<p>Instructions to record bag file is given in <a href="tasks/task_ur5_multiple_arm/recording_logs.html">Recording Logs</a>.</p>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-7"><a class="header" href="#expected-output-7">Expected Output</a></h1>
<ul>
<li>The following video can be considered as a valid output.</li>
</ul>
<center><iframe width="750" height="476"
src="https://www.youtube.com/embed/-7VnkNJFaQY">
</iframe></center>
<blockquote>
<p><strong>NOTE</strong>: This is just one way to solve this task and not the only way. Your way to solve this task can be different.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs-7"><a class="header" href="#recording-logs-7">Recording Logs</a></h1>
<ul>
<li>
<p>For recording the bags in this Task, you can refer to this <a href="tasks/task_ur5_multiple_arm/../task0/recording-logs.html">section</a>.</p>
</li>
<li>
<p>This launch file will specifically make use of <code>/eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1</code> and <code>/eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2</code> ROS topics so make sure to specify these as shown below.</p>
</li>
<li>
<p>We recommend you to add the following in your <code>task_sort.launch</code> in order to record everything properly as soon as you start other nodes.</p>
</li>
<li>
<p>Make sure to create a directory called <code>bag_files</code> within your <code>pkg_vb_solution</code> package where your bag files will get stored.</p>
<pre><code class="language-xml">&lt;!-- Recording Bag File for Submission --&gt;
    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;vb.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_pick&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot; args=&quot;record -O $(find pkg_vb_solution)/bag_files/$(arg rec_name) --chunksize=10 /eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1 /eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2&quot; output=&quot;screen&quot;/&gt;
    &lt;/group&gt;

</code></pre>
</li>
<li>
<p>Verify that your bag file is properly recorded by using the <code>rosbag info</code> command followed by the absolute or relative path of the file.</p>
</li>
<li>
<p>You can use the <code>rostopic echo -b vb.bag /eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1</code> command to display the messages from the topic onto your bag file.</p>
</li>
<li>
<p>If you want to record the bag file needed for submission you would have to run the following command.</p>
<pre><code class="language-bash">roslaunch pkg_vb_solution task_sort.launch record:=true rec_name:=vb.bag
</code></pre>
</li>
<li>
<p>If you just want to run your implementation without recording a bag file. Do the following.</p>
<pre><code class="language-bash">roslaunch pkg_vb_solution task_sort.launch
</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-7"><a class="header" href="#solution-7">Solution</a></h1>
<ul>
<li>Complete solution is in this zip file =&gt; <a href="tasks/task_ur5_multiple_arm/pkg_vb_solution.zip" download><button>Download</button></a></li>
</ul>
<br/>
<ul>
<li>
<p>To run the solution, launch this file.</p>
<pre><code class="language-bash">roslaunch pkg_vb_solution task_sort.launch
</code></pre>
</li>
</ul>
<h3 id="sim_env"><a class="header" href="#sim_env"><code>sim_env</code></a></h3>
<ul>
<li>This python package contains methods to control conveyor belt, vacuum gripper and logical cameras.</li>
</ul>
<h3 id="ur5_moveit"><a class="header" href="#ur5_moveit"><code>ur5_moveit</code></a></h3>
<ul>
<li>This python package includes MoveIt! methods to control motion of UR5 robot arm.</li>
</ul>
<h3 id="config_envyaml"><a class="header" href="#config_envyaml"><code>config_env.yaml</code></a></h3>
<ul>
<li>It contains configurations of simulation environment.</li>
</ul>
<h3 id="config_ur5yaml"><a class="header" href="#config_ur5yaml"><code>config_ur5.yaml</code></a></h3>
<ul>
<li>This file overwrites some of the config of ompl_planning.yaml</li>
</ul>
<h3 id="node_sort_packagespy"><a class="header" href="#node_sort_packagespy"><code>node_sort_packages.py</code></a></h3>
<ul>
<li>
<p>This python scripts sorts the packages spawned on conveyor belt using two UR5 robotic arm (UR5#1 and UR5#2).</p>
</li>
<li>
<p>It makes use of python modules <code>env.py</code> and <code>ur5.py</code> of <strong>sim_env</strong> and <strong>ur5_moveit</strong> python packages respectively.</p>
</li>
<li>
<p>We’re only using one UR5 arm at a time for demonstration purposes. Teams can use both arms simultaneously.</p>
<pre><code class="language-python">#! /usr/bin/env python3

from sim_env.env import ControlSimEnv
from ur5_moveit.ur5 import Ur5Moveit
import rospy

from hrwros_gazebo.msg import LogicalCameraImage
from geometry_msgs.msg import Pose

import threading


package_detected = False
model = ''
model_pos = Pose()
ur5_joint_angles_dict = {}


def clbk_logical_camera_2(model_msg):
    '''Callback to subscriber topic. This detects models
        under logical cameras from ROS topic

        :param model_msg: Custom message file imported from
            `hrwros_gazebo.msg.LogicalCameraImage` that is a list of
            models and their position and position of logical camera
        :type model_msg: hrwros_gazebo.msg.LogicalCameraImage
        '''
    global package_detected, model, model_pos
    model_info = LogicalCameraImage().models
    logical_camera_pos = Pose()
    model_info = model_msg.models
    logical_camera_pos = model_msg.pose
    # Save model type and model position is separate variables
    for mdl in range(len(model_msg.models)):
        model = model_msg.models[mdl].type
        model_pos = model_msg.models[mdl].pose
        # Check if package is in logical camera frustum
        package_detected = &quot;package&quot; in model


def main():
    '''Main Function: Initialize the node and start sorting of packages.'''

    global package_detected, model, model_pos, ur5_joint_angles_dict

    rospy.init_node('node_sort_packages')

    ur5_1 = Ur5Moveit('ur5_1')
    env_1 = ControlSimEnv('1')
    ur5_2 = Ur5Moveit('ur5_2')
    env_2 = ControlSimEnv('2')

    ur5_1.group.set_planning_time(5)
    ur5_1.group.set_planner_id(&quot;RRTConnect&quot;)
    ur5_2.group.set_planning_time(5)
    ur5_2.group.set_planner_id(&quot;RRTStar&quot;)
    sub_lc = rospy.Subscriber(
        &quot;/eyrc/vb/logical_camera_2&quot;, LogicalCameraImage, clbk_logical_camera_2)

    ur5_joint_angles_dict = {
        &quot;ur5_1_pick_home&quot;: ur5_1.list_degrees_to_radians([180, -28, 35, -97, -90, 0]),
        &quot;ur5_2_pick_home&quot;: ur5_1.list_degrees_to_radians([180, -55, 84, -119, -90, 0]),
        &quot;red_bin&quot;: ur5_1.list_degrees_to_radians([80, -50, 70, -110, -90, 0]),
        &quot;green_bin&quot;: ur5_1.list_degrees_to_radians([180, -150, -40, -80, 90, 0]),
        &quot;blue_bin&quot;: ur5_1.list_degrees_to_radians([-95, -50, 70, -110, -90, 0])
    }

    ur5_1.set_joint_angles(ur5_joint_angles_dict[&quot;ur5_1_pick_home&quot;])
    ur5_2.set_joint_angles(ur5_joint_angles_dict[&quot;ur5_2_pick_home&quot;])
    env_1.belt_speed(100)

    while not rospy.is_shutdown():
        if not package_detected:
            env_1.belt_speed(30)
            continue
        picked = False
        rospy.loginfo(model)

        if &quot;00&quot; in model or &quot;02&quot; in model or &quot;11&quot; in model or &quot;20&quot; in model:
            while not picked:
                if 0.39 &lt; model_pos.position.y &lt; 0.41 and package_detected:
                    env_1.belt_speed(0)
                    # while not env_1.package_detected:
                    #     ur5_1.ee_cartesian_translation(
                    #         model_pos.position.z, 0, 0)
                    picked = env_1.pick_package()

            ur5_1.hard_set_joint_angles(ur5_joint_angles_dict[&quot;green_bin&quot;])
            picked = env_1.drop_package()
            ur5_1.set_joint_angles(ur5_joint_angles_dict[&quot;ur5_1_pick_home&quot;])
        elif &quot;01&quot; in model or &quot;10&quot; in model or &quot;12&quot; in model:
            while not picked:
                if -0.21 &lt; model_pos.position.y &lt; -0.19 and package_detected:
                    env_2.belt_speed(0)
                    # while not env_2.package_detected:
                    #     ur5_2.ee_cartesian_translation(
                    #         model_pos.position.z, 0, 0)
                    picked = env_2.pick_package()

            ur5_2.hard_set_joint_angles(ur5_joint_angles_dict[&quot;green_bin&quot;])
            picked = env_2.drop_package()
            ur5_2.set_joint_angles(ur5_joint_angles_dict[&quot;ur5_2_pick_home&quot;])
        else:
            rospy.loginfo(&quot;Waiting for package!&quot;)

    sub_lc.unregister()


if __name__ == '__main__':
    main()

</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoevaluation-script-2"><a class="header" href="#autoevaluation-script-2">Autoevaluation Script</a></h1>
<h2 id="how-to-use-3"><a class="header" href="#how-to-use-3">How to use</a></h2>
<p>This script can take any number of bag files stored in <code>/home/ubuntu/workspace/src/pkg_vb_solution/bag_files</code>
and create a <code>results.csv</code> output which will show the result of micromouse bag files.</p>
<pre><code class="language-bash">rosrun pkg_vb_solution autoeval.py
</code></pre>
<p>This will generate <code>results.csv</code> in bag files location.</p>
<blockquote>
<p><strong>Note</strong>: Packages detected can be greater than 6 because one package can be detected by both arms but only sorted by one.</p>
</blockquote>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_vb_solution autoeval.py
# ROS Topics required: /eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1
# /eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2


def check_for_successful_drop(package):
    # Check for successful drop from the last location of package
    # UR5_1 drop location
    if 0.5 &lt; package[1] &lt; 1.0 and 0.2 &lt; package[2] &lt; 0.7:
        return True
    # UR5_2 drop location
    if -2.5 &lt; package[1] &lt; -2.0 and -0.5 &lt; package[2] &lt; 0.0:
        return True
    else:
        return False


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/pkg_vb_solution/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)
        data_writer.writerow(['Filename', 'Does bag files has rostopic?', 'Package detected by UR5_1',
                              'Package detected by UR5_2', 'Total Package detected', 'Successfully dropped by UR5_1',
                              'Successfully dropped by UR5_2', 'Total Dropped', 'Simulation Time', 'Is Passed', 'Remark'])

        # iterate through each file
        for file in bag_files:
            bag = rosbag.Bag(file)
            is_topic_present = False
            is_passed = False
            ur5_1_package_detected = []
            ur5_2_package_detected = []
            package_detected = 0
            ur5_1_successful_drop = []
            ur5_2_successful_drop = []
            package_dropped = 0
            time_taken = None
            previous_model = None
            ur5_1_model_list = []
            ur5_2_model_list = []
            remark = ''

            # look throuhg topics
            topics = bag.get_type_and_topic_info()[1].keys()
            if '/eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1' in topics and \
                    '/eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2' in topics:
                is_topic_present = True
            else:
                is_topic_present = False
                print('topic not present')
                is_passed = False

            for topic, msg, t in bag.read_messages(
                    topics=['/eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1']):
                for model in msg.models:
                    ur5_1_model_list.append(
                        (model.type, msg.pose.position.x, msg.pose.position.y, t))
                    if model.type != previous_model:
                        ur5_1_package_detected.append(model.type)
                        package_detected += 1
                    previous_model = model.type

            for topic, msg, t in bag.read_messages(
                    topics=['/eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2']):
                for model in msg.models:
                    ur5_2_model_list.append(
                        (model.type, msg.pose.position.x, msg.pose.position.y, t))
                    if model.type != previous_model:
                        ur5_2_package_detected.append(model.type)
                        package_detected += 1
                    previous_model = model.type

            for package in ur5_1_package_detected:
                package_info = [(model_type, x, y, t) for (
                    model_type, x, y, t) in ur5_1_model_list if model_type == package]
                # Check for successful drop from the last location of package
                success = check_for_successful_drop(
                    package_info[-1])
                if success:
                    package_dropped += 1
                    ur5_1_successful_drop.append(package_info[0][0])

            for package in ur5_2_package_detected:
                package_info = [(model_type, x, y, t) for (
                    model_type, x, y, t) in ur5_2_model_list if model_type == package]
                # Check for successful drop from the last location of package
                success = check_for_successful_drop(
                    package_info[-1])
                if success:
                    package_dropped += 1
                ur5_2_successful_drop.append(package_info[0][0])

            if is_topic_present:
                if ur5_1_model_list[0][3] &lt; ur5_2_model_list[0][3]:
                    start_time = ur5_1_model_list[0][3].to_sec()
                elif ur5_1_model_list[0][3] &gt; ur5_2_model_list[0][3]:
                    start_time = ur5_2_model_list[0][3].to_sec()

                if ur5_1_model_list[-1][3] &gt; ur5_2_model_list[-1][3]:
                    end_time = ur5_1_model_list[-1][3].to_sec()
                elif ur5_1_model_list[-1][3] &lt; ur5_2_model_list[-1][3]:
                    end_time = ur5_1_model_list[-1][3].to_sec()

                time_taken = end_time - start_time

            if package_dropped == 6:
                is_passed = True

            if is_topic_present and is_passed:
                remark = &quot;Passed! All packages are sorted.&quot;
                print(file + ' Result: passed!')
            elif is_topic_present and package_dropped &lt; 6:
                remark = &quot;Only &quot; + str(package_dropped) + \
                    &quot; packages are sorted correctly.&quot;
                print(file + ' Result: Incomplete.')
            else:
                remark = &quot;Failed!&quot;
                print(file + ' Result: failed!')

            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], is_topic_present, ur5_1_package_detected, ur5_2_package_detected,
                 package_detected, ur5_1_successful_drop, ur5_2_successful_drop, package_dropped, time_taken, is_passed, remark])

        bag.close()
    data_file.close()


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task_ur5_multiple_arm/autoeval.py" download><button>Download</button></a></center>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="simbhabot-1"><a class="header" href="#simbhabot-1">Simbhabot</a></h1>
<p>Welcome to the sahayak bot mini-project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-2"><a class="header" href="#installation-2">Installation</a></h1>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<ul>
<li>
<p>First, we need a workspace. You can use an existing one or create a new one.</p>
<pre><code class="language-bash">cd ~/workspace/
catkin_make
</code></pre>
<pre><code class="language-bash">source devel/setup.bash:
</code></pre>
</li>
<li>
<p>To source your new <code>setup.*sh</code> file. This command can also be added to you <code>~/.bashrc</code> file</p>
</li>
</ul>
<h2 id="cloning-the-sahayak-bot-repository"><a class="header" href="#cloning-the-sahayak-bot-repository">Cloning the Sahayak Bot repository</a></h2>
<ul>
<li>
<p>Navigate inside your <code>catkin_ws/src</code> directory.</p>
<pre><code class="language-bash">cd ~/workspace/src
</code></pre>
</li>
<li>
<p>Clone the repository…</p>
<pre><code class="language-bash">git clone https://github.com/vishalgpt579/sahayak_bot.git

</code></pre>
</li>
</ul>
<blockquote>
<p>For user who don’t have <code>git</code> installed. Simply enter <code>sudo apt install git</code></p>
</blockquote>
<ul>
<li>
<p>This package will take time to download, due to its large size file such as the stl, meshes, images and executables files.</p>
</li>
<li>
<p>Finally build your catkin workspace using <code>catkin_make</code> command.</p>
</li>
<li>
<p>U will also need another package <code>ebot_nav</code> to navigate the bot in gazebo. Download the package from the button below (which is a zip file) and extract its content in your <code>workspace/src</code> directory.</p>
</li>
</ul>
<center><a href="tasks/task_sahayak_bot/tasks/task_sahayak_bot/ebot_nav.zip" download><button>Download</button></a></center>
<ul>
<li>
<p>After extracting dont forget to build your packages.</p>
<pre><code class="language-bash">cd ~/workspace/
caktkin_make
</code></pre>
</li>
</ul>
<h2 id="addidtion-installation"><a class="header" href="#addidtion-installation">Addidtion Installation</a></h2>
<ul>
<li>
<p>Additional installations are also required to run the sahayak bot, follow the below instructions to install them.</p>
<pre><code class="language-bash">sudo apt-get install ros-noetic-object-recognition-msgs
</code></pre>
<pre><code class="language-bash">sudo apt-get install ros-noetic-navigation
</code></pre>
</li>
</ul>
<p>now you should be able to run the package</p>
<h2 id="running-sahayak-bot"><a class="header" href="#running-sahayak-bot">Running Sahayak Bot</a></h2>
<p>to run Sahayak Bot u will need to do run the following commands:</p>
<ul>
<li>in one terminal:
<pre><code class="language-bash">roslaunch ebot_description task2.launch
</code></pre>
</li>
<li>in second terminal:
<pre><code class="language-bash">roslaunch ebot_nav autonomous_nav.launch
</code></pre>
</li>
</ul>
<p>you should be able to see the sahayak bot in gazebo window moving.</p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="expected-output-8"><a class="header" href="#expected-output-8">Expected Output</a></h1>
<p><a href="https://www.youtube.com/watch?v=xnjWQ1P6-AY"><img src="https://img.youtube.com/vi/xnjWQ1P6-AY/0.jpg" alt="IMAGE ALT TEXT HERE" /></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
